import { spawn } from "node:child_process";
import promises from "node:fs/promises";
import { createRequire } from "node:module";
import node_path from "node:path";
import { pathToFileURL } from "node:url";
import { logger } from "@rsbuild/core";
import picocolors from "../compiled/picocolors/index.js";
import { getTimeCost, globDtsFiles, processDtsFiles, renameDtsFile, updateDeclarationMapContent } from "./utils.js";
const tsgo_require = createRequire(import.meta.url);
const logPrefixTsgo = picocolors.dim('[tsgo]');
const getTsgoBinPath = async ()=>{
    const tsgoPkgPath = tsgo_require.resolve("@typescript/native-preview/package.json");
    const libPath = node_path.resolve(node_path.dirname(tsgoPkgPath), './lib/getExePath.js');
    let fileUrl;
    fileUrl = 'win32' === process.platform ? pathToFileURL(libPath).href : libPath;
    return import(fileUrl).then((mod)=>{
        const getExePath = mod.default;
        return getExePath();
    });
};
const generateTsgoArgs = (configPath, declarationDir, build, isWatch)=>{
    const args = [];
    if (build) args.push('--build', configPath);
    else {
        args.push('--project', configPath);
        args.push('--declarationDir', declarationDir);
    }
    args.push('--noEmit', 'false');
    args.push('--declaration');
    args.push('--emitDeclarationOnly');
    return args;
};
async function handleDiagnosticsAndProcessFiles(isWatch, hasErrors, tsConfigResult, configPath, bundle, declarationDir, dtsExtension, redirect, rootDir, paths, banner, footer, name) {
    if (!bundle) {
        const dtsFiles = await globDtsFiles(declarationDir, [
            '/**/*.d.ts',
            '/**/*.d.ts.map'
        ]);
        await Promise.all(dtsFiles.map(async (file)=>{
            const contents = await promises.readFile(file, 'utf8');
            const newFileName = renameDtsFile(file, dtsExtension, bundle);
            const newContents = updateDeclarationMapContent(file, contents, dtsExtension, bundle, tsConfigResult.options.declarationMap);
            if (file !== newFileName || contents !== newContents) {
                await promises.writeFile(newFileName, newContents);
                await promises.unlink(file);
            }
        }));
    }
    await processDtsFiles(bundle, declarationDir, dtsExtension, redirect, configPath, rootDir, paths, banner, footer);
    if (hasErrors && !isWatch) {
        const error = new Error(`Failed to generate declaration files. ${picocolors.dim(`(${name})`)}`);
        error.stack = '';
        throw error;
    }
}
async function emitDtsTsgo(options, _onComplete, bundle = false, isWatch = false, build = false) {
    const start = Date.now();
    const { configPath, tsConfigResult, declarationDir, name, dtsExtension, rootDir, banner, footer, paths, redirect, cwd } = options;
    const tsgoBinFile = await getTsgoBinPath();
    const args = generateTsgoArgs(configPath, declarationDir, build, isWatch);
    logger.debug(logPrefixTsgo, `Running: ${tsgoBinFile} ${args.join(' ')}`);
    return new Promise((resolve, reject)=>{
        const childProcess = spawn(tsgoBinFile, [
            ...args,
            '--pretty'
        ], {
            cwd,
            stdio: [
                'inherit',
                'pipe',
                'pipe'
            ]
        });
        let hasErrors = false;
        childProcess.stdout?.on('data', (data)=>{
            const output = data.toString();
            const lines = output.split('\n');
            for (const line of lines)if (line.trim()) console.log(picocolors.reset(`${logPrefixTsgo} ${line}`));
        });
        childProcess.stderr?.on('data', (data)=>{
            const output = data.toString();
            const lines = output.split('\n').filter((line)=>line.trim());
            for (const line of lines)logger.error(logPrefixTsgo, line);
        });
        childProcess.on('close', async (code)=>{
            try {
                if (0 !== code) hasErrors = true;
                await handleDiagnosticsAndProcessFiles(isWatch, hasErrors, tsConfigResult, configPath, bundle, declarationDir, dtsExtension, redirect, rootDir, paths, banner, footer, name);
                if (!hasErrors) if (bundle) logger.info(`declaration files prepared with tsgo in ${getTimeCost(start)} ${picocolors.dim(`(${name})`)}`);
                else logger.ready(`declaration files generated with tsgo in ${getTimeCost(start)} ${picocolors.dim(`(${name})`)}`);
                resolve(hasErrors);
            } catch (error) {
                reject(error instanceof Error ? error : new Error(String(error)));
            }
        });
    });
}
export { emitDtsTsgo };
