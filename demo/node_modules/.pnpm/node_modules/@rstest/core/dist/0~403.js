import 'module';
/*#__PURE__*/ import.meta.url;
import { isDynamicPattern, glob } from "./157.js";
import { normalize, logger_logger } from "./278.js";
const getIncludedFiles = async (coverage, rootPath)=>{
    const ignoredPatterns = coverage.exclude?.filter((item)=>isDynamicPattern(item) || item.startsWith(rootPath) || item.startsWith('./'));
    const allFiles = await glob(coverage.include, {
        cwd: rootPath,
        absolute: true,
        onlyFiles: true,
        ignore: ignoredPatterns,
        dot: true,
        expandDirectories: false
    });
    if (ignoredPatterns?.length !== coverage.exclude?.length) {
        const excludes = coverage.exclude.filter((item)=>!isDynamicPattern(item) && !item.startsWith(rootPath) && !item.startsWith('./'));
        return allFiles.filter((file)=>!excludes.some((exclude)=>file.includes(exclude)));
    }
    return allFiles;
};
async function generateCoverage(context, results, coverageProvider) {
    const { rootPath, normalizedConfig: { coverage }, projects } = context;
    try {
        const finalCoverageMap = coverageProvider.createCoverageMap();
        for (const result of results)if (result.coverage) finalCoverageMap.merge(result.coverage);
        if (coverage.include?.length) {
            const coveredFiles = finalCoverageMap.files();
            let isTimeout = false;
            const timeoutId = setTimeout(()=>{
                isTimeout = true;
                logger_logger.info('Generating coverage for untested files...');
            }, 1000);
            const allFiles = (await Promise.all(projects.map(async (p)=>{
                const includedFiles = await getIncludedFiles(coverage, p.rootPath);
                const uncoveredFiles = includedFiles.filter((file)=>!coveredFiles.includes(normalize(file)));
                if (uncoveredFiles.length) await generateCoverageForUntestedFiles(p.environmentName, uncoveredFiles, finalCoverageMap, coverageProvider);
                return includedFiles;
            }))).flat();
            clearTimeout(timeoutId);
            if (isTimeout) logger_logger.info('Coverage for untested files generated.');
            finalCoverageMap.filter((file)=>allFiles.includes(normalize(file)));
        }
        await coverageProvider.generateReports(finalCoverageMap, coverage);
        if (coverage.thresholds) {
            const { checkThresholds } = await import("./0~426.js").then((mod)=>({
                    checkThresholds: mod.checkThresholds
                }));
            const thresholdResult = checkThresholds({
                coverageMap: finalCoverageMap,
                coverageProvider,
                rootPath,
                thresholds: coverage.thresholds
            });
            if (!thresholdResult.success) {
                logger_logger.log('');
                logger_logger.log(thresholdResult.message);
                process.exitCode = 1;
            }
        }
    } catch (error) {
        logger_logger.error('Failed to generate coverage reports:', error);
    }
}
async function generateCoverageForUntestedFiles(environmentName, uncoveredFiles, coverageMap, coverageProvider) {
    if (!coverageProvider.generateCoverageForUntestedFiles) return void logger_logger.warn('Current coverage provider does not support generating coverage for untested files.');
    const coverages = await coverageProvider.generateCoverageForUntestedFiles({
        environmentName,
        files: uncoveredFiles
    });
    coverages.forEach((coverageData)=>{
        coverageMap.addFileCoverage(coverageData);
    });
}
export { generateCoverage };
