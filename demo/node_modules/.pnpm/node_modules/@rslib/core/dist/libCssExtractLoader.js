import { isCssModulesFile, node_path, extname, ABSOLUTE_PUBLIC_PATH, SINGLE_DOT_PATH_SEGMENT, BASE_URI, AUTO_PUBLIC_PATH } from "./800.js";
const LOADER_NAME = 'LIB_CSS_EXTRACT_LOADER';
function stringifyLocal(value) {
    return 'function' == typeof value ? value.toString() : JSON.stringify(value);
}
const libCssExtractLoader_loader = function(content) {
    if (this._compiler?.options?.experiments?.css && this._module && ('css' === this._module.type || 'css/auto' === this._module.type || 'css/global' === this._module.type || 'css/module' === this._module.type)) return content;
};
const pitch = function(request, _, _data) {
    if (this._compiler?.options?.experiments?.css && this._module && ('css' === this._module.type || 'css/auto' === this._module.type || 'css/global' === this._module.type || 'css/module' === this._module.type)) {
        const e = new Error("use type 'css' and `CssExtractRspackPlugin` together, please set `experiments.css` to `false` or set `{ type: \"javascript/auto\" }` for rules with `CssExtractRspackPlugin` in your rspack config (now `CssExtractRspackPlugin` does nothing).");
        e.stack = void 0;
        this.emitWarning(e);
        return;
    }
    const options = this.getOptions();
    const emit = void 0 !== options.emit ? options.emit : true;
    const callback = this.async();
    const filepath = this.resourcePath;
    const rootDir = options.rootDir ?? this.rootContext;
    const auto = options.auto;
    const banner = options.banner;
    const footer = options.footer;
    let { publicPath } = this._compilation.outputOptions;
    if ('string' == typeof options.publicPath) publicPath = options.publicPath;
    else if ('function' == typeof options.publicPath) publicPath = options.publicPath(this.resourcePath, this.rootContext);
    if ('auto' === publicPath) publicPath = AUTO_PUBLIC_PATH;
    let publicPathForExtract;
    if ('string' == typeof publicPath) {
        const isAbsolutePublicPath = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/.test(publicPath);
        publicPathForExtract = isAbsolutePublicPath ? publicPath : `${ABSOLUTE_PUBLIC_PATH}${publicPath.replace(/\./g, SINGLE_DOT_PATH_SEGMENT)}`;
    } else publicPathForExtract = publicPath;
    const handleExports = (originalExports)=>{
        let locals;
        let namedExport;
        const esModule = void 0 !== options.esModule ? options.esModule : true;
        let dependencies = [];
        try {
            const exports = originalExports.__esModule ? originalExports.default : originalExports;
            namedExport = originalExports.__esModule && (!originalExports.default || !('locals' in originalExports.default));
            if (namedExport) {
                for (const key of Object.keys(originalExports))if ('default' !== key) {
                    if (!locals) locals = {};
                    locals[key] = originalExports[key];
                }
            } else locals = exports?.locals;
            if (Array.isArray(exports) && emit) {
                const identifierCountMap = new Map();
                dependencies = exports.map(([id, content, media, sourceMap, supports, layer])=>{
                    const identifier = id;
                    const context = this.rootContext;
                    const count = identifierCountMap.get(identifier) || 0;
                    identifierCountMap.set(identifier, count + 1);
                    return {
                        identifier,
                        context,
                        content,
                        media,
                        supports,
                        layer,
                        identifierIndex: count,
                        sourceMap: sourceMap ? JSON.stringify(sourceMap) : void 0,
                        filepath
                    };
                }).filter((item)=>null !== item);
            }
        } catch (e) {
            callback(e);
            return;
        }
        const result = function() {
            if (locals) {
                if (namedExport) {
                    const identifiers = Array.from(function*() {
                        let identifierId = 0;
                        for (const key of Object.keys(locals)){
                            identifierId += 1;
                            yield [
                                `_${identifierId.toString(16)}`,
                                key
                            ];
                        }
                    }());
                    const localsString = identifiers.map(([id, key])=>`\nvar ${id} = ${stringifyLocal(locals[key])};`).join('');
                    const exportsString = `export { ${identifiers.map(([id, key])=>`${id} as ${JSON.stringify(key)}`).join(', ')} }`;
                    const defaultExport = void 0 !== options.defaultExport ? options.defaultExport : false;
                    return defaultExport ? `${localsString}\n${exportsString}\nexport default { ${identifiers.map(([id, key])=>`${JSON.stringify(key)}: ${id}`).join(', ')} }\n` : `${localsString}\n${exportsString}\n`;
                }
                return `\n${esModule ? 'export default' : 'module.exports = '} ${JSON.stringify(locals)};`;
            }
            if (esModule) return '\nexport {};';
            return '';
        }();
        let resultSource = `// extracted by ${LOADER_NAME}`;
        let importCssFiles = '';
        function getRelativePath(from, to) {
            let relativePath = node_path.relative(from, to);
            if (!relativePath.startsWith('./') && !relativePath.startsWith('../') && !node_path.isAbsolute(relativePath)) relativePath = `./${relativePath}`;
            return relativePath;
        }
        const m = new Map();
        for (const { content, filepath, sourceMap } of dependencies){
            let distFilepath = getRelativePath(rootDir, filepath);
            const ext = extname(distFilepath);
            if ('css' !== ext) distFilepath = distFilepath.replace(ext, '.css');
            if (isCssModulesFile(filepath, auto)) distFilepath = distFilepath.replace(/\.module\.css/, '_module.css');
            const cssFilename = node_path.basename(distFilepath);
            if (content.trim()) {
                m.get(distFilepath) ? m.set(distFilepath, `${m.get(distFilepath) + content}\n`) : m.set(distFilepath, `${content}\n`);
                importCssFiles += '\n';
                importCssFiles += `import "./${cssFilename}"`;
            }
            if (sourceMap) {
                const sourceMapPath = `${distFilepath}.map`;
                m.set(sourceMapPath, sourceMap);
                const sourceMappingURL = `/*# sourceMappingURL=${cssFilename}.map */`;
                m.set(distFilepath, `${m.get(distFilepath)}\n${sourceMappingURL}`);
            }
        }
        for (let [distFilepath, content] of m.entries()){
            if (banner) content = `${banner}\n${content}`;
            if (footer) content = `${content}\n${footer}\n`;
            this.emitFile(distFilepath, content);
        }
        resultSource += importCssFiles;
        resultSource += result;
        callback(null, resultSource, void 0);
    };
    this.importModule(`${this.resourcePath}.webpack[javascript/auto]!=!!!${request}`, {
        layer: options.layer,
        publicPath: publicPathForExtract,
        baseUri: `${BASE_URI}/`
    }, (error, exports)=>{
        if (error) return void callback(error);
        handleExports(exports);
    });
};
const libCssExtractLoader = libCssExtractLoader_loader;
export default libCssExtractLoader;
export { pitch };
