/*! For license information please see 0~151.js.LICENSE.txt */
import 'module';
/*#__PURE__*/ import.meta.url;
import { __webpack_require__ } from "./rslib-runtime.js";
import "./664.js";
import { resolve as pathe_M_eThtNZ_resolve } from "./278.js";
import { getTaskNameWithPrefix, isObject as helper_isObject, castArray, ROOT_SUITE_NAME } from "./157.js";
import { getRealTimers, TestRegisterError, formatTestError, formatName } from "./913.js";
import { fileURLToPath } from "./198.js";
import { parse } from "./672.js";
import "./554.js";
__webpack_require__.add({
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/called-in-order.js" (module, __unused_rspack_exports, __webpack_require__) {
        var every = __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/array.js").every;
        function hasCallsLeft(callMap, spy) {
            if (void 0 === callMap[spy.id]) callMap[spy.id] = 0;
            return callMap[spy.id] < spy.callCount;
        }
        function checkAdjacentCalls(callMap, spy, index, spies) {
            var calledBeforeNext = true;
            if (index !== spies.length - 1) calledBeforeNext = spy.calledBefore(spies[index + 1]);
            if (hasCallsLeft(callMap, spy) && calledBeforeNext) {
                callMap[spy.id] += 1;
                return true;
            }
            return false;
        }
        function calledInOrder(spies) {
            var callMap = {};
            var _spies = arguments.length > 1 ? arguments : spies;
            return every(_spies, checkAdjacentCalls.bind(null, callMap));
        }
        module.exports = calledInOrder;
    },
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/class-name.js" (module) {
        function className(value) {
            const name = value.constructor && value.constructor.name;
            return name || null;
        }
        module.exports = className;
    },
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/deprecated.js" (__unused_rspack_module, exports) {
        exports.wrap = function(func, msg) {
            var wrapped = function() {
                exports.printWarning(msg);
                return func.apply(this, arguments);
            };
            if (func.prototype) wrapped.prototype = func.prototype;
            return wrapped;
        };
        exports.defaultMsg = function(packageName, funcName) {
            return `${packageName}.${funcName} is deprecated and will be removed from the public API in a future version of ${packageName}.`;
        };
        exports.printWarning = function(msg) {
            if ("object" == typeof process && process.emitWarning) process.emitWarning(msg);
            else if (console.info) console.info(msg);
            else console.log(msg);
        };
    },
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/every.js" (module) {
        module.exports = function every(obj, fn) {
            var pass = true;
            try {
                obj.forEach(function() {
                    if (!fn.apply(this, arguments)) throw new Error();
                });
            } catch (e) {
                pass = false;
            }
            return pass;
        };
    },
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/function-name.js" (module) {
        module.exports = function functionName(func) {
            if (!func) return "";
            try {
                return func.displayName || func.name || (String(func).match(/function ([^\s(]+)/) || [])[1];
            } catch (e) {
                return "";
            }
        };
    },
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/global.js" (module) {
        var globalObject;
        globalObject = "undefined" != typeof global ? global : "undefined" != typeof window ? window : self;
        module.exports = globalObject;
    },
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        module.exports = {
            global: __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/global.js"),
            calledInOrder: __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/called-in-order.js"),
            className: __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/class-name.js"),
            deprecated: __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/deprecated.js"),
            every: __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/every.js"),
            functionName: __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/function-name.js"),
            orderByFirstCall: __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/order-by-first-call.js"),
            prototypes: __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/index.js"),
            typeOf: __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/type-of.js"),
            valueToString: __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/value-to-string.js")
        };
    },
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/order-by-first-call.js" (module, __unused_rspack_exports, __webpack_require__) {
        var sort = __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/array.js").sort;
        var slice = __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/array.js").slice;
        function comparator(a, b) {
            var aCall = a.getCall(0);
            var bCall = b.getCall(0);
            var aId = aCall && aCall.callId || -1;
            var bId = bCall && bCall.callId || -1;
            return aId < bId ? -1 : 1;
        }
        function orderByFirstCall(spies) {
            return sort(slice(spies), comparator);
        }
        module.exports = orderByFirstCall;
    },
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/array.js" (module, __unused_rspack_exports, __webpack_require__) {
        var copyPrototype = __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/copy-prototype-methods.js");
        module.exports = copyPrototype(Array.prototype);
    },
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/copy-prototype-methods.js" (module, __unused_rspack_exports, __webpack_require__) {
        var call = Function.call;
        var throwsOnProto = __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/throws-on-proto.js");
        var disallowedProperties = [
            "size",
            "caller",
            "callee",
            "arguments"
        ];
        if (throwsOnProto) disallowedProperties.push("__proto__");
        module.exports = function copyPrototypeMethods(prototype) {
            return Object.getOwnPropertyNames(prototype).reduce(function(result, name) {
                if (disallowedProperties.includes(name)) return result;
                if ("function" != typeof prototype[name]) return result;
                result[name] = call.bind(prototype[name]);
                return result;
            }, Object.create(null));
        };
    },
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/function.js" (module, __unused_rspack_exports, __webpack_require__) {
        var copyPrototype = __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/copy-prototype-methods.js");
        module.exports = copyPrototype(Function.prototype);
    },
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        module.exports = {
            array: __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/array.js"),
            function: __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/function.js"),
            map: __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/map.js"),
            object: __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/object.js"),
            set: __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/set.js"),
            string: __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/string.js")
        };
    },
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/map.js" (module, __unused_rspack_exports, __webpack_require__) {
        var copyPrototype = __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/copy-prototype-methods.js");
        module.exports = copyPrototype(Map.prototype);
    },
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/object.js" (module, __unused_rspack_exports, __webpack_require__) {
        var copyPrototype = __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/copy-prototype-methods.js");
        module.exports = copyPrototype(Object.prototype);
    },
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/set.js" (module, __unused_rspack_exports, __webpack_require__) {
        var copyPrototype = __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/copy-prototype-methods.js");
        module.exports = copyPrototype(Set.prototype);
    },
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/string.js" (module, __unused_rspack_exports, __webpack_require__) {
        var copyPrototype = __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/copy-prototype-methods.js");
        module.exports = copyPrototype(String.prototype);
    },
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/prototypes/throws-on-proto.js" (module) {
        let throwsOnProto;
        try {
            const object = {};
            object.__proto__;
            throwsOnProto = false;
        } catch (_) {
            throwsOnProto = true;
        }
        module.exports = throwsOnProto;
    },
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/type-of.js" (module, __unused_rspack_exports, __webpack_require__) {
        var type = __webpack_require__("../../node_modules/.pnpm/type-detect@4.0.8/node_modules/type-detect/type-detect.js");
        module.exports = function typeOf(value) {
            return type(value).toLowerCase();
        };
    },
    "../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/value-to-string.js" (module) {
        function valueToString(value) {
            if (value && value.toString) return value.toString();
            return String(value);
        }
        module.exports = valueToString;
    },
    "../../node_modules/.pnpm/@sinonjs+fake-timers@15.0.0/node_modules/@sinonjs/fake-timers/src/fake-timers-src.js" (__unused_rspack_module, exports, __webpack_require__) {
        const globalObject = __webpack_require__("../../node_modules/.pnpm/@sinonjs+commons@3.0.1/node_modules/@sinonjs/commons/lib/index.js").global;
        let timersModule, timersPromisesModule;
        try {
            timersModule = __webpack_require__("timers");
        } catch (e) {}
        try {
            timersPromisesModule = __webpack_require__("timers/promises");
        } catch (e) {}
        function withGlobal(_global) {
            const maxTimeout = Math.pow(2, 31) - 1;
            const idCounterStart = 1e12;
            const NOOP = function() {};
            const NOOP_ARRAY = function() {
                return [];
            };
            const isPresent = {};
            let timeoutResult, addTimerReturnsObject = false;
            if (_global.setTimeout) {
                isPresent.setTimeout = true;
                timeoutResult = _global.setTimeout(NOOP, 0);
                addTimerReturnsObject = "object" == typeof timeoutResult;
            }
            isPresent.clearTimeout = Boolean(_global.clearTimeout);
            isPresent.setInterval = Boolean(_global.setInterval);
            isPresent.clearInterval = Boolean(_global.clearInterval);
            isPresent.hrtime = _global.process && "function" == typeof _global.process.hrtime;
            isPresent.hrtimeBigint = isPresent.hrtime && "function" == typeof _global.process.hrtime.bigint;
            isPresent.nextTick = _global.process && "function" == typeof _global.process.nextTick;
            const utilPromisify = _global.process && __webpack_require__("node:util").promisify;
            isPresent.performance = _global.performance && "function" == typeof _global.performance.now;
            const hasPerformancePrototype = _global.Performance && (typeof _global.Performance).match(/^(function|object)$/);
            const hasPerformanceConstructorPrototype = _global.performance && _global.performance.constructor && _global.performance.constructor.prototype;
            isPresent.queueMicrotask = _global.hasOwnProperty("queueMicrotask");
            isPresent.requestAnimationFrame = _global.requestAnimationFrame && "function" == typeof _global.requestAnimationFrame;
            isPresent.cancelAnimationFrame = _global.cancelAnimationFrame && "function" == typeof _global.cancelAnimationFrame;
            isPresent.requestIdleCallback = _global.requestIdleCallback && "function" == typeof _global.requestIdleCallback;
            isPresent.cancelIdleCallbackPresent = _global.cancelIdleCallback && "function" == typeof _global.cancelIdleCallback;
            isPresent.setImmediate = _global.setImmediate && "function" == typeof _global.setImmediate;
            isPresent.clearImmediate = _global.clearImmediate && "function" == typeof _global.clearImmediate;
            isPresent.Intl = _global.Intl && "object" == typeof _global.Intl;
            if (_global.clearTimeout) _global.clearTimeout(timeoutResult);
            const NativeDate = _global.Date;
            const NativeIntl = isPresent.Intl ? Object.defineProperties(Object.create(null), Object.getOwnPropertyDescriptors(_global.Intl)) : void 0;
            let uniqueTimerId = idCounterStart;
            if (void 0 === NativeDate) throw new Error("The global scope doesn't have a `Date` object (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)");
            isPresent.Date = true;
            class FakePerformanceEntry {
                constructor(name, entryType, startTime, duration){
                    this.name = name;
                    this.entryType = entryType;
                    this.startTime = startTime;
                    this.duration = duration;
                }
                toJSON() {
                    return JSON.stringify({
                        ...this
                    });
                }
            }
            function isNumberFinite(num) {
                if (Number.isFinite) return Number.isFinite(num);
                return isFinite(num);
            }
            let isNearInfiniteLimit = false;
            function checkIsNearInfiniteLimit(clock, i) {
                if (clock.loopLimit && i === clock.loopLimit - 1) isNearInfiniteLimit = true;
            }
            function resetIsNearInfiniteLimit() {
                isNearInfiniteLimit = false;
            }
            function parseTime(str) {
                if (!str) return 0;
                const strings = str.split(":");
                const l = strings.length;
                let i = l;
                let ms = 0;
                let parsed;
                if (l > 3 || !/^(\d\d:){0,2}\d\d?$/.test(str)) throw new Error("tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits");
                while(i--){
                    parsed = parseInt(strings[i], 10);
                    if (parsed >= 60) throw new Error(`Invalid time ${str}`);
                    ms += parsed * Math.pow(60, l - i - 1);
                }
                return 1000 * ms;
            }
            function nanoRemainder(msFloat) {
                const modulo = 1e6;
                const remainder = 1e6 * msFloat % modulo;
                const positiveRemainder = remainder < 0 ? remainder + modulo : remainder;
                return Math.floor(positiveRemainder);
            }
            function getEpoch(epoch) {
                if (!epoch) return 0;
                if ("function" == typeof epoch.getTime) return epoch.getTime();
                if ("number" == typeof epoch) return epoch;
                throw new TypeError("now should be milliseconds since UNIX epoch");
            }
            function inRange(from, to, timer) {
                return timer && timer.callAt >= from && timer.callAt <= to;
            }
            function getInfiniteLoopError(clock, job) {
                const infiniteLoopError = new Error(`Aborting after running ${clock.loopLimit} timers, assuming an infinite loop!`);
                if (!job.error) return infiniteLoopError;
                const computedTargetPattern = /target\.*[<|(|[].*?[>|\]|)]\s*/;
                let clockMethodPattern = new RegExp(String(Object.keys(clock).join("|")));
                if (addTimerReturnsObject) clockMethodPattern = new RegExp(`\\s+at (Object\\.)?(?:${Object.keys(clock).join("|")})\\s+`);
                let matchedLineIndex = -1;
                job.error.stack.split("\n").some(function(line, i) {
                    const matchedComputedTarget = line.match(computedTargetPattern);
                    if (matchedComputedTarget) {
                        matchedLineIndex = i;
                        return true;
                    }
                    const matchedClockMethod = line.match(clockMethodPattern);
                    if (matchedClockMethod) {
                        matchedLineIndex = i;
                        return false;
                    }
                    return matchedLineIndex >= 0;
                });
                const stack = `${infiniteLoopError}\n${job.type || "Microtask"} - ${job.func.name || "anonymous"}\n${job.error.stack.split("\n").slice(matchedLineIndex + 1).join("\n")}`;
                try {
                    Object.defineProperty(infiniteLoopError, "stack", {
                        value: stack
                    });
                } catch (e) {}
                return infiniteLoopError;
            }
            function createDate() {
                class ClockDate extends NativeDate {
                    constructor(year, month, date, hour, minute, second, ms){
                        if (0 === arguments.length) super(ClockDate.clock.now);
                        else super(...arguments);
                        Object.defineProperty(this, "constructor", {
                            value: NativeDate,
                            enumerable: false
                        });
                    }
                    static [Symbol.hasInstance](instance) {
                        return instance instanceof NativeDate;
                    }
                }
                ClockDate.isFake = true;
                if (NativeDate.now) ClockDate.now = function now() {
                    return ClockDate.clock.now;
                };
                if (NativeDate.toSource) ClockDate.toSource = function toSource() {
                    return NativeDate.toSource();
                };
                ClockDate.toString = function toString() {
                    return NativeDate.toString();
                };
                const ClockDateProxy = new Proxy(ClockDate, {
                    apply () {
                        if (this instanceof ClockDate) throw new TypeError("A Proxy should only capture `new` calls with the `construct` handler. This is not supposed to be possible, so check the logic.");
                        return new NativeDate(ClockDate.clock.now).toString();
                    }
                });
                return ClockDateProxy;
            }
            function createIntl() {
                const ClockIntl = {};
                Object.getOwnPropertyNames(NativeIntl).forEach((property)=>ClockIntl[property] = NativeIntl[property]);
                ClockIntl.DateTimeFormat = function(...args) {
                    const realFormatter = new NativeIntl.DateTimeFormat(...args);
                    const formatter = {};
                    [
                        "formatRange",
                        "formatRangeToParts",
                        "resolvedOptions"
                    ].forEach((method)=>{
                        formatter[method] = realFormatter[method].bind(realFormatter);
                    });
                    [
                        "format",
                        "formatToParts"
                    ].forEach((method)=>{
                        formatter[method] = function(date) {
                            return realFormatter[method](date || ClockIntl.clock.now);
                        };
                    });
                    return formatter;
                };
                ClockIntl.DateTimeFormat.prototype = Object.create(NativeIntl.DateTimeFormat.prototype);
                ClockIntl.DateTimeFormat.supportedLocalesOf = NativeIntl.DateTimeFormat.supportedLocalesOf;
                return ClockIntl;
            }
            function enqueueJob(clock, job) {
                if (!clock.jobs) clock.jobs = [];
                clock.jobs.push(job);
            }
            function runJobs(clock) {
                if (!clock.jobs) return;
                for(let i = 0; i < clock.jobs.length; i++){
                    const job = clock.jobs[i];
                    job.func.apply(null, job.args);
                    checkIsNearInfiniteLimit(clock, i);
                    if (clock.loopLimit && i > clock.loopLimit) throw getInfiniteLoopError(clock, job);
                }
                resetIsNearInfiniteLimit();
                clock.jobs = [];
            }
            function addTimer(clock, timer) {
                if (void 0 === timer.func) throw new Error("Callback must be provided to timer calls");
                if (addTimerReturnsObject) {
                    if ("function" != typeof timer.func) throw new TypeError(`[ERR_INVALID_CALLBACK]: Callback must be a function. Received ${timer.func} of type ${typeof timer.func}`);
                }
                if (isNearInfiniteLimit) timer.error = new Error();
                timer.type = timer.immediate ? "Immediate" : "Timeout";
                if (timer.hasOwnProperty("delay")) {
                    if ("number" != typeof timer.delay) timer.delay = parseInt(timer.delay, 10);
                    if (!isNumberFinite(timer.delay)) timer.delay = 0;
                    timer.delay = timer.delay > maxTimeout ? 1 : timer.delay;
                    timer.delay = Math.max(0, timer.delay);
                }
                if (timer.hasOwnProperty("interval")) {
                    timer.type = "Interval";
                    timer.interval = timer.interval > maxTimeout ? 1 : timer.interval;
                }
                if (timer.hasOwnProperty("animation")) {
                    timer.type = "AnimationFrame";
                    timer.animation = true;
                }
                if (timer.hasOwnProperty("idleCallback")) {
                    timer.type = "IdleCallback";
                    timer.idleCallback = true;
                }
                if (!clock.timers) clock.timers = {};
                timer.id = uniqueTimerId++;
                timer.createdAt = clock.now;
                timer.callAt = clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));
                clock.timers[timer.id] = timer;
                if (addTimerReturnsObject) {
                    const res = {
                        refed: true,
                        ref: function() {
                            this.refed = true;
                            return res;
                        },
                        unref: function() {
                            this.refed = false;
                            return res;
                        },
                        hasRef: function() {
                            return this.refed;
                        },
                        refresh: function() {
                            timer.callAt = clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));
                            clock.timers[timer.id] = timer;
                            return res;
                        },
                        [Symbol.toPrimitive]: function() {
                            return timer.id;
                        }
                    };
                    return res;
                }
                return timer.id;
            }
            function compareTimers(a, b) {
                if (a.callAt < b.callAt) return -1;
                if (a.callAt > b.callAt) return 1;
                if (a.immediate && !b.immediate) return -1;
                if (!a.immediate && b.immediate) return 1;
                if (a.createdAt < b.createdAt) return -1;
                if (a.createdAt > b.createdAt) return 1;
                if (a.id < b.id) return -1;
                if (a.id > b.id) return 1;
            }
            function firstTimerInRange(clock, from, to) {
                const timers = clock.timers;
                let timer = null;
                let id, isInRange;
                for(id in timers)if (timers.hasOwnProperty(id)) {
                    isInRange = inRange(from, to, timers[id]);
                    if (isInRange && (!timer || 1 === compareTimers(timer, timers[id]))) timer = timers[id];
                }
                return timer;
            }
            function firstTimer(clock) {
                const timers = clock.timers;
                let timer = null;
                let id;
                for(id in timers)if (timers.hasOwnProperty(id)) {
                    if (!timer || 1 === compareTimers(timer, timers[id])) timer = timers[id];
                }
                return timer;
            }
            function lastTimer(clock) {
                const timers = clock.timers;
                let timer = null;
                let id;
                for(id in timers)if (timers.hasOwnProperty(id)) {
                    if (!timer || -1 === compareTimers(timer, timers[id])) timer = timers[id];
                }
                return timer;
            }
            function callTimer(clock, timer) {
                if ("number" == typeof timer.interval) clock.timers[timer.id].callAt += timer.interval;
                else delete clock.timers[timer.id];
                if ("function" == typeof timer.func) timer.func.apply(null, timer.args);
                else {
                    const eval2 = eval;
                    (function() {
                        eval2(timer.func);
                    })();
                }
            }
            function getClearHandler(ttype) {
                if ("IdleCallback" === ttype || "AnimationFrame" === ttype) return `cancel${ttype}`;
                return `clear${ttype}`;
            }
            function getScheduleHandler(ttype) {
                if ("IdleCallback" === ttype || "AnimationFrame" === ttype) return `request${ttype}`;
                return `set${ttype}`;
            }
            function createWarnOnce() {
                let calls = 0;
                return function(msg) {
                    calls++ || console.warn(msg);
                };
            }
            const warnOnce = createWarnOnce();
            function clearTimer(clock, timerId, ttype) {
                if (!timerId) return;
                if (!clock.timers) clock.timers = {};
                const id = Number(timerId);
                if (Number.isNaN(id) || id < idCounterStart) {
                    const handlerName = getClearHandler(ttype);
                    if (true === clock.shouldClearNativeTimers) {
                        const nativeHandler = clock[`_${handlerName}`];
                        return "function" == typeof nativeHandler ? nativeHandler(timerId) : void 0;
                    }
                    warnOnce(`FakeTimers: ${handlerName} was invoked to clear a native timer instead of one created by this library.\nTo automatically clean-up native timers, use \`shouldClearNativeTimers\`.`);
                }
                if (clock.timers.hasOwnProperty(id)) {
                    const timer = clock.timers[id];
                    if (timer.type === ttype || "Timeout" === timer.type && "Interval" === ttype || "Interval" === timer.type && "Timeout" === ttype) delete clock.timers[id];
                    else {
                        const clear = getClearHandler(ttype);
                        const schedule = getScheduleHandler(timer.type);
                        throw new Error(`Cannot clear timer: timer created with ${schedule}() but cleared with ${clear}()`);
                    }
                }
            }
            function uninstall(clock) {
                let method, i, l;
                const installedHrTime = "_hrtime";
                const installedNextTick = "_nextTick";
                for(i = 0, l = clock.methods.length; i < l; i++){
                    method = clock.methods[i];
                    if ("hrtime" === method && _global.process) _global.process.hrtime = clock[installedHrTime];
                    else if ("nextTick" === method && _global.process) _global.process.nextTick = clock[installedNextTick];
                    else if ("performance" === method) {
                        const originalPerfDescriptor = Object.getOwnPropertyDescriptor(clock, `_${method}`);
                        if (originalPerfDescriptor && originalPerfDescriptor.get && !originalPerfDescriptor.set) Object.defineProperty(_global, method, originalPerfDescriptor);
                        else if (originalPerfDescriptor.configurable) _global[method] = clock[`_${method}`];
                    } else if (_global[method] && _global[method].hadOwnProperty) _global[method] = clock[`_${method}`];
                    else try {
                        delete _global[method];
                    } catch (ignore) {}
                    if (void 0 !== clock.timersModuleMethods) for(let j = 0; j < clock.timersModuleMethods.length; j++){
                        const entry = clock.timersModuleMethods[j];
                        timersModule[entry.methodName] = entry.original;
                    }
                    if (void 0 !== clock.timersPromisesModuleMethods) for(let j = 0; j < clock.timersPromisesModuleMethods.length; j++){
                        const entry = clock.timersPromisesModuleMethods[j];
                        timersPromisesModule[entry.methodName] = entry.original;
                    }
                }
                clock.setTickMode("manual");
                clock.methods = [];
                for (const [listener, signal] of clock.abortListenerMap.entries()){
                    signal.removeEventListener("abort", listener);
                    clock.abortListenerMap.delete(listener);
                }
                if (!clock.timers) return [];
                return Object.keys(clock.timers).map(function mapper(key) {
                    return clock.timers[key];
                });
            }
            function hijackMethod(target, method, clock) {
                clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(target, method);
                clock[`_${method}`] = target[method];
                if ("Date" === method) target[method] = clock[method];
                else if ("Intl" === method) target[method] = clock[method];
                else if ("performance" === method) {
                    const originalPerfDescriptor = Object.getOwnPropertyDescriptor(target, method);
                    if (originalPerfDescriptor && originalPerfDescriptor.get && !originalPerfDescriptor.set) {
                        Object.defineProperty(clock, `_${method}`, originalPerfDescriptor);
                        const perfDescriptor = Object.getOwnPropertyDescriptor(clock, method);
                        Object.defineProperty(target, method, perfDescriptor);
                    } else target[method] = clock[method];
                } else {
                    target[method] = function() {
                        return clock[method].apply(clock, arguments);
                    };
                    Object.defineProperties(target[method], Object.getOwnPropertyDescriptors(clock[method]));
                }
                target[method].clock = clock;
            }
            function doIntervalTick(clock, advanceTimeDelta) {
                clock.tick(advanceTimeDelta);
            }
            const timers = {
                setTimeout: _global.setTimeout,
                clearTimeout: _global.clearTimeout,
                setInterval: _global.setInterval,
                clearInterval: _global.clearInterval,
                Date: _global.Date
            };
            if (isPresent.setImmediate) timers.setImmediate = _global.setImmediate;
            if (isPresent.clearImmediate) timers.clearImmediate = _global.clearImmediate;
            if (isPresent.hrtime) timers.hrtime = _global.process.hrtime;
            if (isPresent.nextTick) timers.nextTick = _global.process.nextTick;
            if (isPresent.performance) timers.performance = _global.performance;
            if (isPresent.requestAnimationFrame) timers.requestAnimationFrame = _global.requestAnimationFrame;
            if (isPresent.queueMicrotask) timers.queueMicrotask = _global.queueMicrotask;
            if (isPresent.cancelAnimationFrame) timers.cancelAnimationFrame = _global.cancelAnimationFrame;
            if (isPresent.requestIdleCallback) timers.requestIdleCallback = _global.requestIdleCallback;
            if (isPresent.cancelIdleCallback) timers.cancelIdleCallback = _global.cancelIdleCallback;
            if (isPresent.Intl) timers.Intl = NativeIntl;
            const originalSetTimeout = _global.setImmediate || _global.setTimeout;
            const originalClearInterval = _global.clearInterval;
            const originalSetInterval = _global.setInterval;
            function createClock(start, loopLimit) {
                start = Math.floor(getEpoch(start));
                loopLimit = loopLimit || 1000;
                let nanos = 0;
                const adjustedSystemTime = [
                    0,
                    0
                ];
                const clock = {
                    now: start,
                    Date: createDate(),
                    loopLimit: loopLimit,
                    tickMode: {
                        mode: "manual",
                        counter: 0,
                        delta: void 0
                    }
                };
                clock.Date.clock = clock;
                function getTimeToNextFrame() {
                    return 16 - (clock.now - start) % 16;
                }
                function hrtime(prev) {
                    const millisSinceStart = clock.now - adjustedSystemTime[0] - start;
                    const secsSinceStart = Math.floor(millisSinceStart / 1000);
                    const remainderInNanos = (millisSinceStart - 1e3 * secsSinceStart) * 1e6 + nanos - adjustedSystemTime[1];
                    if (Array.isArray(prev)) {
                        if (prev[1] > 1e9) throw new TypeError("Number of nanoseconds can't exceed a billion");
                        const oldSecs = prev[0];
                        let nanoDiff = remainderInNanos - prev[1];
                        let secDiff = secsSinceStart - oldSecs;
                        if (nanoDiff < 0) {
                            nanoDiff += 1e9;
                            secDiff -= 1;
                        }
                        return [
                            secDiff,
                            nanoDiff
                        ];
                    }
                    return [
                        secsSinceStart,
                        remainderInNanos
                    ];
                }
                function fakePerformanceNow() {
                    const hrt = hrtime();
                    const millis = 1000 * hrt[0] + hrt[1] / 1e6;
                    return millis;
                }
                if (isPresent.hrtimeBigint) hrtime.bigint = function() {
                    const parts = hrtime();
                    return BigInt(parts[0]) * BigInt(1e9) + BigInt(parts[1]);
                };
                if (isPresent.Intl) {
                    clock.Intl = createIntl();
                    clock.Intl.clock = clock;
                }
                clock.setTickMode = function(tickModeConfig) {
                    const { mode: newMode, delta: newDelta } = tickModeConfig;
                    const { mode: oldMode, delta: oldDelta } = clock.tickMode;
                    if (newMode === oldMode && newDelta === oldDelta) return;
                    if ("interval" === oldMode) originalClearInterval(clock.attachedInterval);
                    clock.tickMode = {
                        counter: clock.tickMode.counter + 1,
                        mode: newMode,
                        delta: newDelta
                    };
                    if ("nextAsync" === newMode) advanceUntilModeChanges();
                    else if ("interval" === newMode) createIntervalTick(clock, newDelta || 20);
                };
                async function advanceUntilModeChanges() {
                    async function newMacrotask() {
                        const channel = new MessageChannel();
                        await new Promise((resolve)=>{
                            channel.port1.onmessage = ()=>{
                                resolve();
                                channel.port1.close();
                            };
                            channel.port2.postMessage(void 0);
                        });
                        channel.port1.close();
                        channel.port2.close();
                        await new Promise((resolve)=>{
                            originalSetTimeout(resolve);
                        });
                    }
                    const { counter } = clock.tickMode;
                    while(clock.tickMode.counter === counter){
                        await newMacrotask();
                        if (clock.tickMode.counter !== counter) return;
                        clock.next();
                    }
                }
                function pauseAutoTickUntilFinished(promise) {
                    if ("nextAsync" !== clock.tickMode.mode) return promise;
                    clock.setTickMode({
                        mode: "manual"
                    });
                    return promise.finally(()=>{
                        clock.setTickMode({
                            mode: "nextAsync"
                        });
                    });
                }
                clock.requestIdleCallback = function requestIdleCallback(func, timeout) {
                    let timeToNextIdlePeriod = 0;
                    if (clock.countTimers() > 0) timeToNextIdlePeriod = 50;
                    const result = addTimer(clock, {
                        func: func,
                        args: Array.prototype.slice.call(arguments, 2),
                        delay: void 0 === timeout ? timeToNextIdlePeriod : Math.min(timeout, timeToNextIdlePeriod),
                        idleCallback: true
                    });
                    return Number(result);
                };
                clock.cancelIdleCallback = function cancelIdleCallback(timerId) {
                    return clearTimer(clock, timerId, "IdleCallback");
                };
                clock.setTimeout = function setTimeout(func, timeout) {
                    return addTimer(clock, {
                        func: func,
                        args: Array.prototype.slice.call(arguments, 2),
                        delay: timeout
                    });
                };
                if (void 0 !== _global.Promise && utilPromisify) clock.setTimeout[utilPromisify.custom] = function promisifiedSetTimeout(timeout, arg) {
                    return new _global.Promise(function setTimeoutExecutor(resolve) {
                        addTimer(clock, {
                            func: resolve,
                            args: [
                                arg
                            ],
                            delay: timeout
                        });
                    });
                };
                clock.clearTimeout = function clearTimeout1(timerId) {
                    return clearTimer(clock, timerId, "Timeout");
                };
                clock.nextTick = function nextTick(func) {
                    return enqueueJob(clock, {
                        func: func,
                        args: Array.prototype.slice.call(arguments, 1),
                        error: isNearInfiniteLimit ? new Error() : null
                    });
                };
                clock.queueMicrotask = function queueMicrotask(func) {
                    return clock.nextTick(func);
                };
                clock.setInterval = function setInterval(func, timeout) {
                    timeout = parseInt(timeout, 10);
                    return addTimer(clock, {
                        func: func,
                        args: Array.prototype.slice.call(arguments, 2),
                        delay: timeout,
                        interval: timeout
                    });
                };
                clock.clearInterval = function clearInterval(timerId) {
                    return clearTimer(clock, timerId, "Interval");
                };
                if (isPresent.setImmediate) {
                    clock.setImmediate = function setImmediate(func) {
                        return addTimer(clock, {
                            func: func,
                            args: Array.prototype.slice.call(arguments, 1),
                            immediate: true
                        });
                    };
                    if (void 0 !== _global.Promise && utilPromisify) clock.setImmediate[utilPromisify.custom] = function promisifiedSetImmediate(arg) {
                        return new _global.Promise(function setImmediateExecutor(resolve) {
                            addTimer(clock, {
                                func: resolve,
                                args: [
                                    arg
                                ],
                                immediate: true
                            });
                        });
                    };
                    clock.clearImmediate = function clearImmediate(timerId) {
                        return clearTimer(clock, timerId, "Immediate");
                    };
                }
                clock.countTimers = function countTimers() {
                    return Object.keys(clock.timers || {}).length + (clock.jobs || []).length;
                };
                clock.requestAnimationFrame = function requestAnimationFrame(func) {
                    const result = addTimer(clock, {
                        func: func,
                        delay: getTimeToNextFrame(),
                        get args () {
                            return [
                                fakePerformanceNow()
                            ];
                        },
                        animation: true
                    });
                    return Number(result);
                };
                clock.cancelAnimationFrame = function cancelAnimationFrame(timerId) {
                    return clearTimer(clock, timerId, "AnimationFrame");
                };
                clock.runMicrotasks = function runMicrotasks() {
                    runJobs(clock);
                };
                function doTick(tickValue, isAsync, resolve, reject) {
                    const msFloat = "number" == typeof tickValue ? tickValue : parseTime(tickValue);
                    const ms = Math.floor(msFloat);
                    const remainder = nanoRemainder(msFloat);
                    let nanosTotal = nanos + remainder;
                    let tickTo = clock.now + ms;
                    if (msFloat < 0) throw new TypeError("Negative ticks are not supported");
                    if (nanosTotal >= 1e6) {
                        tickTo += 1;
                        nanosTotal -= 1e6;
                    }
                    nanos = nanosTotal;
                    let tickFrom = clock.now;
                    let previous = clock.now;
                    let timer, firstException, oldNow, nextPromiseTick, compensationCheck, postTimerCall;
                    clock.duringTick = true;
                    oldNow = clock.now;
                    runJobs(clock);
                    if (oldNow !== clock.now) {
                        tickFrom += clock.now - oldNow;
                        tickTo += clock.now - oldNow;
                    }
                    function doTickInner() {
                        timer = firstTimerInRange(clock, tickFrom, tickTo);
                        while(timer && tickFrom <= tickTo){
                            if (clock.timers[timer.id]) {
                                tickFrom = timer.callAt;
                                clock.now = timer.callAt;
                                oldNow = clock.now;
                                try {
                                    runJobs(clock);
                                    callTimer(clock, timer);
                                } catch (e) {
                                    firstException = firstException || e;
                                }
                                if (isAsync) return void originalSetTimeout(nextPromiseTick);
                                compensationCheck();
                            }
                            postTimerCall();
                        }
                        oldNow = clock.now;
                        runJobs(clock);
                        if (oldNow !== clock.now) {
                            tickFrom += clock.now - oldNow;
                            tickTo += clock.now - oldNow;
                        }
                        clock.duringTick = false;
                        timer = firstTimerInRange(clock, tickFrom, tickTo);
                        if (timer) try {
                            clock.tick(tickTo - clock.now);
                        } catch (e) {
                            firstException = firstException || e;
                        }
                        else {
                            clock.now = tickTo;
                            nanos = nanosTotal;
                        }
                        if (firstException) throw firstException;
                        if (!isAsync) return clock.now;
                        resolve(clock.now);
                    }
                    nextPromiseTick = isAsync && function() {
                        try {
                            compensationCheck();
                            postTimerCall();
                            doTickInner();
                        } catch (e) {
                            reject(e);
                        }
                    };
                    compensationCheck = function() {
                        if (oldNow !== clock.now) {
                            tickFrom += clock.now - oldNow;
                            tickTo += clock.now - oldNow;
                            previous += clock.now - oldNow;
                        }
                    };
                    postTimerCall = function() {
                        timer = firstTimerInRange(clock, previous, tickTo);
                        previous = tickFrom;
                    };
                    return doTickInner();
                }
                clock.tick = function tick(tickValue) {
                    return doTick(tickValue, false);
                };
                if (void 0 !== _global.Promise) clock.tickAsync = function tickAsync(tickValue) {
                    return pauseAutoTickUntilFinished(new _global.Promise(function(resolve, reject) {
                        originalSetTimeout(function() {
                            try {
                                doTick(tickValue, true, resolve, reject);
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }));
                };
                clock.next = function next() {
                    runJobs(clock);
                    const timer = firstTimer(clock);
                    if (!timer) return clock.now;
                    clock.duringTick = true;
                    try {
                        clock.now = timer.callAt;
                        callTimer(clock, timer);
                        runJobs(clock);
                        return clock.now;
                    } finally{
                        clock.duringTick = false;
                    }
                };
                if (void 0 !== _global.Promise) clock.nextAsync = function nextAsync() {
                    return pauseAutoTickUntilFinished(new _global.Promise(function(resolve, reject) {
                        originalSetTimeout(function() {
                            try {
                                const timer = firstTimer(clock);
                                if (!timer) return void resolve(clock.now);
                                let err;
                                clock.duringTick = true;
                                clock.now = timer.callAt;
                                try {
                                    callTimer(clock, timer);
                                } catch (e) {
                                    err = e;
                                }
                                clock.duringTick = false;
                                originalSetTimeout(function() {
                                    if (err) reject(err);
                                    else resolve(clock.now);
                                });
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }));
                };
                clock.runAll = function runAll() {
                    let numTimers, i;
                    runJobs(clock);
                    for(i = 0; i < clock.loopLimit; i++){
                        if (!clock.timers) {
                            resetIsNearInfiniteLimit();
                            return clock.now;
                        }
                        numTimers = Object.keys(clock.timers).length;
                        if (0 === numTimers) {
                            resetIsNearInfiniteLimit();
                            return clock.now;
                        }
                        clock.next();
                        checkIsNearInfiniteLimit(clock, i);
                    }
                    const excessJob = firstTimer(clock);
                    throw getInfiniteLoopError(clock, excessJob);
                };
                clock.runToFrame = function runToFrame() {
                    return clock.tick(getTimeToNextFrame());
                };
                if (void 0 !== _global.Promise) clock.runAllAsync = function runAllAsync() {
                    return pauseAutoTickUntilFinished(new _global.Promise(function(resolve, reject) {
                        let i = 0;
                        function doRun() {
                            originalSetTimeout(function() {
                                try {
                                    runJobs(clock);
                                    let numTimers;
                                    if (i < clock.loopLimit) {
                                        if (!clock.timers) {
                                            resetIsNearInfiniteLimit();
                                            resolve(clock.now);
                                            return;
                                        }
                                        numTimers = Object.keys(clock.timers).length;
                                        if (0 === numTimers) {
                                            resetIsNearInfiniteLimit();
                                            resolve(clock.now);
                                            return;
                                        }
                                        clock.next();
                                        i++;
                                        doRun();
                                        checkIsNearInfiniteLimit(clock, i);
                                        return;
                                    }
                                    const excessJob = firstTimer(clock);
                                    reject(getInfiniteLoopError(clock, excessJob));
                                } catch (e) {
                                    reject(e);
                                }
                            });
                        }
                        doRun();
                    }));
                };
                clock.runToLast = function runToLast() {
                    const timer = lastTimer(clock);
                    if (!timer) {
                        runJobs(clock);
                        return clock.now;
                    }
                    return clock.tick(timer.callAt - clock.now);
                };
                if (void 0 !== _global.Promise) clock.runToLastAsync = function runToLastAsync() {
                    return pauseAutoTickUntilFinished(new _global.Promise(function(resolve, reject) {
                        originalSetTimeout(function() {
                            try {
                                const timer = lastTimer(clock);
                                if (!timer) {
                                    runJobs(clock);
                                    resolve(clock.now);
                                }
                                resolve(clock.tickAsync(timer.callAt - clock.now));
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }));
                };
                clock.reset = function reset() {
                    nanos = 0;
                    clock.timers = {};
                    clock.jobs = [];
                    clock.now = start;
                };
                clock.setSystemTime = function setSystemTime(systemTime) {
                    const newNow = getEpoch(systemTime);
                    const difference = newNow - clock.now;
                    let id, timer;
                    adjustedSystemTime[0] = adjustedSystemTime[0] + difference;
                    adjustedSystemTime[1] = adjustedSystemTime[1] + nanos;
                    clock.now = newNow;
                    nanos = 0;
                    for(id in clock.timers)if (clock.timers.hasOwnProperty(id)) {
                        timer = clock.timers[id];
                        timer.createdAt += difference;
                        timer.callAt += difference;
                    }
                };
                clock.jump = function jump(tickValue) {
                    const msFloat = "number" == typeof tickValue ? tickValue : parseTime(tickValue);
                    const ms = Math.floor(msFloat);
                    for (const timer of Object.values(clock.timers))if (clock.now + ms > timer.callAt) timer.callAt = clock.now + ms;
                    clock.tick(ms);
                };
                if (isPresent.performance) {
                    clock.performance = Object.create(null);
                    clock.performance.now = fakePerformanceNow;
                }
                if (isPresent.hrtime) clock.hrtime = hrtime;
                return clock;
            }
            function createIntervalTick(clock, delta) {
                const intervalTick = doIntervalTick.bind(null, clock, delta);
                const intervalId = originalSetInterval(intervalTick, delta);
                clock.attachedInterval = intervalId;
            }
            function install(config) {
                if (arguments.length > 1 || config instanceof Date || Array.isArray(config) || "number" == typeof config) throw new TypeError(`FakeTimers.install called with ${String(config)} install requires an object parameter`);
                if (true === _global.Date.isFake) throw new TypeError("Can't install fake timers twice on the same global object.");
                config = void 0 !== config ? config : {};
                config.shouldAdvanceTime = config.shouldAdvanceTime || false;
                config.advanceTimeDelta = config.advanceTimeDelta || 20;
                config.shouldClearNativeTimers = config.shouldClearNativeTimers || false;
                if (config.target) throw new TypeError("config.target is no longer supported. Use `withGlobal(target)` instead.");
                function handleMissingTimer(timer) {
                    if (config.ignoreMissingTimers) return;
                    throw new ReferenceError(`non-existent timers and/or objects cannot be faked: '${timer}'`);
                }
                let i, l;
                const clock = createClock(config.now, config.loopLimit);
                clock.shouldClearNativeTimers = config.shouldClearNativeTimers;
                clock.uninstall = function() {
                    return uninstall(clock);
                };
                clock.abortListenerMap = new Map();
                clock.methods = config.toFake || [];
                if (0 === clock.methods.length) clock.methods = Object.keys(timers);
                if (true === config.shouldAdvanceTime) clock.setTickMode({
                    mode: "interval",
                    delta: config.advanceTimeDelta
                });
                if (clock.methods.includes("performance")) {
                    const proto = (()=>{
                        if (hasPerformanceConstructorPrototype) return _global.performance.constructor.prototype;
                        if (hasPerformancePrototype) return _global.Performance.prototype;
                    })();
                    if (proto) {
                        Object.getOwnPropertyNames(proto).forEach(function(name) {
                            if ("now" !== name) clock.performance[name] = 0 === name.indexOf("getEntries") ? NOOP_ARRAY : NOOP;
                        });
                        clock.performance.mark = (name)=>new FakePerformanceEntry(name, "mark", 0, 0);
                        clock.performance.measure = (name)=>new FakePerformanceEntry(name, "measure", 0, 100);
                        clock.performance.timeOrigin = getEpoch(config.now);
                    } else if ((config.toFake || []).includes("performance")) return handleMissingTimer("performance");
                }
                if (_global === globalObject && timersModule) clock.timersModuleMethods = [];
                if (_global === globalObject && timersPromisesModule) clock.timersPromisesModuleMethods = [];
                for(i = 0, l = clock.methods.length; i < l; i++){
                    const nameOfMethodToReplace = clock.methods[i];
                    if (!isPresent[nameOfMethodToReplace]) {
                        handleMissingTimer(nameOfMethodToReplace);
                        continue;
                    }
                    if ("hrtime" === nameOfMethodToReplace) {
                        if (_global.process && "function" == typeof _global.process.hrtime) hijackMethod(_global.process, nameOfMethodToReplace, clock);
                    } else if ("nextTick" === nameOfMethodToReplace) {
                        if (_global.process && "function" == typeof _global.process.nextTick) hijackMethod(_global.process, nameOfMethodToReplace, clock);
                    } else hijackMethod(_global, nameOfMethodToReplace, clock);
                    if (void 0 !== clock.timersModuleMethods && timersModule[nameOfMethodToReplace]) {
                        const original = timersModule[nameOfMethodToReplace];
                        clock.timersModuleMethods.push({
                            methodName: nameOfMethodToReplace,
                            original: original
                        });
                        timersModule[nameOfMethodToReplace] = _global[nameOfMethodToReplace];
                    }
                    if (void 0 !== clock.timersPromisesModuleMethods) {
                        if ("setTimeout" === nameOfMethodToReplace) {
                            clock.timersPromisesModuleMethods.push({
                                methodName: "setTimeout",
                                original: timersPromisesModule.setTimeout
                            });
                            timersPromisesModule.setTimeout = (delay, value, options = {})=>new Promise((resolve, reject)=>{
                                    const abort = ()=>{
                                        options.signal.removeEventListener("abort", abort);
                                        clock.abortListenerMap.delete(abort);
                                        clock.clearTimeout(handle);
                                        reject(options.signal.reason);
                                    };
                                    const handle = clock.setTimeout(()=>{
                                        if (options.signal) {
                                            options.signal.removeEventListener("abort", abort);
                                            clock.abortListenerMap.delete(abort);
                                        }
                                        resolve(value);
                                    }, delay);
                                    if (options.signal) if (options.signal.aborted) abort();
                                    else {
                                        options.signal.addEventListener("abort", abort);
                                        clock.abortListenerMap.set(abort, options.signal);
                                    }
                                });
                        } else if ("setImmediate" === nameOfMethodToReplace) {
                            clock.timersPromisesModuleMethods.push({
                                methodName: "setImmediate",
                                original: timersPromisesModule.setImmediate
                            });
                            timersPromisesModule.setImmediate = (value, options = {})=>new Promise((resolve, reject)=>{
                                    const abort = ()=>{
                                        options.signal.removeEventListener("abort", abort);
                                        clock.abortListenerMap.delete(abort);
                                        clock.clearImmediate(handle);
                                        reject(options.signal.reason);
                                    };
                                    const handle = clock.setImmediate(()=>{
                                        if (options.signal) {
                                            options.signal.removeEventListener("abort", abort);
                                            clock.abortListenerMap.delete(abort);
                                        }
                                        resolve(value);
                                    });
                                    if (options.signal) if (options.signal.aborted) abort();
                                    else {
                                        options.signal.addEventListener("abort", abort);
                                        clock.abortListenerMap.set(abort, options.signal);
                                    }
                                });
                        } else if ("setInterval" === nameOfMethodToReplace) {
                            clock.timersPromisesModuleMethods.push({
                                methodName: "setInterval",
                                original: timersPromisesModule.setInterval
                            });
                            timersPromisesModule.setInterval = (delay, value, options = {})=>({
                                    [Symbol.asyncIterator]: ()=>{
                                        const createResolvable = ()=>{
                                            let resolve, reject;
                                            const promise = new Promise((res, rej)=>{
                                                resolve = res;
                                                reject = rej;
                                            });
                                            promise.resolve = resolve;
                                            promise.reject = reject;
                                            return promise;
                                        };
                                        let done = false;
                                        let hasThrown = false;
                                        let returnCall;
                                        let nextAvailable = 0;
                                        const nextQueue = [];
                                        const handle = clock.setInterval(()=>{
                                            if (nextQueue.length > 0) nextQueue.shift().resolve();
                                            else nextAvailable++;
                                        }, delay);
                                        const abort = ()=>{
                                            options.signal.removeEventListener("abort", abort);
                                            clock.abortListenerMap.delete(abort);
                                            clock.clearInterval(handle);
                                            done = true;
                                            for (const resolvable of nextQueue)resolvable.resolve();
                                        };
                                        if (options.signal) if (options.signal.aborted) done = true;
                                        else {
                                            options.signal.addEventListener("abort", abort);
                                            clock.abortListenerMap.set(abort, options.signal);
                                        }
                                        return {
                                            next: async ()=>{
                                                if (options.signal?.aborted && !hasThrown) {
                                                    hasThrown = true;
                                                    throw options.signal.reason;
                                                }
                                                if (done) return {
                                                    done: true,
                                                    value: void 0
                                                };
                                                if (nextAvailable > 0) {
                                                    nextAvailable--;
                                                    return {
                                                        done: false,
                                                        value: value
                                                    };
                                                }
                                                const resolvable = createResolvable();
                                                nextQueue.push(resolvable);
                                                await resolvable;
                                                if (returnCall && 0 === nextQueue.length) returnCall.resolve();
                                                if (options.signal?.aborted && !hasThrown) {
                                                    hasThrown = true;
                                                    throw options.signal.reason;
                                                }
                                                if (done) return {
                                                    done: true,
                                                    value: void 0
                                                };
                                                return {
                                                    done: false,
                                                    value: value
                                                };
                                            },
                                            return: async ()=>{
                                                if (done) return {
                                                    done: true,
                                                    value: void 0
                                                };
                                                if (nextQueue.length > 0) {
                                                    returnCall = createResolvable();
                                                    await returnCall;
                                                }
                                                clock.clearInterval(handle);
                                                done = true;
                                                if (options.signal) {
                                                    options.signal.removeEventListener("abort", abort);
                                                    clock.abortListenerMap.delete(abort);
                                                }
                                                return {
                                                    done: true,
                                                    value: void 0
                                                };
                                            }
                                        };
                                    }
                                });
                        }
                    }
                }
                return clock;
            }
            return {
                timers: timers,
                createClock: createClock,
                install: install,
                withGlobal: withGlobal
            };
        }
        const defaultImplementation = withGlobal(globalObject);
        defaultImplementation.timers;
        defaultImplementation.createClock;
        defaultImplementation.install;
        exports.withGlobal = withGlobal;
    },
    "../../node_modules/.pnpm/type-detect@4.0.8/node_modules/type-detect/type-detect.js" (module) {
        (function(global1, factory) {
            module.exports = factory();
        })(0, function() {
            'use strict';
            var promiseExists = 'function' == typeof Promise;
            var globalObject = 'object' == typeof self ? self : global;
            var symbolExists = 'undefined' != typeof Symbol;
            var mapExists = 'undefined' != typeof Map;
            var setExists = 'undefined' != typeof Set;
            var weakMapExists = 'undefined' != typeof WeakMap;
            var weakSetExists = 'undefined' != typeof WeakSet;
            var dataViewExists = 'undefined' != typeof DataView;
            var symbolIteratorExists = symbolExists && void 0 !== Symbol.iterator;
            var symbolToStringTagExists = symbolExists && void 0 !== Symbol.toStringTag;
            var setEntriesExists = setExists && 'function' == typeof Set.prototype.entries;
            var mapEntriesExists = mapExists && 'function' == typeof Map.prototype.entries;
            var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());
            var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());
            var arrayIteratorExists = symbolIteratorExists && 'function' == typeof Array.prototype[Symbol.iterator];
            var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
            var stringIteratorExists = symbolIteratorExists && 'function' == typeof String.prototype[Symbol.iterator];
            var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
            var toStringLeftSliceLength = 8;
            var toStringRightSliceLength = -1;
            function typeDetect(obj) {
                var typeofObj = typeof obj;
                if ('object' !== typeofObj) return typeofObj;
                if (null === obj) return 'null';
                if (obj === globalObject) return 'global';
                if (Array.isArray(obj) && (false === symbolToStringTagExists || !(Symbol.toStringTag in obj))) return 'Array';
                if ('object' == typeof window && null !== window) {
                    if ('object' == typeof window.location && obj === window.location) return 'Location';
                    if ('object' == typeof window.document && obj === window.document) return 'Document';
                    if ('object' == typeof window.navigator) {
                        if ('object' == typeof window.navigator.mimeTypes && obj === window.navigator.mimeTypes) return 'MimeTypeArray';
                        if ('object' == typeof window.navigator.plugins && obj === window.navigator.plugins) return 'PluginArray';
                    }
                    if (('function' == typeof window.HTMLElement || 'object' == typeof window.HTMLElement) && obj instanceof window.HTMLElement) {
                        if ('BLOCKQUOTE' === obj.tagName) return 'HTMLQuoteElement';
                        if ('TD' === obj.tagName) return 'HTMLTableDataCellElement';
                        if ('TH' === obj.tagName) return 'HTMLTableHeaderCellElement';
                    }
                }
                var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];
                if ('string' == typeof stringTag) return stringTag;
                var objPrototype = Object.getPrototypeOf(obj);
                if (objPrototype === RegExp.prototype) return 'RegExp';
                if (objPrototype === Date.prototype) return 'Date';
                if (promiseExists && objPrototype === Promise.prototype) return 'Promise';
                if (setExists && objPrototype === Set.prototype) return 'Set';
                if (mapExists && objPrototype === Map.prototype) return 'Map';
                if (weakSetExists && objPrototype === WeakSet.prototype) return 'WeakSet';
                if (weakMapExists && objPrototype === WeakMap.prototype) return 'WeakMap';
                if (dataViewExists && objPrototype === DataView.prototype) return 'DataView';
                if (mapExists && objPrototype === mapIteratorPrototype) return 'Map Iterator';
                if (setExists && objPrototype === setIteratorPrototype) return 'Set Iterator';
                if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) return 'Array Iterator';
                if (stringIteratorExists && objPrototype === stringIteratorPrototype) return 'String Iterator';
                if (null === objPrototype) return 'Object';
                return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
            }
            return typeDetect;
        });
    }
});
var chunk_BVHSVHOK_f = {
    reset: [
        0,
        0
    ],
    bold: [
        1,
        22,
        "\x1B[22m\x1B[1m"
    ],
    dim: [
        2,
        22,
        "\x1B[22m\x1B[2m"
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    inverse: [
        7,
        27
    ],
    hidden: [
        8,
        28
    ],
    strikethrough: [
        9,
        29
    ],
    black: [
        30,
        39
    ],
    red: [
        31,
        39
    ],
    green: [
        32,
        39
    ],
    yellow: [
        33,
        39
    ],
    blue: [
        34,
        39
    ],
    magenta: [
        35,
        39
    ],
    cyan: [
        36,
        39
    ],
    white: [
        37,
        39
    ],
    gray: [
        90,
        39
    ],
    bgBlack: [
        40,
        49
    ],
    bgRed: [
        41,
        49
    ],
    bgGreen: [
        42,
        49
    ],
    bgYellow: [
        43,
        49
    ],
    bgBlue: [
        44,
        49
    ],
    bgMagenta: [
        45,
        49
    ],
    bgCyan: [
        46,
        49
    ],
    bgWhite: [
        47,
        49
    ],
    blackBright: [
        90,
        39
    ],
    redBright: [
        91,
        39
    ],
    greenBright: [
        92,
        39
    ],
    yellowBright: [
        93,
        39
    ],
    blueBright: [
        94,
        39
    ],
    magentaBright: [
        95,
        39
    ],
    cyanBright: [
        96,
        39
    ],
    whiteBright: [
        97,
        39
    ],
    bgBlackBright: [
        100,
        49
    ],
    bgRedBright: [
        101,
        49
    ],
    bgGreenBright: [
        102,
        49
    ],
    bgYellowBright: [
        103,
        49
    ],
    bgBlueBright: [
        104,
        49
    ],
    bgMagentaBright: [
        105,
        49
    ],
    bgCyanBright: [
        106,
        49
    ],
    bgWhiteBright: [
        107,
        49
    ]
}, chunk_BVHSVHOK_h = Object.entries(chunk_BVHSVHOK_f);
function chunk_BVHSVHOK_a(n) {
    return String(n);
}
chunk_BVHSVHOK_a.open = "";
chunk_BVHSVHOK_a.close = "";
function C(n = !1) {
    let e = "undefined" != typeof process ? process : void 0, i = (null == e ? void 0 : e.env) || {}, g = (null == e ? void 0 : e.argv) || [];
    return !("NO_COLOR" in i || g.includes("--no-color")) && ("FORCE_COLOR" in i || g.includes("--color") || (null == e ? void 0 : e.platform) === "win32" || n && "dumb" !== i.TERM || "CI" in i) || "undefined" != typeof window && !!window.chrome;
}
function chunk_BVHSVHOK_p(n = !1) {
    let e = C(n), i = (r, t, c, o)=>{
        let l = "", s = 0;
        do l += r.substring(s, o) + c, s = o + t.length, o = r.indexOf(t, s);
        while (~o);
        return l + r.substring(s);
    }, g = (r, t, c = r)=>{
        let o = (l)=>{
            let s = String(l), b = s.indexOf(t, r.length);
            return ~b ? r + i(s, t, c, b) + t : r + s + t;
        };
        return o.open = r, o.close = t, o;
    }, u = {
        isColorSupported: e
    }, d = (r)=>`\x1B[${r}m`;
    for (let [r, t] of chunk_BVHSVHOK_h)u[r] = e ? g(d(t[0]), d(t[1]), t[2]) : chunk_BVHSVHOK_a;
    return u;
}
const external_node_tty_ = __webpack_require__("node:tty");
var node_r = void 0 !== process.env.FORCE_TTY || (0, external_node_tty_.isatty)(1);
var node_u = chunk_BVHSVHOK_p(node_r);
function _mergeNamespaces(n, m) {
    m.forEach(function(e) {
        e && 'string' != typeof e && !Array.isArray(e) && Object.keys(e).forEach(function(k) {
            if ('default' !== k && !(k in n)) {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function() {
                        return e[k];
                    }
                });
            }
        });
    });
    return Object.freeze(n);
}
function getKeysOfEnumerableProperties(object, compareKeys) {
    const rawKeys = Object.keys(object);
    const keys = null === compareKeys ? rawKeys : rawKeys.sort(compareKeys);
    if (Object.getOwnPropertySymbols) {
        for (const symbol of Object.getOwnPropertySymbols(object))if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) keys.push(symbol);
    }
    return keys;
}
function printIteratorEntries(iterator, config, indentation, depth, refs, printer, separator = ": ") {
    let result = "";
    let width = 0;
    let current = iterator.next();
    if (!current.done) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        while(!current.done){
            result += indentationNext;
            if (width++ === config.maxWidth) {
                result += "";
                break;
            }
            const name = printer(current.value[0], config, indentationNext, depth, refs);
            const value = printer(current.value[1], config, indentationNext, depth, refs);
            result += name + separator + value;
            current = iterator.next();
            if (current.done) {
                if (!config.min) result += ",";
            } else result += `,${config.spacingInner}`;
        }
        result += config.spacingOuter + indentation;
    }
    return result;
}
function printIteratorValues(iterator, config, indentation, depth, refs, printer) {
    let result = "";
    let width = 0;
    let current = iterator.next();
    if (!current.done) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        while(!current.done){
            result += indentationNext;
            if (width++ === config.maxWidth) {
                result += "";
                break;
            }
            result += printer(current.value, config, indentationNext, depth, refs);
            current = iterator.next();
            if (current.done) {
                if (!config.min) result += ",";
            } else result += `,${config.spacingInner}`;
        }
        result += config.spacingOuter + indentation;
    }
    return result;
}
function printListItems(list, config, indentation, depth, refs, printer) {
    let result = "";
    list = list instanceof ArrayBuffer ? new DataView(list) : list;
    const isDataView = (l)=>l instanceof DataView;
    const length = isDataView(list) ? list.byteLength : list.length;
    if (length > 0) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        for(let i = 0; i < length; i++){
            result += indentationNext;
            if (i === config.maxWidth) {
                result += "";
                break;
            }
            if (isDataView(list) || i in list) result += printer(isDataView(list) ? list.getInt8(i) : list[i], config, indentationNext, depth, refs);
            if (i < length - 1) result += `,${config.spacingInner}`;
            else if (!config.min) result += ",";
        }
        result += config.spacingOuter + indentation;
    }
    return result;
}
function printObjectProperties(val, config, indentation, depth, refs, printer) {
    let result = "";
    const keys = getKeysOfEnumerableProperties(val, config.compareKeys);
    if (keys.length > 0) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            const name = printer(key, config, indentationNext, depth, refs);
            const value = printer(val[key], config, indentationNext, depth, refs);
            result += `${indentationNext + name}: ${value}`;
            if (i < keys.length - 1) result += `,${config.spacingInner}`;
            else if (!config.min) result += ",";
        }
        result += config.spacingOuter + indentation;
    }
    return result;
}
const asymmetricMatcher = "function" == typeof Symbol && Symbol.for ? Symbol.for("jest.asymmetricMatcher") : 1267621;
const SPACE$2 = " ";
const serialize$5 = (val, config, indentation, depth, refs, printer)=>{
    const stringedValue = val.toString();
    if ("ArrayContaining" === stringedValue || "ArrayNotContaining" === stringedValue) {
        if (++depth > config.maxDepth) return `[${stringedValue}]`;
        return `${stringedValue + SPACE$2}[${printListItems(val.sample, config, indentation, depth, refs, printer)}]`;
    }
    if ("ObjectContaining" === stringedValue || "ObjectNotContaining" === stringedValue) {
        if (++depth > config.maxDepth) return `[${stringedValue}]`;
        return `${stringedValue + SPACE$2}{${printObjectProperties(val.sample, config, indentation, depth, refs, printer)}}`;
    }
    if ("StringMatching" === stringedValue || "StringNotMatching" === stringedValue) return stringedValue + SPACE$2 + printer(val.sample, config, indentation, depth, refs);
    if ("StringContaining" === stringedValue || "StringNotContaining" === stringedValue) return stringedValue + SPACE$2 + printer(val.sample, config, indentation, depth, refs);
    if ("function" != typeof val.toAsymmetricMatcher) throw new TypeError(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);
    return val.toAsymmetricMatcher();
};
const test$5 = (val)=>val && val.$$typeof === asymmetricMatcher;
const plugin$5 = {
    serialize: serialize$5,
    test: test$5
};
const SPACE$1 = " ";
const OBJECT_NAMES = new Set([
    "DOMStringMap",
    "NamedNodeMap"
]);
const ARRAY_REGEXP = /^(?:HTML\w*Collection|NodeList)$/;
function dist_testName(name) {
    return OBJECT_NAMES.has(name) || ARRAY_REGEXP.test(name);
}
const test$4 = (val)=>val && val.constructor && !!val.constructor.name && dist_testName(val.constructor.name);
function isNamedNodeMap(collection) {
    return "NamedNodeMap" === collection.constructor.name;
}
const serialize$4 = (collection, config, indentation, depth, refs, printer)=>{
    const name = collection.constructor.name;
    if (++depth > config.maxDepth) return `[${name}]`;
    return (config.min ? "" : name + SPACE$1) + (OBJECT_NAMES.has(name) ? `{${printObjectProperties(isNamedNodeMap(collection) ? [
        ...collection
    ].reduce((props, attribute)=>{
        props[attribute.name] = attribute.value;
        return props;
    }, {}) : {
        ...collection
    }, config, indentation, depth, refs, printer)}}` : `[${printListItems([
        ...collection
    ], config, indentation, depth, refs, printer)}]`);
};
const plugin$4 = {
    serialize: serialize$4,
    test: test$4
};
function escapeHTML(str) {
    return str.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}
function printProps(keys, props, config, indentation, depth, refs, printer) {
    const indentationNext = indentation + config.indent;
    const colors = config.colors;
    return keys.map((key)=>{
        const value = props[key];
        let printed = printer(value, config, indentationNext, depth, refs);
        if ("string" != typeof value) {
            if (printed.includes("\n")) printed = config.spacingOuter + indentationNext + printed + config.spacingOuter + indentation;
            printed = `{${printed}}`;
        }
        return `${config.spacingInner + indentation + colors.prop.open + key + colors.prop.close}=${colors.value.open}${printed}${colors.value.close}`;
    }).join("");
}
function printChildren(children, config, indentation, depth, refs, printer) {
    return children.map((child)=>config.spacingOuter + indentation + ("string" == typeof child ? printText(child, config) : printer(child, config, indentation, depth, refs))).join("");
}
function printText(text, config) {
    const contentColor = config.colors.content;
    return contentColor.open + escapeHTML(text) + contentColor.close;
}
function printComment(comment, config) {
    const commentColor = config.colors.comment;
    return `${commentColor.open}<!--${escapeHTML(comment)}-->${commentColor.close}`;
}
function printElement(type, printedProps, printedChildren, config, indentation) {
    const tagColor = config.colors.tag;
    return `${tagColor.open}<${type}${printedProps && tagColor.close + printedProps + config.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config.spacingOuter}${indentation}${tagColor.open}</${type}` : `${printedProps && !config.min ? "" : " "}/`}>${tagColor.close}`;
}
function printElementAsLeaf(type, config) {
    const tagColor = config.colors.tag;
    return `${tagColor.open}<${type}${tagColor.close} ${tagColor.open} />${tagColor.close}`;
}
const ELEMENT_NODE = 1;
const TEXT_NODE = 3;
const COMMENT_NODE = 8;
const FRAGMENT_NODE = 11;
const ELEMENT_REGEXP = /^(?:(?:HTML|SVG)\w*)?Element$/;
function testHasAttribute(val) {
    try {
        return "function" == typeof val.hasAttribute && val.hasAttribute("is");
    } catch  {
        return false;
    }
}
function testNode(val) {
    const constructorName = val.constructor.name;
    const { nodeType, tagName } = val;
    const isCustomElement = "string" == typeof tagName && tagName.includes("-") || testHasAttribute(val);
    return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE && "Text" === constructorName || nodeType === COMMENT_NODE && "Comment" === constructorName || nodeType === FRAGMENT_NODE && "DocumentFragment" === constructorName;
}
const test$3 = (val)=>{
    var _val$constructor;
    return (null == val || null == (_val$constructor = val.constructor) ? void 0 : _val$constructor.name) && testNode(val);
};
function nodeIsText(node) {
    return node.nodeType === TEXT_NODE;
}
function nodeIsComment(node) {
    return node.nodeType === COMMENT_NODE;
}
function nodeIsFragment(node) {
    return node.nodeType === FRAGMENT_NODE;
}
const serialize$3 = (node, config, indentation, depth, refs, printer)=>{
    if (nodeIsText(node)) return printText(node.data, config);
    if (nodeIsComment(node)) return printComment(node.data, config);
    const type = nodeIsFragment(node) ? "DocumentFragment" : node.tagName.toLowerCase();
    if (++depth > config.maxDepth) return printElementAsLeaf(type, config);
    return printElement(type, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes, (attr)=>attr.name).sort(), nodeIsFragment(node) ? {} : [
        ...node.attributes
    ].reduce((props, attribute)=>{
        props[attribute.name] = attribute.value;
        return props;
    }, {}), config, indentation + config.indent, depth, refs, printer), printChildren(Array.prototype.slice.call(node.childNodes || node.children), config, indentation + config.indent, depth, refs, printer), config, indentation);
};
const plugin$3 = {
    serialize: serialize$3,
    test: test$3
};
const IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
const IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
const IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
const IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
const IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
const IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@";
const IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
const IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
const IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
const getImmutableName = (name)=>`Immutable.${name}`;
const printAsLeaf = (name)=>`[${name}]`;
const SPACE = " ";
const LAZY = "";
function printImmutableEntries(val, config, indentation, depth, refs, printer, type) {
    return ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}{${printIteratorEntries(val.entries(), config, indentation, depth, refs, printer)}}`;
}
function getRecordEntries(val) {
    let i = 0;
    return {
        next () {
            if (i < val._keys.length) {
                const key = val._keys[i++];
                return {
                    done: false,
                    value: [
                        key,
                        val.get(key)
                    ]
                };
            }
            return {
                done: true,
                value: void 0
            };
        }
    };
}
function printImmutableRecord(val, config, indentation, depth, refs, printer) {
    const name = getImmutableName(val._name || "Record");
    return ++depth > config.maxDepth ? printAsLeaf(name) : `${name + SPACE}{${printIteratorEntries(getRecordEntries(val), config, indentation, depth, refs, printer)}}`;
}
function printImmutableSeq(val, config, indentation, depth, refs, printer) {
    const name = getImmutableName("Seq");
    if (++depth > config.maxDepth) return printAsLeaf(name);
    if (val[IS_KEYED_SENTINEL]) return `${name + SPACE}{${val._iter || val._object ? printIteratorEntries(val.entries(), config, indentation, depth, refs, printer) : LAZY}}`;
    return `${name + SPACE}[${val._iter || val._array || val._collection || val._iterable ? printIteratorValues(val.values(), config, indentation, depth, refs, printer) : LAZY}]`;
}
function printImmutableValues(val, config, indentation, depth, refs, printer, type) {
    return ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}[${printIteratorValues(val.values(), config, indentation, depth, refs, printer)}]`;
}
const serialize$2 = (val, config, indentation, depth, refs, printer)=>{
    if (val[IS_MAP_SENTINEL]) return printImmutableEntries(val, config, indentation, depth, refs, printer, val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map");
    if (val[IS_LIST_SENTINEL]) return printImmutableValues(val, config, indentation, depth, refs, printer, "List");
    if (val[IS_SET_SENTINEL]) return printImmutableValues(val, config, indentation, depth, refs, printer, val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set");
    if (val[IS_STACK_SENTINEL]) return printImmutableValues(val, config, indentation, depth, refs, printer, "Stack");
    if (val[IS_SEQ_SENTINEL]) return printImmutableSeq(val, config, indentation, depth, refs, printer);
    return printImmutableRecord(val, config, indentation, depth, refs, printer);
};
const test$2 = (val)=>val && (true === val[IS_ITERABLE_SENTINEL] || true === val[IS_RECORD_SENTINEL]);
const plugin$2 = {
    serialize: serialize$2,
    test: test$2
};
function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}
var reactIs$1 = {
    exports: {}
};
var reactIs_production = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredReactIs_production;
function requireReactIs_production() {
    if (hasRequiredReactIs_production) return reactIs_production;
    hasRequiredReactIs_production = 1;
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    function typeOf(object) {
        if ("object" == typeof object && null !== object) {
            var $$typeof = object.$$typeof;
            switch($$typeof){
                case REACT_ELEMENT_TYPE:
                    switch(object = object.type){
                        case REACT_FRAGMENT_TYPE:
                        case REACT_PROFILER_TYPE:
                        case REACT_STRICT_MODE_TYPE:
                        case REACT_SUSPENSE_TYPE:
                        case REACT_SUSPENSE_LIST_TYPE:
                        case REACT_VIEW_TRANSITION_TYPE:
                            return object;
                        default:
                            switch(object = object && object.$$typeof){
                                case REACT_CONTEXT_TYPE:
                                case REACT_FORWARD_REF_TYPE:
                                case REACT_LAZY_TYPE:
                                case REACT_MEMO_TYPE:
                                    return object;
                                case REACT_CONSUMER_TYPE:
                                    return object;
                                default:
                                    return $$typeof;
                            }
                    }
                case REACT_PORTAL_TYPE:
                    return $$typeof;
            }
        }
    }
    reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
    reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
    reactIs_production.Element = REACT_ELEMENT_TYPE;
    reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
    reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
    reactIs_production.Lazy = REACT_LAZY_TYPE;
    reactIs_production.Memo = REACT_MEMO_TYPE;
    reactIs_production.Portal = REACT_PORTAL_TYPE;
    reactIs_production.Profiler = REACT_PROFILER_TYPE;
    reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
    reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
    reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
    reactIs_production.isContextConsumer = function(object) {
        return typeOf(object) === REACT_CONSUMER_TYPE;
    };
    reactIs_production.isContextProvider = function(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
    };
    reactIs_production.isElement = function(object) {
        return "object" == typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    };
    reactIs_production.isForwardRef = function(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
    };
    reactIs_production.isFragment = function(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
    };
    reactIs_production.isLazy = function(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
    };
    reactIs_production.isMemo = function(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
    };
    reactIs_production.isPortal = function(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
    };
    reactIs_production.isProfiler = function(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
    };
    reactIs_production.isStrictMode = function(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
    };
    reactIs_production.isSuspense = function(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
    };
    reactIs_production.isSuspenseList = function(object) {
        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
    };
    reactIs_production.isValidElementType = function(type) {
        return "string" == typeof type || "function" == typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" == typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId);
    };
    reactIs_production.typeOf = typeOf;
    return reactIs_production;
}
var reactIs_development$1 = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredReactIs_development$1;
function requireReactIs_development$1() {
    if (hasRequiredReactIs_development$1) return reactIs_development$1;
    hasRequiredReactIs_development$1 = 1;
    "production" !== process.env.NODE_ENV && function() {
        function typeOf(object) {
            if ("object" == typeof object && null !== object) {
                var $$typeof = object.$$typeof;
                switch($$typeof){
                    case REACT_ELEMENT_TYPE:
                        switch(object = object.type){
                            case REACT_FRAGMENT_TYPE:
                            case REACT_PROFILER_TYPE:
                            case REACT_STRICT_MODE_TYPE:
                            case REACT_SUSPENSE_TYPE:
                            case REACT_SUSPENSE_LIST_TYPE:
                            case REACT_VIEW_TRANSITION_TYPE:
                                return object;
                            default:
                                switch(object = object && object.$$typeof){
                                    case REACT_CONTEXT_TYPE:
                                    case REACT_FORWARD_REF_TYPE:
                                    case REACT_LAZY_TYPE:
                                    case REACT_MEMO_TYPE:
                                        return object;
                                    case REACT_CONSUMER_TYPE:
                                        return object;
                                    default:
                                        return $$typeof;
                                }
                        }
                    case REACT_PORTAL_TYPE:
                        return $$typeof;
                }
            }
        }
        var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
        reactIs_development$1.ContextConsumer = REACT_CONSUMER_TYPE;
        reactIs_development$1.ContextProvider = REACT_CONTEXT_TYPE;
        reactIs_development$1.Element = REACT_ELEMENT_TYPE;
        reactIs_development$1.ForwardRef = REACT_FORWARD_REF_TYPE;
        reactIs_development$1.Fragment = REACT_FRAGMENT_TYPE;
        reactIs_development$1.Lazy = REACT_LAZY_TYPE;
        reactIs_development$1.Memo = REACT_MEMO_TYPE;
        reactIs_development$1.Portal = REACT_PORTAL_TYPE;
        reactIs_development$1.Profiler = REACT_PROFILER_TYPE;
        reactIs_development$1.StrictMode = REACT_STRICT_MODE_TYPE;
        reactIs_development$1.Suspense = REACT_SUSPENSE_TYPE;
        reactIs_development$1.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        reactIs_development$1.isContextConsumer = function(object) {
            return typeOf(object) === REACT_CONSUMER_TYPE;
        };
        reactIs_development$1.isContextProvider = function(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
        };
        reactIs_development$1.isElement = function(object) {
            return "object" == typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        };
        reactIs_development$1.isForwardRef = function(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
        };
        reactIs_development$1.isFragment = function(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
        };
        reactIs_development$1.isLazy = function(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
        };
        reactIs_development$1.isMemo = function(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
        };
        reactIs_development$1.isPortal = function(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
        };
        reactIs_development$1.isProfiler = function(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
        };
        reactIs_development$1.isStrictMode = function(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
        };
        reactIs_development$1.isSuspense = function(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
        };
        reactIs_development$1.isSuspenseList = function(object) {
            return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        };
        reactIs_development$1.isValidElementType = function(type) {
            return "string" == typeof type || "function" == typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" == typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId);
        };
        reactIs_development$1.typeOf = typeOf;
    }();
    return reactIs_development$1;
}
var hasRequiredReactIs$1;
function requireReactIs$1() {
    if (hasRequiredReactIs$1) return reactIs$1.exports;
    hasRequiredReactIs$1 = 1;
    if ('production' === process.env.NODE_ENV) reactIs$1.exports = requireReactIs_production();
    else reactIs$1.exports = requireReactIs_development$1();
    return reactIs$1.exports;
}
var reactIsExports$1 = requireReactIs$1();
var index$1 = /*@__PURE__*/ getDefaultExportFromCjs(reactIsExports$1);
var ReactIs19 = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null,
    default: index$1
}, [
    reactIsExports$1
]);
var reactIs = {
    exports: {}
};
var reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
    if (hasRequiredReactIs_production_min) return reactIs_production_min;
    hasRequiredReactIs_production_min = 1;
    var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u;
    u = Symbol.for("react.module.reference");
    function v(a) {
        if ("object" == typeof a && null !== a) {
            var r = a.$$typeof;
            switch(r){
                case b:
                    switch(a = a.type){
                        case d:
                        case f:
                        case e:
                        case m:
                        case n:
                            return a;
                        default:
                            switch(a = a && a.$$typeof){
                                case k:
                                case h:
                                case l:
                                case q:
                                case p:
                                case g:
                                    return a;
                                default:
                                    return r;
                            }
                    }
                case c:
                    return r;
            }
        }
    }
    reactIs_production_min.ContextConsumer = h;
    reactIs_production_min.ContextProvider = g;
    reactIs_production_min.Element = b;
    reactIs_production_min.ForwardRef = l;
    reactIs_production_min.Fragment = d;
    reactIs_production_min.Lazy = q;
    reactIs_production_min.Memo = p;
    reactIs_production_min.Portal = c;
    reactIs_production_min.Profiler = f;
    reactIs_production_min.StrictMode = e;
    reactIs_production_min.Suspense = m;
    reactIs_production_min.SuspenseList = n;
    reactIs_production_min.isAsyncMode = function() {
        return false;
    };
    reactIs_production_min.isConcurrentMode = function() {
        return false;
    };
    reactIs_production_min.isContextConsumer = function(a) {
        return v(a) === h;
    };
    reactIs_production_min.isContextProvider = function(a) {
        return v(a) === g;
    };
    reactIs_production_min.isElement = function(a) {
        return "object" == typeof a && null !== a && a.$$typeof === b;
    };
    reactIs_production_min.isForwardRef = function(a) {
        return v(a) === l;
    };
    reactIs_production_min.isFragment = function(a) {
        return v(a) === d;
    };
    reactIs_production_min.isLazy = function(a) {
        return v(a) === q;
    };
    reactIs_production_min.isMemo = function(a) {
        return v(a) === p;
    };
    reactIs_production_min.isPortal = function(a) {
        return v(a) === c;
    };
    reactIs_production_min.isProfiler = function(a) {
        return v(a) === f;
    };
    reactIs_production_min.isStrictMode = function(a) {
        return v(a) === e;
    };
    reactIs_production_min.isSuspense = function(a) {
        return v(a) === m;
    };
    reactIs_production_min.isSuspenseList = function(a) {
        return v(a) === n;
    };
    reactIs_production_min.isValidElementType = function(a) {
        return "string" == typeof a || "function" == typeof a || a === d || a === f || a === e || a === m || a === n || a === t || "object" == typeof a && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === u || void 0 !== a.getModuleId);
    };
    reactIs_production_min.typeOf = v;
    return reactIs_production_min;
}
var reactIs_development = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredReactIs_development;
function requireReactIs_development() {
    if (hasRequiredReactIs_development) return reactIs_development;
    hasRequiredReactIs_development = 1;
    if ("production" !== process.env.NODE_ENV) (function() {
        var REACT_ELEMENT_TYPE = Symbol.for('react.element');
        var REACT_PORTAL_TYPE = Symbol.for('react.portal');
        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
        var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
        var REACT_CONTEXT_TYPE = Symbol.for('react.context');
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var REACT_LAZY_TYPE = Symbol.for('react.lazy');
        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
        function isValidElementType(type) {
            if ('string' == typeof type || 'function' == typeof type) return true;
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) return true;
            if ('object' == typeof type && null !== type) {
                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || void 0 !== type.getModuleId) return true;
            }
            return false;
        }
        function typeOf(object) {
            if ('object' == typeof object && null !== object) {
                var $$typeof = object.$$typeof;
                switch($$typeof){
                    case REACT_ELEMENT_TYPE:
                        var type = object.type;
                        switch(type){
                            case REACT_FRAGMENT_TYPE:
                            case REACT_PROFILER_TYPE:
                            case REACT_STRICT_MODE_TYPE:
                            case REACT_SUSPENSE_TYPE:
                            case REACT_SUSPENSE_LIST_TYPE:
                                return type;
                            default:
                                var $$typeofType = type && type.$$typeof;
                                switch($$typeofType){
                                    case REACT_SERVER_CONTEXT_TYPE:
                                    case REACT_CONTEXT_TYPE:
                                    case REACT_FORWARD_REF_TYPE:
                                    case REACT_LAZY_TYPE:
                                    case REACT_MEMO_TYPE:
                                    case REACT_PROVIDER_TYPE:
                                        return $$typeofType;
                                    default:
                                        return $$typeof;
                                }
                        }
                    case REACT_PORTAL_TYPE:
                        return $$typeof;
                }
            }
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element1 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                console['warn']("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
            return false;
        }
        function isConcurrentMode(object) {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
                hasWarnedAboutDeprecatedIsConcurrentMode = true;
                console['warn']("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
            return false;
        }
        function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
            return 'object' == typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
            return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        reactIs_development.ContextConsumer = ContextConsumer;
        reactIs_development.ContextProvider = ContextProvider;
        reactIs_development.Element = Element1;
        reactIs_development.ForwardRef = ForwardRef;
        reactIs_development.Fragment = Fragment;
        reactIs_development.Lazy = Lazy;
        reactIs_development.Memo = Memo;
        reactIs_development.Portal = Portal;
        reactIs_development.Profiler = Profiler;
        reactIs_development.StrictMode = StrictMode;
        reactIs_development.Suspense = Suspense;
        reactIs_development.SuspenseList = SuspenseList;
        reactIs_development.isAsyncMode = isAsyncMode;
        reactIs_development.isConcurrentMode = isConcurrentMode;
        reactIs_development.isContextConsumer = isContextConsumer;
        reactIs_development.isContextProvider = isContextProvider;
        reactIs_development.isElement = isElement;
        reactIs_development.isForwardRef = isForwardRef;
        reactIs_development.isFragment = isFragment;
        reactIs_development.isLazy = isLazy;
        reactIs_development.isMemo = isMemo;
        reactIs_development.isPortal = isPortal;
        reactIs_development.isProfiler = isProfiler;
        reactIs_development.isStrictMode = isStrictMode;
        reactIs_development.isSuspense = isSuspense;
        reactIs_development.isSuspenseList = isSuspenseList;
        reactIs_development.isValidElementType = isValidElementType;
        reactIs_development.typeOf = typeOf;
    })();
    return reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
    if (hasRequiredReactIs) return reactIs.exports;
    hasRequiredReactIs = 1;
    if ('production' === process.env.NODE_ENV) reactIs.exports = requireReactIs_production_min();
    else reactIs.exports = requireReactIs_development();
    return reactIs.exports;
}
var reactIsExports = requireReactIs();
var dist_index = /*@__PURE__*/ getDefaultExportFromCjs(reactIsExports);
var ReactIs18 = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null,
    default: dist_index
}, [
    reactIsExports
]);
const reactIsMethods = [
    "isAsyncMode",
    "isConcurrentMode",
    "isContextConsumer",
    "isContextProvider",
    "isElement",
    "isForwardRef",
    "isFragment",
    "isLazy",
    "isMemo",
    "isPortal",
    "isProfiler",
    "isStrictMode",
    "isSuspense",
    "isSuspenseList",
    "isValidElementType"
];
const ReactIs = Object.fromEntries(reactIsMethods.map((m)=>[
        m,
        (v)=>ReactIs18[m](v) || ReactIs19[m](v)
    ]));
function getChildren(arg, children = []) {
    if (Array.isArray(arg)) for (const item of arg)getChildren(item, children);
    else if (null != arg && false !== arg && "" !== arg) children.push(arg);
    return children;
}
function getType(element) {
    const type = element.type;
    if ("string" == typeof type) return type;
    if ("function" == typeof type) return type.displayName || type.name || "Unknown";
    if (ReactIs.isFragment(element)) return "React.Fragment";
    if (ReactIs.isSuspense(element)) return "React.Suspense";
    if ("object" == typeof type && null !== type) {
        if (ReactIs.isContextProvider(element)) return "Context.Provider";
        if (ReactIs.isContextConsumer(element)) return "Context.Consumer";
        if (ReactIs.isForwardRef(element)) {
            if (type.displayName) return type.displayName;
            const functionName = type.render.displayName || type.render.name || "";
            return "" === functionName ? "ForwardRef" : `ForwardRef(${functionName})`;
        }
        if (ReactIs.isMemo(element)) {
            const functionName = type.displayName || type.type.displayName || type.type.name || "";
            return "" === functionName ? "Memo" : `Memo(${functionName})`;
        }
    }
    return "UNDEFINED";
}
function getPropKeys$1(element) {
    const { props } = element;
    return Object.keys(props).filter((key)=>"children" !== key && void 0 !== props[key]).sort();
}
const serialize$1 = (element, config, indentation, depth, refs, printer)=>++depth > config.maxDepth ? printElementAsLeaf(getType(element), config) : printElement(getType(element), printProps(getPropKeys$1(element), element.props, config, indentation + config.indent, depth, refs, printer), printChildren(getChildren(element.props.children), config, indentation + config.indent, depth, refs, printer), config, indentation);
const test$1 = (val)=>null != val && ReactIs.isElement(val);
const plugin$1 = {
    serialize: serialize$1,
    test: test$1
};
const testSymbol = "function" == typeof Symbol && Symbol.for ? Symbol.for("react.test.json") : 245830487;
function getPropKeys(object) {
    const { props } = object;
    return props ? Object.keys(props).filter((key)=>void 0 !== props[key]).sort() : [];
}
const serialize = (object, config, indentation, depth, refs, printer)=>++depth > config.maxDepth ? printElementAsLeaf(object.type, config) : printElement(object.type, object.props ? printProps(getPropKeys(object), object.props, config, indentation + config.indent, depth, refs, printer) : "", object.children ? printChildren(object.children, config, indentation + config.indent, depth, refs, printer) : "", config, indentation);
const dist_test = (val)=>val && val.$$typeof === testSymbol;
const dist_plugin = {
    serialize: serialize,
    test: dist_test
};
const dist_toString = Object.prototype.toString;
const toISOString = Date.prototype.toISOString;
const errorToString = Error.prototype.toString;
const regExpToString = RegExp.prototype.toString;
function getConstructorName(val) {
    return "function" == typeof val.constructor && val.constructor.name || "Object";
}
function isWindow(val) {
    return "undefined" != typeof window && val === window;
}
const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
const NEWLINE_REGEXP = /\n/g;
class PrettyFormatPluginError extends Error {
    constructor(message, stack){
        super(message);
        this.stack = stack;
        this.name = this.constructor.name;
    }
}
function isToStringedArrayType(toStringed) {
    return "[object Array]" === toStringed || "[object ArrayBuffer]" === toStringed || "[object DataView]" === toStringed || "[object Float32Array]" === toStringed || "[object Float64Array]" === toStringed || "[object Int8Array]" === toStringed || "[object Int16Array]" === toStringed || "[object Int32Array]" === toStringed || "[object Uint8Array]" === toStringed || "[object Uint8ClampedArray]" === toStringed || "[object Uint16Array]" === toStringed || "[object Uint32Array]" === toStringed;
}
function printNumber(val) {
    return Object.is(val, -0) ? "-0" : String(val);
}
function printBigInt(val) {
    return String(`${val}n`);
}
function printFunction(val, printFunctionName) {
    if (!printFunctionName) return "[Function]";
    return `[Function ${val.name || "anonymous"}]`;
}
function printSymbol(val) {
    return String(val).replace(SYMBOL_REGEXP, "Symbol($1)");
}
function printError(val) {
    return `[${errorToString.call(val)}]`;
}
function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
    if (true === val || false === val) return `${val}`;
    if (void 0 === val) return "undefined";
    if (null === val) return "null";
    const typeOf = typeof val;
    if ("number" === typeOf) return printNumber(val);
    if ("bigint" === typeOf) return printBigInt(val);
    if ("string" === typeOf) {
        if (escapeString) return `"${val.replaceAll(/"|\\/g, "\\$&")}"`;
        return `"${val}"`;
    }
    if ("function" === typeOf) return printFunction(val, printFunctionName);
    if ("symbol" === typeOf) return printSymbol(val);
    const toStringed = dist_toString.call(val);
    if ("[object WeakMap]" === toStringed) return "WeakMap {}";
    if ("[object WeakSet]" === toStringed) return "WeakSet {}";
    if ("[object Function]" === toStringed || "[object GeneratorFunction]" === toStringed) return printFunction(val, printFunctionName);
    if ("[object Symbol]" === toStringed) return printSymbol(val);
    if ("[object Date]" === toStringed) return Number.isNaN(+val) ? "Date { NaN }" : toISOString.call(val);
    if ("[object Error]" === toStringed) return printError(val);
    if ("[object RegExp]" === toStringed) {
        if (escapeRegex) return regExpToString.call(val).replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&");
        return regExpToString.call(val);
    }
    if (val instanceof Error) return printError(val);
    return null;
}
function printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON) {
    if (refs.includes(val)) return "[Circular]";
    refs = [
        ...refs
    ];
    refs.push(val);
    const hitMaxDepth = ++depth > config.maxDepth;
    const min = config.min;
    if (config.callToJSON && !hitMaxDepth && val.toJSON && "function" == typeof val.toJSON && !hasCalledToJSON) return dist_printer(val.toJSON(), config, indentation, depth, refs, true);
    const toStringed = dist_toString.call(val);
    if ("[object Arguments]" === toStringed) return hitMaxDepth ? "[Arguments]" : `${min ? "" : "Arguments "}[${printListItems(val, config, indentation, depth, refs, dist_printer)}]`;
    if (isToStringedArrayType(toStringed)) return hitMaxDepth ? `[${val.constructor.name}]` : `${min ? "" : !config.printBasicPrototype && "Array" === val.constructor.name ? "" : `${val.constructor.name} `}[${printListItems(val, config, indentation, depth, refs, dist_printer)}]`;
    if ("[object Map]" === toStringed) return hitMaxDepth ? "[Map]" : `Map {${printIteratorEntries(val.entries(), config, indentation, depth, refs, dist_printer, " => ")}}`;
    if ("[object Set]" === toStringed) return hitMaxDepth ? "[Set]" : `Set {${printIteratorValues(val.values(), config, indentation, depth, refs, dist_printer)}}`;
    return hitMaxDepth || isWindow(val) ? `[${getConstructorName(val)}]` : `${min ? "" : !config.printBasicPrototype && "Object" === getConstructorName(val) ? "" : `${getConstructorName(val)} `}{${printObjectProperties(val, config, indentation, depth, refs, dist_printer)}}`;
}
const ErrorPlugin = {
    test: (val)=>val && val instanceof Error,
    serialize (val, config, indentation, depth, refs, printer) {
        if (refs.includes(val)) return "[Circular]";
        refs = [
            ...refs,
            val
        ];
        const hitMaxDepth = ++depth > config.maxDepth;
        const { message, cause, ...rest } = val;
        const entries = {
            message,
            ...void 0 !== cause ? {
                cause
            } : {},
            ...val instanceof AggregateError ? {
                errors: val.errors
            } : {},
            ...rest
        };
        const name = "Error" !== val.name ? val.name : getConstructorName(val);
        return hitMaxDepth ? `[${name}]` : `${name} {${printIteratorEntries(Object.entries(entries).values(), config, indentation, depth, refs, printer)}}`;
    }
};
function isNewPlugin(plugin) {
    return null != plugin.serialize;
}
function printPlugin(plugin, val, config, indentation, depth, refs) {
    let printed;
    try {
        printed = isNewPlugin(plugin) ? plugin.serialize(val, config, indentation, depth, refs, dist_printer) : plugin.print(val, (valChild)=>dist_printer(valChild, config, indentation, depth, refs), (str)=>{
            const indentationNext = indentation + config.indent;
            return indentationNext + str.replaceAll(NEWLINE_REGEXP, `\n${indentationNext}`);
        }, {
            edgeSpacing: config.spacingOuter,
            min: config.min,
            spacing: config.spacingInner
        }, config.colors);
    } catch (error) {
        throw new PrettyFormatPluginError(error.message, error.stack);
    }
    if ("string" != typeof printed) throw new TypeError(`pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`);
    return printed;
}
function findPlugin(plugins, val) {
    for (const plugin of plugins)try {
        if (plugin.test(val)) return plugin;
    } catch (error) {
        throw new PrettyFormatPluginError(error.message, error.stack);
    }
    return null;
}
function dist_printer(val, config, indentation, depth, refs, hasCalledToJSON) {
    const plugin = findPlugin(config.plugins, val);
    if (null !== plugin) return printPlugin(plugin, val, config, indentation, depth, refs);
    const basicResult = printBasicValue(val, config.printFunctionName, config.escapeRegex, config.escapeString);
    if (null !== basicResult) return basicResult;
    return printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON);
}
const DEFAULT_THEME = {
    comment: "gray",
    content: "reset",
    prop: "yellow",
    tag: "cyan",
    value: "green"
};
const DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
const DEFAULT_OPTIONS = {
    callToJSON: true,
    compareKeys: void 0,
    escapeRegex: false,
    escapeString: true,
    highlight: false,
    indent: 2,
    maxDepth: 1 / 0,
    maxWidth: 1 / 0,
    min: false,
    plugins: [],
    printBasicPrototype: true,
    printFunctionName: true,
    theme: DEFAULT_THEME
};
function validateOptions(options) {
    for (const key of Object.keys(options))if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS, key)) throw new Error(`pretty-format: Unknown option "${key}".`);
    if (options.min && void 0 !== options.indent && 0 !== options.indent) throw new Error("pretty-format: Options \"min\" and \"indent\" cannot be used together.");
}
function getColorsHighlight() {
    return DEFAULT_THEME_KEYS.reduce((colors, key)=>{
        const value = DEFAULT_THEME[key];
        const color = value && node_u[value];
        if (color && "string" == typeof color.close && "string" == typeof color.open) colors[key] = color;
        else throw new Error(`pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`);
        return colors;
    }, Object.create(null));
}
function getColorsEmpty() {
    return DEFAULT_THEME_KEYS.reduce((colors, key)=>{
        colors[key] = {
            close: "",
            open: ""
        };
        return colors;
    }, Object.create(null));
}
function getPrintFunctionName(options) {
    return (null == options ? void 0 : options.printFunctionName) ?? DEFAULT_OPTIONS.printFunctionName;
}
function getEscapeRegex(options) {
    return (null == options ? void 0 : options.escapeRegex) ?? DEFAULT_OPTIONS.escapeRegex;
}
function getEscapeString(options) {
    return (null == options ? void 0 : options.escapeString) ?? DEFAULT_OPTIONS.escapeString;
}
function getConfig(options) {
    return {
        callToJSON: (null == options ? void 0 : options.callToJSON) ?? DEFAULT_OPTIONS.callToJSON,
        colors: (null == options ? void 0 : options.highlight) ? getColorsHighlight() : getColorsEmpty(),
        compareKeys: "function" == typeof (null == options ? void 0 : options.compareKeys) || (null == options ? void 0 : options.compareKeys) === null ? options.compareKeys : DEFAULT_OPTIONS.compareKeys,
        escapeRegex: getEscapeRegex(options),
        escapeString: getEscapeString(options),
        indent: (null == options ? void 0 : options.min) ? "" : createIndent((null == options ? void 0 : options.indent) ?? DEFAULT_OPTIONS.indent),
        maxDepth: (null == options ? void 0 : options.maxDepth) ?? DEFAULT_OPTIONS.maxDepth,
        maxWidth: (null == options ? void 0 : options.maxWidth) ?? DEFAULT_OPTIONS.maxWidth,
        min: (null == options ? void 0 : options.min) ?? DEFAULT_OPTIONS.min,
        plugins: (null == options ? void 0 : options.plugins) ?? DEFAULT_OPTIONS.plugins,
        printBasicPrototype: (null == options ? void 0 : options.printBasicPrototype) ?? true,
        printFunctionName: getPrintFunctionName(options),
        spacingInner: (null == options ? void 0 : options.min) ? " " : "\n",
        spacingOuter: (null == options ? void 0 : options.min) ? "" : "\n"
    };
}
function createIndent(indent) {
    return Array.from({
        length: indent + 1
    }).join(" ");
}
function format(val, options) {
    if (options) {
        validateOptions(options);
        if (options.plugins) {
            const plugin = findPlugin(options.plugins, val);
            if (null !== plugin) return printPlugin(plugin, val, getConfig(options), "", 0, []);
        }
    }
    const basicResult = printBasicValue(val, getPrintFunctionName(options), getEscapeRegex(options), getEscapeString(options));
    if (null !== basicResult) return basicResult;
    return printComplexValue(val, getConfig(options), "", 0, []);
}
const dist_plugins = {
    AsymmetricMatcher: plugin$5,
    DOMCollection: plugin$4,
    DOMElement: plugin$3,
    Immutable: plugin$2,
    ReactElement: plugin$1,
    ReactTestComponent: dist_plugin,
    Error: ErrorPlugin
};
const ansiColors = {
    bold: [
        '1',
        '22'
    ],
    dim: [
        '2',
        '22'
    ],
    italic: [
        '3',
        '23'
    ],
    underline: [
        '4',
        '24'
    ],
    inverse: [
        '7',
        '27'
    ],
    hidden: [
        '8',
        '28'
    ],
    strike: [
        '9',
        '29'
    ],
    black: [
        '30',
        '39'
    ],
    red: [
        '31',
        '39'
    ],
    green: [
        '32',
        '39'
    ],
    yellow: [
        '33',
        '39'
    ],
    blue: [
        '34',
        '39'
    ],
    magenta: [
        '35',
        '39'
    ],
    cyan: [
        '36',
        '39'
    ],
    white: [
        '37',
        '39'
    ],
    brightblack: [
        '30;1',
        '39'
    ],
    brightred: [
        '31;1',
        '39'
    ],
    brightgreen: [
        '32;1',
        '39'
    ],
    brightyellow: [
        '33;1',
        '39'
    ],
    brightblue: [
        '34;1',
        '39'
    ],
    brightmagenta: [
        '35;1',
        '39'
    ],
    brightcyan: [
        '36;1',
        '39'
    ],
    brightwhite: [
        '37;1',
        '39'
    ],
    grey: [
        '90',
        '39'
    ]
};
const styles = {
    special: 'cyan',
    number: 'yellow',
    bigint: 'yellow',
    boolean: 'yellow',
    undefined: 'grey',
    null: 'bold',
    string: 'green',
    symbol: 'green',
    date: 'magenta',
    regexp: 'red'
};
const truncator = '';
function colorise(value, styleType) {
    const color = ansiColors[styles[styleType]] || ansiColors[styleType] || '';
    if (!color) return String(value);
    return `\u001b[${color[0]}m${String(value)}\u001b[${color[1]}m`;
}
function normaliseOptions({ showHidden = false, depth = 2, colors = false, customInspect = true, showProxy = false, maxArrayLength = 1 / 0, breakLength = 1 / 0, seen = [], truncate = 1 / 0, stylize = String } = {}, inspect) {
    const options = {
        showHidden: Boolean(showHidden),
        depth: Number(depth),
        colors: Boolean(colors),
        customInspect: Boolean(customInspect),
        showProxy: Boolean(showProxy),
        maxArrayLength: Number(maxArrayLength),
        breakLength: Number(breakLength),
        truncate: Number(truncate),
        seen,
        inspect,
        stylize
    };
    if (options.colors) options.stylize = colorise;
    return options;
}
function isHighSurrogate(char) {
    return char >= '\ud800' && char <= '\udbff';
}
function helpers_truncate(string, length, tail = truncator) {
    string = String(string);
    const tailLength = tail.length;
    const stringLength = string.length;
    if (tailLength > length && stringLength > tailLength) return tail;
    if (stringLength > length && stringLength > tailLength) {
        let end = length - tailLength;
        if (end > 0 && isHighSurrogate(string[end - 1])) end -= 1;
        return `${string.slice(0, end)}${tail}`;
    }
    return string;
}
function inspectList(list, options, inspectItem, separator = ', ') {
    inspectItem = inspectItem || options.inspect;
    const size = list.length;
    if (0 === size) return '';
    const originalLength = options.truncate;
    let output = '';
    let peek = '';
    let truncated = '';
    for(let i = 0; i < size; i += 1){
        const last = i + 1 === list.length;
        const secondToLast = i + 2 === list.length;
        truncated = `${truncator}(${list.length - i})`;
        const value = list[i];
        options.truncate = originalLength - output.length - (last ? 0 : separator.length);
        const string = peek || inspectItem(value, options) + (last ? '' : separator);
        const nextLength = output.length + string.length;
        const truncatedLength = nextLength + truncated.length;
        if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) break;
        if (!last && !secondToLast && truncatedLength > originalLength) break;
        peek = last ? '' : inspectItem(list[i + 1], options) + (secondToLast ? '' : separator);
        if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) break;
        output += string;
        if (!last && !secondToLast && nextLength + peek.length >= originalLength) {
            truncated = `${truncator}(${list.length - i - 1})`;
            break;
        }
        truncated = '';
    }
    return `${output}${truncated}`;
}
function quoteComplexKey(key) {
    if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) return key;
    return JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
function inspectProperty([key, value], options) {
    options.truncate -= 2;
    if ('string' == typeof key) key = quoteComplexKey(key);
    else if ('number' != typeof key) key = `[${options.inspect(key, options)}]`;
    options.truncate -= key.length;
    value = options.inspect(value, options);
    return `${key}: ${value}`;
}
function inspectArray(array, options) {
    const nonIndexProperties = Object.keys(array).slice(array.length);
    if (!array.length && !nonIndexProperties.length) return '[]';
    options.truncate -= 4;
    const listContents = inspectList(array, options);
    options.truncate -= listContents.length;
    let propertyContents = '';
    if (nonIndexProperties.length) propertyContents = inspectList(nonIndexProperties.map((key)=>[
            key,
            array[key]
        ]), options, inspectProperty);
    return `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ''} ]`;
}
const getArrayName = (array)=>{
    if ('function' == typeof Buffer && array instanceof Buffer) return 'Buffer';
    if (array[Symbol.toStringTag]) return array[Symbol.toStringTag];
    return array.constructor.name;
};
function inspectTypedArray(array, options) {
    const name = getArrayName(array);
    options.truncate -= name.length + 4;
    const nonIndexProperties = Object.keys(array).slice(array.length);
    if (!array.length && !nonIndexProperties.length) return `${name}[]`;
    let output = '';
    for(let i = 0; i < array.length; i++){
        const string = `${options.stylize(helpers_truncate(array[i], options.truncate), 'number')}${i === array.length - 1 ? '' : ', '}`;
        options.truncate -= string.length;
        if (array[i] !== array.length && options.truncate <= 3) {
            output += `(${array.length - array[i] + 1})`;
            break;
        }
        output += string;
    }
    let propertyContents = '';
    if (nonIndexProperties.length) propertyContents = inspectList(nonIndexProperties.map((key)=>[
            key,
            array[key]
        ]), options, inspectProperty);
    return `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ''} ]`;
}
function inspectDate(dateObject, options) {
    const stringRepresentation = dateObject.toJSON();
    if (null === stringRepresentation) return 'Invalid Date';
    const split = stringRepresentation.split('T');
    const date = split[0];
    return options.stylize(`${date}T${helpers_truncate(split[1], options.truncate - date.length - 1)}`, 'date');
}
function inspectFunction(func, options) {
    const functionType = func[Symbol.toStringTag] || 'Function';
    const name = func.name;
    if (!name) return options.stylize(`[${functionType}]`, 'special');
    return options.stylize(`[${functionType} ${helpers_truncate(name, options.truncate - 11)}]`, 'special');
}
function inspectMapEntry([key, value], options) {
    options.truncate -= 4;
    key = options.inspect(key, options);
    options.truncate -= key.length;
    value = options.inspect(value, options);
    return `${key} => ${value}`;
}
function mapToEntries(map) {
    const entries = [];
    map.forEach((value, key)=>{
        entries.push([
            key,
            value
        ]);
    });
    return entries;
}
function inspectMap(map, options) {
    if (0 === map.size) return 'Map{}';
    options.truncate -= 7;
    return `Map{ ${inspectList(mapToEntries(map), options, inspectMapEntry)} }`;
}
const number_isNaN = Number.isNaN || ((i)=>i !== i);
function inspectNumber(number, options) {
    if (number_isNaN(number)) return options.stylize('NaN', 'number');
    if (number === 1 / 0) return options.stylize('Infinity', 'number');
    if (number === -1 / 0) return options.stylize('-Infinity', 'number');
    if (0 === number) return options.stylize(1 / number === 1 / 0 ? '+0' : '-0', 'number');
    return options.stylize(helpers_truncate(String(number), options.truncate), 'number');
}
function inspectBigInt(number, options) {
    let nums = helpers_truncate(number.toString(), options.truncate - 1);
    if ("" !== nums) nums += 'n';
    return options.stylize(nums, 'bigint');
}
function inspectRegExp(value, options) {
    const flags = value.toString().split('/')[2];
    const sourceLength = options.truncate - (2 + flags.length);
    const source = value.source;
    return options.stylize(`/${helpers_truncate(source, sourceLength)}/${flags}`, 'regexp');
}
function arrayFromSet(set) {
    const values = [];
    set.forEach((value)=>{
        values.push(value);
    });
    return values;
}
function inspectSet(set, options) {
    if (0 === set.size) return 'Set{}';
    options.truncate -= 7;
    return `Set{ ${inspectList(arrayFromSet(set), options)} }`;
}
const stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", 'g');
const escapeCharacters = {
    '\b': '\\b',
    '\t': '\\t',
    '\n': '\\n',
    '\f': '\\f',
    '\r': '\\r',
    "'": "\\'",
    '\\': '\\\\'
};
const hex = 16;
const unicodeLength = 4;
function string_escape(char) {
    return escapeCharacters[char] || `\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-unicodeLength)}`;
}
function inspectString(string, options) {
    if (stringEscapeChars.test(string)) string = string.replace(stringEscapeChars, string_escape);
    return options.stylize(`'${helpers_truncate(string, options.truncate - 2)}'`, 'string');
}
function inspectSymbol(value) {
    if ("description" in Symbol.prototype) return value.description ? `Symbol(${value.description})` : 'Symbol()';
    return value.toString();
}
let getPromiseValue = ()=>'Promise{}';
try {
    const { getPromiseDetails, kPending, kRejected } = process.binding('util');
    if (Array.isArray(getPromiseDetails(Promise.resolve()))) getPromiseValue = (value, options)=>{
        const [state, innerValue] = getPromiseDetails(value);
        if (state === kPending) return 'Promise{<pending>}';
        return `Promise${state === kRejected ? '!' : ''}{${options.inspect(innerValue, options)}}`;
    };
} catch (notNode) {}
const lib_promise = getPromiseValue;
function inspectObject(object, options) {
    const properties = Object.getOwnPropertyNames(object);
    const symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];
    if (0 === properties.length && 0 === symbols.length) return '{}';
    options.truncate -= 4;
    options.seen = options.seen || [];
    if (options.seen.includes(object)) return '[Circular]';
    options.seen.push(object);
    const propertyContents = inspectList(properties.map((key)=>[
            key,
            object[key]
        ]), options, inspectProperty);
    const symbolContents = inspectList(symbols.map((key)=>[
            key,
            object[key]
        ]), options, inspectProperty);
    options.seen.pop();
    let sep = '';
    if (propertyContents && symbolContents) sep = ', ';
    return `{ ${propertyContents}${sep}${symbolContents} }`;
}
const toStringTag = 'undefined' != typeof Symbol && Symbol.toStringTag ? Symbol.toStringTag : false;
function inspectClass(value, options) {
    let name = '';
    if (toStringTag && toStringTag in value) name = value[toStringTag];
    name = name || value.constructor.name;
    if (!name || '_class' === name) name = '<Anonymous Class>';
    options.truncate -= name.length;
    return `${name}${inspectObject(value, options)}`;
}
function inspectArguments(args, options) {
    if (0 === args.length) return 'Arguments[]';
    options.truncate -= 13;
    return `Arguments[ ${inspectList(args, options)} ]`;
}
const errorKeys = [
    'stack',
    'line',
    'column',
    'name',
    'message',
    'fileName',
    'lineNumber',
    'columnNumber',
    'number',
    "description",
    'cause'
];
function error_inspectObject(error, options) {
    const properties = Object.getOwnPropertyNames(error).filter((key)=>-1 === errorKeys.indexOf(key));
    const name = error.name;
    options.truncate -= name.length;
    let message = '';
    if ('string' == typeof error.message) message = helpers_truncate(error.message, options.truncate);
    else properties.unshift('message');
    message = message ? `: ${message}` : '';
    options.truncate -= message.length + 5;
    options.seen = options.seen || [];
    if (options.seen.includes(error)) return '[Circular]';
    options.seen.push(error);
    const propertyContents = inspectList(properties.map((key)=>[
            key,
            error[key]
        ]), options, inspectProperty);
    return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ''}`;
}
function inspectAttribute([key, value], options) {
    options.truncate -= 3;
    if (!value) return `${options.stylize(String(key), 'yellow')}`;
    return `${options.stylize(String(key), 'yellow')}=${options.stylize(`"${value}"`, 'string')}`;
}
function inspectNodeCollection(collection, options) {
    return inspectList(collection, options, inspectNode, '\n');
}
function inspectNode(node, options) {
    switch(node.nodeType){
        case 1:
            return inspectHTML(node, options);
        case 3:
            return options.inspect(node.data, options);
        default:
            return options.inspect(node, options);
    }
}
function inspectHTML(element, options) {
    const properties = element.getAttributeNames();
    const name = element.tagName.toLowerCase();
    const head = options.stylize(`<${name}`, 'special');
    const headClose = options.stylize(">", 'special');
    const tail = options.stylize(`</${name}>`, 'special');
    options.truncate -= 2 * name.length + 5;
    let propertyContents = '';
    if (properties.length > 0) {
        propertyContents += ' ';
        propertyContents += inspectList(properties.map((key)=>[
                key,
                element.getAttribute(key)
            ]), options, inspectAttribute, ' ');
    }
    options.truncate -= propertyContents.length;
    const truncate = options.truncate;
    let children = inspectNodeCollection(element.children, options);
    if (children && children.length > truncate) children = `(${element.children.length})`;
    return `${head}${propertyContents}${headClose}${children}${tail}`;
}
const symbolsSupported = 'function' == typeof Symbol && 'function' == typeof Symbol.for;
const chaiInspect = symbolsSupported ? Symbol.for('chai/inspect') : '@@chai/inspect';
const nodeInspect = Symbol.for('nodejs.util.inspect.custom');
const constructorMap = new WeakMap();
const stringTagMap = {};
const baseTypesMap = {
    undefined: (value, options)=>options.stylize('undefined', 'undefined'),
    null: (value, options)=>options.stylize('null', 'null'),
    boolean: (value, options)=>options.stylize(String(value), 'boolean'),
    Boolean: (value, options)=>options.stylize(String(value), 'boolean'),
    number: inspectNumber,
    Number: inspectNumber,
    bigint: inspectBigInt,
    BigInt: inspectBigInt,
    string: inspectString,
    String: inspectString,
    function: inspectFunction,
    Function: inspectFunction,
    symbol: inspectSymbol,
    Symbol: inspectSymbol,
    Array: inspectArray,
    Date: inspectDate,
    Map: inspectMap,
    Set: inspectSet,
    RegExp: inspectRegExp,
    Promise: lib_promise,
    WeakSet: (value, options)=>options.stylize('WeakSet{}', 'special'),
    WeakMap: (value, options)=>options.stylize('WeakMap{}', 'special'),
    Arguments: inspectArguments,
    Int8Array: inspectTypedArray,
    Uint8Array: inspectTypedArray,
    Uint8ClampedArray: inspectTypedArray,
    Int16Array: inspectTypedArray,
    Uint16Array: inspectTypedArray,
    Int32Array: inspectTypedArray,
    Uint32Array: inspectTypedArray,
    Float32Array: inspectTypedArray,
    Float64Array: inspectTypedArray,
    Generator: ()=>'',
    DataView: ()=>'',
    ArrayBuffer: ()=>'',
    Error: error_inspectObject,
    HTMLCollection: inspectNodeCollection,
    NodeList: inspectNodeCollection
};
const inspectCustom = (value, options, type)=>{
    if (chaiInspect in value && 'function' == typeof value[chaiInspect]) return value[chaiInspect](options);
    if (nodeInspect in value && 'function' == typeof value[nodeInspect]) return value[nodeInspect](options.depth, options);
    if ('inspect' in value && 'function' == typeof value.inspect) return value.inspect(options.depth, options);
    if ('constructor' in value && constructorMap.has(value.constructor)) return constructorMap.get(value.constructor)(value, options);
    if (stringTagMap[type]) return stringTagMap[type](value, options);
    return '';
};
const lib_toString = Object.prototype.toString;
function lib_inspect(value, opts = {}) {
    const options = normaliseOptions(opts, lib_inspect);
    const { customInspect } = options;
    let type = null === value ? 'null' : typeof value;
    if ('object' === type) type = lib_toString.call(value).slice(8, -1);
    if (type in baseTypesMap) return baseTypesMap[type](value, options);
    if (customInspect && value) {
        const output = inspectCustom(value, options, type);
        if (output) {
            if ('string' == typeof output) return output;
            return lib_inspect(output, options);
        }
    }
    const proto = value ? Object.getPrototypeOf(value) : false;
    if (proto === Object.prototype || null === proto) return inspectObject(value, options);
    if (value && 'function' == typeof HTMLElement && value instanceof HTMLElement) return inspectHTML(value, options);
    if ('constructor' in value) {
        if (value.constructor !== Object) return inspectClass(value, options);
        return inspectObject(value, options);
    }
    if (value === Object(value)) return inspectObject(value, options);
    return options.stylize(String(value), type);
}
const { AsymmetricMatcher: AsymmetricMatcher, DOMCollection: DOMCollection, DOMElement: DOMElement, Immutable: Immutable, ReactElement: ReactElement, ReactTestComponent: ReactTestComponent } = dist_plugins;
const PLUGINS = [
    ReactTestComponent,
    ReactElement,
    DOMElement,
    DOMCollection,
    Immutable,
    AsymmetricMatcher
];
function stringify(object, maxDepth = 10, { maxLength, ...options } = {}) {
    const MAX_LENGTH = maxLength ?? 1e4;
    let result;
    try {
        result = format(object, {
            maxDepth,
            escapeString: false,
            plugins: PLUGINS,
            ...options
        });
    } catch  {
        result = format(object, {
            callToJSON: false,
            maxDepth,
            escapeString: false,
            plugins: PLUGINS,
            ...options
        });
    }
    return result.length >= MAX_LENGTH && maxDepth > 1 ? stringify(object, Math.floor(Math.min(maxDepth, Number.MAX_SAFE_INTEGER) / 2), {
        maxLength,
        ...options
    }) : result;
}
const formatRegExp = /%[sdjifoOc%]/g;
function chunk_commonjsHelpers_format(...args) {
    if ("string" != typeof args[0]) {
        const objects = [];
        for(let i = 0; i < args.length; i++)objects.push(chunk_commonjsHelpers_inspect(args[i], {
            depth: 0,
            colors: false
        }));
        return objects.join(" ");
    }
    const len = args.length;
    let i = 1;
    const template = args[0];
    let str = String(template).replace(formatRegExp, (x)=>{
        if ("%%" === x) return "%";
        if (i >= len) return x;
        switch(x){
            case "%s":
                {
                    const value = args[i++];
                    if ("bigint" == typeof value) return `${value.toString()}n`;
                    if ("number" == typeof value && 0 === value && 1 / value < 0) return "-0";
                    if ("object" == typeof value && null !== value) {
                        if ("function" == typeof value.toString && value.toString !== Object.prototype.toString) return value.toString();
                        return chunk_commonjsHelpers_inspect(value, {
                            depth: 0,
                            colors: false
                        });
                    }
                    return String(value);
                }
            case "%d":
                {
                    const value = args[i++];
                    if ("bigint" == typeof value) return `${value.toString()}n`;
                    return Number(value).toString();
                }
            case "%i":
                {
                    const value = args[i++];
                    if ("bigint" == typeof value) return `${value.toString()}n`;
                    return Number.parseInt(String(value)).toString();
                }
            case "%f":
                return Number.parseFloat(String(args[i++])).toString();
            case "%o":
                return chunk_commonjsHelpers_inspect(args[i++], {
                    showHidden: true,
                    showProxy: true
                });
            case "%O":
                return chunk_commonjsHelpers_inspect(args[i++]);
            case "%c":
                i++;
                return "";
            case "%j":
                try {
                    return JSON.stringify(args[i++]);
                } catch (err) {
                    const m = err.message;
                    if (m.includes("circular structure") || m.includes("cyclic structures") || m.includes("cyclic object")) return "[Circular]";
                    throw err;
                }
            default:
                return x;
        }
    });
    for(let x = args[i]; i < len; x = args[++i])if (null === x || "object" != typeof x) str += ` ${x}`;
    else str += ` ${chunk_commonjsHelpers_inspect(x)}`;
    return str;
}
function chunk_commonjsHelpers_inspect(obj, options = {}) {
    if (0 === options.truncate) options.truncate = 1 / 0;
    return lib_inspect(obj, options);
}
function chunk_commonjsHelpers_getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}
function assertTypes(value, name, types) {
    const receivedType = typeof value;
    const pass = types.includes(receivedType);
    if (!pass) throw new TypeError(`${name} value must be ${types.join(" or ")}, received "${receivedType}"`);
}
function helpers_isObject(item) {
    return null != item && "object" == typeof item && !Array.isArray(item);
}
function isFinalObj(obj) {
    return obj === Object.prototype || obj === Function.prototype || obj === RegExp.prototype;
}
function helpers_getType(value) {
    return Object.prototype.toString.apply(value).slice(8, -1);
}
function collectOwnProperties(obj, collector) {
    const collect = "function" == typeof collector ? collector : (key)=>collector.add(key);
    Object.getOwnPropertyNames(obj).forEach(collect);
    Object.getOwnPropertySymbols(obj).forEach(collect);
}
function getOwnProperties(obj) {
    const ownProps = new Set();
    if (isFinalObj(obj)) return [];
    collectOwnProperties(obj, ownProps);
    return Array.from(ownProps);
}
const defaultCloneOptions = {
    forceWritable: false
};
function deepClone(val, options = defaultCloneOptions) {
    const seen = new WeakMap();
    return helpers_clone(val, seen, options);
}
function helpers_clone(val, seen, options = defaultCloneOptions) {
    let k, out;
    if (seen.has(val)) return seen.get(val);
    if (Array.isArray(val)) {
        out = Array.from({
            length: k = val.length
        });
        seen.set(val, out);
        while(k--)out[k] = helpers_clone(val[k], seen, options);
        return out;
    }
    if ("[object Object]" === Object.prototype.toString.call(val)) {
        out = Object.create(Object.getPrototypeOf(val));
        seen.set(val, out);
        const props = getOwnProperties(val);
        for (const k of props){
            const descriptor = Object.getOwnPropertyDescriptor(val, k);
            if (!descriptor) continue;
            const cloned = helpers_clone(val[k], seen, options);
            if (options.forceWritable) Object.defineProperty(out, k, {
                enumerable: descriptor.enumerable,
                configurable: true,
                writable: true,
                value: cloned
            });
            else if ("get" in descriptor) Object.defineProperty(out, k, {
                ...descriptor,
                get () {
                    return cloned;
                }
            });
            else Object.defineProperty(out, k, {
                ...descriptor,
                value: cloned
            });
        }
        return out;
    }
    return val;
}
function noop() {}
const DIFF_DELETE = -1;
const DIFF_INSERT = 1;
const DIFF_EQUAL = 0;
class Diff {
    0;
    1;
    constructor(op, text){
        this[0] = op;
        this[1] = text;
    }
}
function diff_commonPrefix(text1, text2) {
    if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) return 0;
    let pointermin = 0;
    let pointermax = Math.min(text1.length, text2.length);
    let pointermid = pointermax;
    let pointerstart = 0;
    while(pointermin < pointermid){
        if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {
            pointermin = pointermid;
            pointerstart = pointermin;
        } else pointermax = pointermid;
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }
    return pointermid;
}
function diff_commonSuffix(text1, text2) {
    if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) return 0;
    let pointermin = 0;
    let pointermax = Math.min(text1.length, text2.length);
    let pointermid = pointermax;
    let pointerend = 0;
    while(pointermin < pointermid){
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {
            pointermin = pointermid;
            pointerend = pointermin;
        } else pointermax = pointermid;
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }
    return pointermid;
}
function diff_commonOverlap_(text1, text2) {
    const text1_length = text1.length;
    const text2_length = text2.length;
    if (0 === text1_length || 0 === text2_length) return 0;
    if (text1_length > text2_length) text1 = text1.substring(text1_length - text2_length);
    else if (text1_length < text2_length) text2 = text2.substring(0, text1_length);
    const text_length = Math.min(text1_length, text2_length);
    if (text1 === text2) return text_length;
    let best = 0;
    let length = 1;
    while(true){
        const pattern = text1.substring(text_length - length);
        const found = text2.indexOf(pattern);
        if (-1 === found) return best;
        length += found;
        if (0 === found || text1.substring(text_length - length) === text2.substring(0, length)) {
            best = length;
            length++;
        }
    }
}
function diff_cleanupSemantic(diffs) {
    let changes = false;
    const equalities = [];
    let equalitiesLength = 0;
    let lastEquality = null;
    let pointer = 0;
    let length_insertions1 = 0;
    let length_deletions1 = 0;
    let length_insertions2 = 0;
    let length_deletions2 = 0;
    while(pointer < diffs.length){
        if (diffs[pointer][0] === DIFF_EQUAL) {
            equalities[equalitiesLength++] = pointer;
            length_insertions1 = length_insertions2;
            length_deletions1 = length_deletions2;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastEquality = diffs[pointer][1];
        } else {
            if (diffs[pointer][0] === DIFF_INSERT) length_insertions2 += diffs[pointer][1].length;
            else length_deletions2 += diffs[pointer][1].length;
            if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
                diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality));
                diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                equalitiesLength--;
                equalitiesLength--;
                pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
                length_insertions1 = 0;
                length_deletions1 = 0;
                length_insertions2 = 0;
                length_deletions2 = 0;
                lastEquality = null;
                changes = true;
            }
        }
        pointer++;
    }
    if (changes) diff_cleanupMerge(diffs);
    diff_cleanupSemanticLossless(diffs);
    pointer = 1;
    while(pointer < diffs.length){
        if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
            const deletion = diffs[pointer - 1][1];
            const insertion = diffs[pointer][1];
            const overlap_length1 = diff_commonOverlap_(deletion, insertion);
            const overlap_length2 = diff_commonOverlap_(insertion, deletion);
            if (overlap_length1 >= overlap_length2) {
                if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
                    diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));
                    diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
                    diffs[pointer + 1][1] = insertion.substring(overlap_length1);
                    pointer++;
                }
            } else if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
                diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));
                diffs[pointer - 1][0] = DIFF_INSERT;
                diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
                diffs[pointer + 1][0] = DIFF_DELETE;
                diffs[pointer + 1][1] = deletion.substring(overlap_length2);
                pointer++;
            }
            pointer++;
        }
        pointer++;
    }
}
const nonAlphaNumericRegex_ = /[^a-z0-9]/i;
const whitespaceRegex_ = /\s/;
const linebreakRegex_ = /[\r\n]/;
const blanklineEndRegex_ = /\n\r?\n$/;
const blanklineStartRegex_ = /^\r?\n\r?\n/;
function diff_cleanupSemanticLossless(diffs) {
    let pointer = 1;
    while(pointer < diffs.length - 1){
        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
            let equality1 = diffs[pointer - 1][1];
            let edit = diffs[pointer][1];
            let equality2 = diffs[pointer + 1][1];
            const commonOffset = diff_commonSuffix(equality1, edit);
            if (commonOffset) {
                const commonString = edit.substring(edit.length - commonOffset);
                equality1 = equality1.substring(0, equality1.length - commonOffset);
                edit = commonString + edit.substring(0, edit.length - commonOffset);
                equality2 = commonString + equality2;
            }
            let bestEquality1 = equality1;
            let bestEdit = edit;
            let bestEquality2 = equality2;
            let bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
            while(edit.charAt(0) === equality2.charAt(0)){
                equality1 += edit.charAt(0);
                edit = edit.substring(1) + equality2.charAt(0);
                equality2 = equality2.substring(1);
                const score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
                if (score >= bestScore) {
                    bestScore = score;
                    bestEquality1 = equality1;
                    bestEdit = edit;
                    bestEquality2 = equality2;
                }
            }
            if (diffs[pointer - 1][1] !== bestEquality1) {
                if (bestEquality1) diffs[pointer - 1][1] = bestEquality1;
                else {
                    diffs.splice(pointer - 1, 1);
                    pointer--;
                }
                diffs[pointer][1] = bestEdit;
                if (bestEquality2) diffs[pointer + 1][1] = bestEquality2;
                else {
                    diffs.splice(pointer + 1, 1);
                    pointer--;
                }
            }
        }
        pointer++;
    }
}
function diff_cleanupMerge(diffs) {
    diffs.push(new Diff(DIFF_EQUAL, ""));
    let pointer = 0;
    let count_delete = 0;
    let count_insert = 0;
    let text_delete = "";
    let text_insert = "";
    let commonlength;
    while(pointer < diffs.length)switch(diffs[pointer][0]){
        case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
        case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
        case DIFF_EQUAL:
            if (count_delete + count_insert > 1) {
                if (0 !== count_delete && 0 !== count_insert) {
                    commonlength = diff_commonPrefix(text_insert, text_delete);
                    if (0 !== commonlength) {
                        if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] === DIFF_EQUAL) diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                        else {
                            diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));
                            pointer++;
                        }
                        text_insert = text_insert.substring(commonlength);
                        text_delete = text_delete.substring(commonlength);
                    }
                    commonlength = diff_commonSuffix(text_insert, text_delete);
                    if (0 !== commonlength) {
                        diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                        text_insert = text_insert.substring(0, text_insert.length - commonlength);
                        text_delete = text_delete.substring(0, text_delete.length - commonlength);
                    }
                }
                pointer -= count_delete + count_insert;
                diffs.splice(pointer, count_delete + count_insert);
                if (text_delete.length) {
                    diffs.splice(pointer, 0, new Diff(DIFF_DELETE, text_delete));
                    pointer++;
                }
                if (text_insert.length) {
                    diffs.splice(pointer, 0, new Diff(DIFF_INSERT, text_insert));
                    pointer++;
                }
                pointer++;
            } else if (0 !== pointer && diffs[pointer - 1][0] === DIFF_EQUAL) {
                diffs[pointer - 1][1] += diffs[pointer][1];
                diffs.splice(pointer, 1);
            } else pointer++;
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
    }
    if ("" === diffs[diffs.length - 1][1]) diffs.pop();
    let changes = false;
    pointer = 1;
    while(pointer < diffs.length - 1){
        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
            if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
                diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                diffs.splice(pointer - 1, 1);
                changes = true;
            } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {
                diffs[pointer - 1][1] += diffs[pointer + 1][1];
                diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                diffs.splice(pointer + 1, 1);
                changes = true;
            }
        }
        pointer++;
    }
    if (changes) diff_cleanupMerge(diffs);
}
function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two) return 6;
    const char1 = one.charAt(one.length - 1);
    const char2 = two.charAt(0);
    const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
    const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
    const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
    const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
    const lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
    const lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
    const blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
    const blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
    if (blankLine1 || blankLine2) return 5;
    if (lineBreak1 || lineBreak2) return 4;
    if (nonAlphaNumeric1 && !whitespace1 && whitespace2) return 3;
    if (whitespace1 || whitespace2) return 2;
    if (nonAlphaNumeric1 || nonAlphaNumeric2) return 1;
    return 0;
}
const NO_DIFF_MESSAGE = "Compared values have no visual difference.";
const SIMILAR_MESSAGE = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.";
var build = {};
var hasRequiredBuild;
function requireBuild() {
    if (hasRequiredBuild) return build;
    hasRequiredBuild = 1;
    Object.defineProperty(build, '__esModule', {
        value: true
    });
    build.default = diffSequence;
    const pkg = 'diff-sequences';
    const NOT_YET_SET = 0;
    const countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon)=>{
        let nCommon = 0;
        while(aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)){
            aIndex += 1;
            bIndex += 1;
            nCommon += 1;
        }
        return nCommon;
    };
    const countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon)=>{
        let nCommon = 0;
        while(aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)){
            aIndex -= 1;
            bIndex -= 1;
            nCommon += 1;
        }
        return nCommon;
    };
    const extendPathsF = (d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF)=>{
        let iF = 0;
        let kF = -d;
        let aFirst = aIndexesF[iF];
        let aIndexPrev1 = aFirst;
        aIndexesF[iF] += countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
        const nF = d < iMaxF ? d : iMaxF;
        for(iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2){
            if (iF !== d && aIndexPrev1 < aIndexesF[iF]) aFirst = aIndexesF[iF];
            else {
                aFirst = aIndexPrev1 + 1;
                if (aEnd <= aFirst) return iF - 1;
            }
            aIndexPrev1 = aIndexesF[iF];
            aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
        }
        return iMaxF;
    };
    const extendPathsR = (d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR)=>{
        let iR = 0;
        let kR = d;
        let aFirst = aIndexesR[iR];
        let aIndexPrev1 = aFirst;
        aIndexesR[iR] -= countCommonItemsR(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon);
        const nR = d < iMaxR ? d : iMaxR;
        for(iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2){
            if (iR !== d && aIndexesR[iR] < aIndexPrev1) aFirst = aIndexesR[iR];
            else {
                aFirst = aIndexPrev1 - 1;
                if (aFirst < aStart) return iR - 1;
            }
            aIndexPrev1 = aIndexesR[iR];
            aIndexesR[iR] = aFirst - countCommonItemsR(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon);
        }
        return iMaxR;
    };
    const extendOverlappablePathsF = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)=>{
        const bF = bStart - aStart;
        const aLength = aEnd - aStart;
        const bLength = bEnd - bStart;
        const baDeltaLength = bLength - aLength;
        const kMinOverlapF = -baDeltaLength - (d - 1);
        const kMaxOverlapF = -baDeltaLength + (d - 1);
        let aIndexPrev1 = NOT_YET_SET;
        const nF = d < iMaxF ? d : iMaxF;
        for(let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2){
            const insert = 0 === iF || iF !== d && aIndexPrev1 < aIndexesF[iF];
            const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;
            const aFirst = insert ? aLastPrev : aLastPrev + 1;
            const bFirst = bF + aFirst - kF;
            const nCommonF = countCommonItemsF(aFirst + 1, aEnd, bFirst + 1, bEnd, isCommon);
            const aLast = aFirst + nCommonF;
            aIndexPrev1 = aIndexesF[iF];
            aIndexesF[iF] = aLast;
            if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {
                const iR = (d - 1 - (kF + baDeltaLength)) / 2;
                if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
                    const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1);
                    const nCommonR = countCommonItemsR(aStart, aLastPrev, bStart, bLastPrev, isCommon);
                    const aIndexPrevFirst = aLastPrev - nCommonR;
                    const bIndexPrevFirst = bLastPrev - nCommonR;
                    const aEndPreceding = aIndexPrevFirst + 1;
                    const bEndPreceding = bIndexPrevFirst + 1;
                    division.nChangePreceding = d - 1;
                    if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {
                        division.aEndPreceding = aStart;
                        division.bEndPreceding = bStart;
                    } else {
                        division.aEndPreceding = aEndPreceding;
                        division.bEndPreceding = bEndPreceding;
                    }
                    division.nCommonPreceding = nCommonR;
                    if (0 !== nCommonR) {
                        division.aCommonPreceding = aEndPreceding;
                        division.bCommonPreceding = bEndPreceding;
                    }
                    division.nCommonFollowing = nCommonF;
                    if (0 !== nCommonF) {
                        division.aCommonFollowing = aFirst + 1;
                        division.bCommonFollowing = bFirst + 1;
                    }
                    const aStartFollowing = aLast + 1;
                    const bStartFollowing = bFirst + nCommonF + 1;
                    division.nChangeFollowing = d - 1;
                    if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
                        division.aStartFollowing = aEnd;
                        division.bStartFollowing = bEnd;
                    } else {
                        division.aStartFollowing = aStartFollowing;
                        division.bStartFollowing = bStartFollowing;
                    }
                    return true;
                }
            }
        }
        return false;
    };
    const extendOverlappablePathsR = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)=>{
        const bR = bEnd - aEnd;
        const aLength = aEnd - aStart;
        const bLength = bEnd - bStart;
        const baDeltaLength = bLength - aLength;
        const kMinOverlapR = baDeltaLength - d;
        const kMaxOverlapR = baDeltaLength + d;
        let aIndexPrev1 = NOT_YET_SET;
        const nR = d < iMaxR ? d : iMaxR;
        for(let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2){
            const insert = 0 === iR || iR !== d && aIndexesR[iR] < aIndexPrev1;
            const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;
            const aFirst = insert ? aLastPrev : aLastPrev - 1;
            const bFirst = bR + aFirst - kR;
            const nCommonR = countCommonItemsR(aStart, aFirst - 1, bStart, bFirst - 1, isCommon);
            const aLast = aFirst - nCommonR;
            aIndexPrev1 = aIndexesR[iR];
            aIndexesR[iR] = aLast;
            if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {
                const iF = (d + (kR - baDeltaLength)) / 2;
                if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
                    const bLast = bFirst - nCommonR;
                    division.nChangePreceding = d;
                    if (d === aLast + bLast - aStart - bStart) {
                        division.aEndPreceding = aStart;
                        division.bEndPreceding = bStart;
                    } else {
                        division.aEndPreceding = aLast;
                        division.bEndPreceding = bLast;
                    }
                    division.nCommonPreceding = nCommonR;
                    if (0 !== nCommonR) {
                        division.aCommonPreceding = aLast;
                        division.bCommonPreceding = bLast;
                    }
                    division.nChangeFollowing = d - 1;
                    if (1 === d) {
                        division.nCommonFollowing = 0;
                        division.aStartFollowing = aEnd;
                        division.bStartFollowing = bEnd;
                    } else {
                        const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1);
                        const nCommonF = countCommonItemsF(aLastPrev, aEnd, bLastPrev, bEnd, isCommon);
                        division.nCommonFollowing = nCommonF;
                        if (0 !== nCommonF) {
                            division.aCommonFollowing = aLastPrev;
                            division.bCommonFollowing = bLastPrev;
                        }
                        const aStartFollowing = aLastPrev + nCommonF;
                        const bStartFollowing = bLastPrev + nCommonF;
                        if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
                            division.aStartFollowing = aEnd;
                            division.bStartFollowing = bEnd;
                        } else {
                            division.aStartFollowing = aStartFollowing;
                            division.bStartFollowing = bStartFollowing;
                        }
                    }
                    return true;
                }
            }
        }
        return false;
    };
    const divide = (nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division)=>{
        const bF = bStart - aStart;
        const bR = bEnd - aEnd;
        const aLength = aEnd - aStart;
        const bLength = bEnd - bStart;
        const baDeltaLength = bLength - aLength;
        let iMaxF = aLength;
        let iMaxR = aLength;
        aIndexesF[0] = aStart - 1;
        aIndexesR[0] = aEnd;
        if (baDeltaLength % 2 === 0) {
            const dMin = (nChange || baDeltaLength) / 2;
            const dMax = (aLength + bLength) / 2;
            for(let d = 1; d <= dMax; d += 1){
                iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
                if (d < dMin) iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
                else if (extendOverlappablePathsR(d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)) return;
            }
        } else {
            const dMin = ((nChange || baDeltaLength) + 1) / 2;
            const dMax = (aLength + bLength + 1) / 2;
            let d = 1;
            iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
            for(d += 1; d <= dMax; d += 1){
                iMaxR = extendPathsR(d - 1, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
                if (d < dMin) iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
                else if (extendOverlappablePathsF(d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)) return;
            }
        }
        throw new Error(`${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`);
    };
    const findSubsequences = (nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division)=>{
        if (bEnd - bStart < aEnd - aStart) {
            transposed = !transposed;
            if (transposed && 1 === callbacks.length) {
                const { foundSubsequence, isCommon } = callbacks[0];
                callbacks[1] = {
                    foundSubsequence: (nCommon, bCommon, aCommon)=>{
                        foundSubsequence(nCommon, aCommon, bCommon);
                    },
                    isCommon: (bIndex, aIndex)=>isCommon(aIndex, bIndex)
                };
            }
            const tStart = aStart;
            const tEnd = aEnd;
            aStart = bStart;
            aEnd = bEnd;
            bStart = tStart;
            bEnd = tEnd;
        }
        const { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];
        divide(nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division);
        const { nChangePreceding, aEndPreceding, bEndPreceding, nCommonPreceding, aCommonPreceding, bCommonPreceding, nCommonFollowing, aCommonFollowing, bCommonFollowing, nChangeFollowing, aStartFollowing, bStartFollowing } = division;
        if (aStart < aEndPreceding && bStart < bEndPreceding) findSubsequences(nChangePreceding, aStart, aEndPreceding, bStart, bEndPreceding, transposed, callbacks, aIndexesF, aIndexesR, division);
        if (0 !== nCommonPreceding) foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);
        if (0 !== nCommonFollowing) foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);
        if (aStartFollowing < aEnd && bStartFollowing < bEnd) findSubsequences(nChangeFollowing, aStartFollowing, aEnd, bStartFollowing, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division);
    };
    const validateLength = (name, arg)=>{
        if ('number' != typeof arg) throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);
        if (!Number.isSafeInteger(arg)) throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);
        if (arg < 0) throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);
    };
    const validateCallback = (name, arg)=>{
        const type = typeof arg;
        if ('function' !== type) throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);
    };
    function diffSequence(aLength, bLength, isCommon, foundSubsequence) {
        validateLength('aLength', aLength);
        validateLength('bLength', bLength);
        validateCallback('isCommon', isCommon);
        validateCallback('foundSubsequence', foundSubsequence);
        const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);
        if (0 !== nCommonF) foundSubsequence(nCommonF, 0, 0);
        if (aLength !== nCommonF || bLength !== nCommonF) {
            const aStart = nCommonF;
            const bStart = nCommonF;
            const nCommonR = countCommonItemsR(aStart, aLength - 1, bStart, bLength - 1, isCommon);
            const aEnd = aLength - nCommonR;
            const bEnd = bLength - nCommonR;
            const nCommonFR = nCommonF + nCommonR;
            if (aLength !== nCommonFR && bLength !== nCommonFR) {
                const nChange = 0;
                const transposed = false;
                const callbacks = [
                    {
                        foundSubsequence,
                        isCommon
                    }
                ];
                const aIndexesF = [
                    NOT_YET_SET
                ];
                const aIndexesR = [
                    NOT_YET_SET
                ];
                const division = {
                    aCommonFollowing: NOT_YET_SET,
                    aCommonPreceding: NOT_YET_SET,
                    aEndPreceding: NOT_YET_SET,
                    aStartFollowing: NOT_YET_SET,
                    bCommonFollowing: NOT_YET_SET,
                    bCommonPreceding: NOT_YET_SET,
                    bEndPreceding: NOT_YET_SET,
                    bStartFollowing: NOT_YET_SET,
                    nChangeFollowing: NOT_YET_SET,
                    nChangePreceding: NOT_YET_SET,
                    nCommonFollowing: NOT_YET_SET,
                    nCommonPreceding: NOT_YET_SET
                };
                findSubsequences(nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division);
            }
            if (0 !== nCommonR) foundSubsequence(nCommonR, aEnd, bEnd);
        }
    }
    return build;
}
var buildExports = requireBuild();
var diffSequences = /*@__PURE__*/ chunk_commonjsHelpers_getDefaultExportFromCjs(buildExports);
function formatTrailingSpaces(line, trailingSpaceFormatter) {
    return line.replace(/\s+$/, (match)=>trailingSpaceFormatter(match));
}
function printDiffLine(line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {
    return 0 !== line.length ? color(`${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`) : " " !== indicator ? color(indicator) : isFirstOrLast && 0 !== emptyFirstOrLastLinePlaceholder.length ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : "";
}
function printDeleteLine(line, isFirstOrLast, { aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
    return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function printInsertLine(line, isFirstOrLast, { bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
    return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function printCommonLine(line, isFirstOrLast, { commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
    return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function createPatchMark(aStart, aEnd, bStart, bEnd, { patchColor }) {
    return patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);
}
function joinAlignedDiffsNoExpand(diffs, options) {
    const iLength = diffs.length;
    const nContextLines = options.contextLines;
    const nContextLines2 = nContextLines + nContextLines;
    let jLength = iLength;
    let hasExcessAtStartOrEnd = false;
    let nExcessesBetweenChanges = 0;
    let i = 0;
    while(i !== iLength){
        const iStart = i;
        while(i !== iLength && diffs[i][0] === DIFF_EQUAL)i += 1;
        if (iStart !== i) if (0 === iStart) {
            if (i > nContextLines) {
                jLength -= i - nContextLines;
                hasExcessAtStartOrEnd = true;
            }
        } else if (i === iLength) {
            const n = i - iStart;
            if (n > nContextLines) {
                jLength -= n - nContextLines;
                hasExcessAtStartOrEnd = true;
            }
        } else {
            const n = i - iStart;
            if (n > nContextLines2) {
                jLength -= n - nContextLines2;
                nExcessesBetweenChanges += 1;
            }
        }
        while(i !== iLength && diffs[i][0] !== DIFF_EQUAL)i += 1;
    }
    const hasPatch = 0 !== nExcessesBetweenChanges || hasExcessAtStartOrEnd;
    if (0 !== nExcessesBetweenChanges) jLength += nExcessesBetweenChanges + 1;
    else if (hasExcessAtStartOrEnd) jLength += 1;
    const jLast = jLength - 1;
    const lines = [];
    let jPatchMark = 0;
    if (hasPatch) lines.push("");
    let aStart = 0;
    let bStart = 0;
    let aEnd = 0;
    let bEnd = 0;
    const pushCommonLine = (line)=>{
        const j = lines.length;
        lines.push(printCommonLine(line, 0 === j || j === jLast, options));
        aEnd += 1;
        bEnd += 1;
    };
    const pushDeleteLine = (line)=>{
        const j = lines.length;
        lines.push(printDeleteLine(line, 0 === j || j === jLast, options));
        aEnd += 1;
    };
    const pushInsertLine = (line)=>{
        const j = lines.length;
        lines.push(printInsertLine(line, 0 === j || j === jLast, options));
        bEnd += 1;
    };
    i = 0;
    while(i !== iLength){
        let iStart = i;
        while(i !== iLength && diffs[i][0] === DIFF_EQUAL)i += 1;
        if (iStart !== i) if (0 === iStart) {
            if (i > nContextLines) {
                iStart = i - nContextLines;
                aStart = iStart;
                bStart = iStart;
                aEnd = aStart;
                bEnd = bStart;
            }
            for(let iCommon = iStart; iCommon !== i; iCommon += 1)pushCommonLine(diffs[iCommon][1]);
        } else if (i === iLength) {
            const iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;
            for(let iCommon = iStart; iCommon !== iEnd; iCommon += 1)pushCommonLine(diffs[iCommon][1]);
        } else {
            const nCommon = i - iStart;
            if (nCommon > nContextLines2) {
                const iEnd = iStart + nContextLines;
                for(let iCommon = iStart; iCommon !== iEnd; iCommon += 1)pushCommonLine(diffs[iCommon][1]);
                lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
                jPatchMark = lines.length;
                lines.push("");
                const nOmit = nCommon - nContextLines2;
                aStart = aEnd + nOmit;
                bStart = bEnd + nOmit;
                aEnd = aStart;
                bEnd = bStart;
                for(let iCommon = i - nContextLines; iCommon !== i; iCommon += 1)pushCommonLine(diffs[iCommon][1]);
            } else for(let iCommon = iStart; iCommon !== i; iCommon += 1)pushCommonLine(diffs[iCommon][1]);
        }
        while(i !== iLength && diffs[i][0] === DIFF_DELETE){
            pushDeleteLine(diffs[i][1]);
            i += 1;
        }
        while(i !== iLength && diffs[i][0] === DIFF_INSERT){
            pushInsertLine(diffs[i][1]);
            i += 1;
        }
    }
    if (hasPatch) lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
    return lines.join("\n");
}
function joinAlignedDiffsExpand(diffs, options) {
    return diffs.map((diff, i, diffs)=>{
        const line = diff[1];
        const isFirstOrLast = 0 === i || i === diffs.length - 1;
        switch(diff[0]){
            case DIFF_DELETE:
                return printDeleteLine(line, isFirstOrLast, options);
            case DIFF_INSERT:
                return printInsertLine(line, isFirstOrLast, options);
            default:
                return printCommonLine(line, isFirstOrLast, options);
        }
    }).join("\n");
}
const noColor = (string)=>string;
const DIFF_CONTEXT_DEFAULT = 5;
const DIFF_TRUNCATE_THRESHOLD_DEFAULT = 0;
function getDefaultOptions() {
    return {
        aAnnotation: "Expected",
        aColor: node_u.green,
        aIndicator: "-",
        bAnnotation: "Received",
        bColor: node_u.red,
        bIndicator: "+",
        changeColor: node_u.inverse,
        changeLineTrailingSpaceColor: noColor,
        commonColor: node_u.dim,
        commonIndicator: " ",
        commonLineTrailingSpaceColor: noColor,
        compareKeys: void 0,
        contextLines: DIFF_CONTEXT_DEFAULT,
        emptyFirstOrLastLinePlaceholder: "",
        expand: false,
        includeChangeCounts: false,
        omitAnnotationLines: false,
        patchColor: node_u.yellow,
        printBasicPrototype: false,
        truncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT,
        truncateAnnotation: "... Diff result is truncated",
        truncateAnnotationColor: noColor
    };
}
function getCompareKeys(compareKeys) {
    return compareKeys && "function" == typeof compareKeys ? compareKeys : void 0;
}
function getContextLines(contextLines) {
    return "number" == typeof contextLines && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;
}
function normalizeDiffOptions(options = {}) {
    return {
        ...getDefaultOptions(),
        ...options,
        compareKeys: getCompareKeys(options.compareKeys),
        contextLines: getContextLines(options.contextLines)
    };
}
function isEmptyString(lines) {
    return 1 === lines.length && 0 === lines[0].length;
}
function countChanges(diffs) {
    let a = 0;
    let b = 0;
    diffs.forEach((diff)=>{
        switch(diff[0]){
            case DIFF_DELETE:
                a += 1;
                break;
            case DIFF_INSERT:
                b += 1;
                break;
        }
    });
    return {
        a,
        b
    };
}
function printAnnotation({ aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator, includeChangeCounts, omitAnnotationLines }, changeCounts) {
    if (omitAnnotationLines) return "";
    let aRest = "";
    let bRest = "";
    if (includeChangeCounts) {
        const aCount = String(changeCounts.a);
        const bCount = String(changeCounts.b);
        const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;
        const aAnnotationPadding = " ".repeat(Math.max(0, baAnnotationLengthDiff));
        const bAnnotationPadding = " ".repeat(Math.max(0, -baAnnotationLengthDiff));
        const baCountLengthDiff = bCount.length - aCount.length;
        const aCountPadding = " ".repeat(Math.max(0, baCountLengthDiff));
        const bCountPadding = " ".repeat(Math.max(0, -baCountLengthDiff));
        aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`;
        bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;
    }
    const a = `${aIndicator} ${aAnnotation}${aRest}`;
    const b = `${bIndicator} ${bAnnotation}${bRest}`;
    return `${aColor(a)}\n${bColor(b)}\n\n`;
}
function printDiffLines(diffs, truncated, options) {
    return printAnnotation(options, countChanges(diffs)) + (options.expand ? joinAlignedDiffsExpand(diffs, options) : joinAlignedDiffsNoExpand(diffs, options)) + (truncated ? options.truncateAnnotationColor(`\n${options.truncateAnnotation}`) : "");
}
function diffLinesUnified(aLines, bLines, options) {
    const normalizedOptions = normalizeDiffOptions(options);
    const [diffs, truncated] = diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines, normalizedOptions);
    return printDiffLines(diffs, truncated, normalizedOptions);
}
function diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) {
    if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {
        aLinesDisplay = [];
        aLinesCompare = [];
    }
    if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {
        bLinesDisplay = [];
        bLinesCompare = [];
    }
    if (aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length) return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);
    const [diffs, truncated] = diffLinesRaw(aLinesCompare, bLinesCompare, options);
    let aIndex = 0;
    let bIndex = 0;
    diffs.forEach((diff)=>{
        switch(diff[0]){
            case DIFF_DELETE:
                diff[1] = aLinesDisplay[aIndex];
                aIndex += 1;
                break;
            case DIFF_INSERT:
                diff[1] = bLinesDisplay[bIndex];
                bIndex += 1;
                break;
            default:
                diff[1] = bLinesDisplay[bIndex];
                aIndex += 1;
                bIndex += 1;
        }
    });
    return printDiffLines(diffs, truncated, normalizeDiffOptions(options));
}
function diffLinesRaw(aLines, bLines, options) {
    const truncate = (null == options ? void 0 : options.truncateThreshold) ?? false;
    const truncateThreshold = Math.max(Math.floor((null == options ? void 0 : options.truncateThreshold) ?? 0), 0);
    const aLength = truncate ? Math.min(aLines.length, truncateThreshold) : aLines.length;
    const bLength = truncate ? Math.min(bLines.length, truncateThreshold) : bLines.length;
    const truncated = aLength !== aLines.length || bLength !== bLines.length;
    const isCommon = (aIndex, bIndex)=>aLines[aIndex] === bLines[bIndex];
    const diffs = [];
    let aIndex = 0;
    let bIndex = 0;
    const foundSubsequence = (nCommon, aCommon, bCommon)=>{
        for(; aIndex !== aCommon; aIndex += 1)diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
        for(; bIndex !== bCommon; bIndex += 1)diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
        for(; 0 !== nCommon; nCommon -= 1, aIndex += 1, bIndex += 1)diffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));
    };
    diffSequences(aLength, bLength, isCommon, foundSubsequence);
    for(; aIndex !== aLength; aIndex += 1)diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
    for(; bIndex !== bLength; bIndex += 1)diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
    return [
        diffs,
        truncated
    ];
}
function diff_getType(value) {
    if (void 0 === value) return "undefined";
    if (null === value) return "null";
    if (Array.isArray(value)) return "array";
    if ("boolean" == typeof value) return "boolean";
    if ("function" == typeof value) return "function";
    else if ("number" == typeof value) return "number";
    else if ("string" == typeof value) return "string";
    else if ("bigint" == typeof value) return "bigint";
    else if ("object" == typeof value) {
        if (null != value) {
            if (value.constructor === RegExp) return "regexp";
            else if (value.constructor === Map) return "map";
            else if (value.constructor === Set) return "set";
            else if (value.constructor === Date) return "date";
        }
        return "object";
    } else if ("symbol" == typeof value) return "symbol";
    throw new Error(`value of unknown type: ${value}`);
}
function getNewLineSymbol(string) {
    return string.includes("\r\n") ? "\r\n" : "\n";
}
function diffStrings(a, b, options) {
    const truncate = (null == options ? void 0 : options.truncateThreshold) ?? false;
    const truncateThreshold = Math.max(Math.floor((null == options ? void 0 : options.truncateThreshold) ?? 0), 0);
    let aLength = a.length;
    let bLength = b.length;
    if (truncate) {
        const aMultipleLines = a.includes("\n");
        const bMultipleLines = b.includes("\n");
        const aNewLineSymbol = getNewLineSymbol(a);
        const bNewLineSymbol = getNewLineSymbol(b);
        const _a = aMultipleLines ? `${a.split(aNewLineSymbol, truncateThreshold).join(aNewLineSymbol)}\n` : a;
        const _b = bMultipleLines ? `${b.split(bNewLineSymbol, truncateThreshold).join(bNewLineSymbol)}\n` : b;
        aLength = _a.length;
        bLength = _b.length;
    }
    const truncated = aLength !== a.length || bLength !== b.length;
    const isCommon = (aIndex, bIndex)=>a[aIndex] === b[bIndex];
    let aIndex = 0;
    let bIndex = 0;
    const diffs = [];
    const foundSubsequence = (nCommon, aCommon, bCommon)=>{
        if (aIndex !== aCommon) diffs.push(new Diff(DIFF_DELETE, a.slice(aIndex, aCommon)));
        if (bIndex !== bCommon) diffs.push(new Diff(DIFF_INSERT, b.slice(bIndex, bCommon)));
        aIndex = aCommon + nCommon;
        bIndex = bCommon + nCommon;
        diffs.push(new Diff(DIFF_EQUAL, b.slice(bCommon, bIndex)));
    };
    diffSequences(aLength, bLength, isCommon, foundSubsequence);
    if (aIndex !== aLength) diffs.push(new Diff(DIFF_DELETE, a.slice(aIndex)));
    if (bIndex !== bLength) diffs.push(new Diff(DIFF_INSERT, b.slice(bIndex)));
    return [
        diffs,
        truncated
    ];
}
function concatenateRelevantDiffs(op, diffs, changeColor) {
    return diffs.reduce((reduced, diff)=>reduced + (diff[0] === DIFF_EQUAL ? diff[1] : diff[0] === op && 0 !== diff[1].length ? changeColor(diff[1]) : ""), "");
}
class ChangeBuffer {
    op;
    line;
    lines;
    changeColor;
    constructor(op, changeColor){
        this.op = op;
        this.line = [];
        this.lines = [];
        this.changeColor = changeColor;
    }
    pushSubstring(substring) {
        this.pushDiff(new Diff(this.op, substring));
    }
    pushLine() {
        this.lines.push(1 !== this.line.length ? new Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Diff(this.op, this.line[0][1]));
        this.line.length = 0;
    }
    isLineEmpty() {
        return 0 === this.line.length;
    }
    pushDiff(diff) {
        this.line.push(diff);
    }
    align(diff) {
        const string = diff[1];
        if (string.includes("\n")) {
            const substrings = string.split("\n");
            const iLast = substrings.length - 1;
            substrings.forEach((substring, i)=>{
                if (i < iLast) {
                    this.pushSubstring(substring);
                    this.pushLine();
                } else if (0 !== substring.length) this.pushSubstring(substring);
            });
        } else this.pushDiff(diff);
    }
    moveLinesTo(lines) {
        if (!this.isLineEmpty()) this.pushLine();
        lines.push(...this.lines);
        this.lines.length = 0;
    }
}
class CommonBuffer {
    deleteBuffer;
    insertBuffer;
    lines;
    constructor(deleteBuffer, insertBuffer){
        this.deleteBuffer = deleteBuffer;
        this.insertBuffer = insertBuffer;
        this.lines = [];
    }
    pushDiffCommonLine(diff) {
        this.lines.push(diff);
    }
    pushDiffChangeLines(diff) {
        const isDiffEmpty = 0 === diff[1].length;
        if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) this.deleteBuffer.pushDiff(diff);
        if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) this.insertBuffer.pushDiff(diff);
    }
    flushChangeLines() {
        this.deleteBuffer.moveLinesTo(this.lines);
        this.insertBuffer.moveLinesTo(this.lines);
    }
    align(diff) {
        const op = diff[0];
        const string = diff[1];
        if (string.includes("\n")) {
            const substrings = string.split("\n");
            const iLast = substrings.length - 1;
            substrings.forEach((substring, i)=>{
                if (0 === i) {
                    const subdiff = new Diff(op, substring);
                    if (this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()) {
                        this.flushChangeLines();
                        this.pushDiffCommonLine(subdiff);
                    } else {
                        this.pushDiffChangeLines(subdiff);
                        this.flushChangeLines();
                    }
                } else if (i < iLast) this.pushDiffCommonLine(new Diff(op, substring));
                else if (0 !== substring.length) this.pushDiffChangeLines(new Diff(op, substring));
            });
        } else this.pushDiffChangeLines(diff);
    }
    getLines() {
        this.flushChangeLines();
        return this.lines;
    }
}
function getAlignedDiffs(diffs, changeColor) {
    const deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor);
    const insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor);
    const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);
    diffs.forEach((diff)=>{
        switch(diff[0]){
            case DIFF_DELETE:
                deleteBuffer.align(diff);
                break;
            case DIFF_INSERT:
                insertBuffer.align(diff);
                break;
            default:
                commonBuffer.align(diff);
        }
    });
    return commonBuffer.getLines();
}
function diff_hasCommonDiff(diffs, isMultiline) {
    if (isMultiline) {
        const iLast = diffs.length - 1;
        return diffs.some((diff, i)=>diff[0] === DIFF_EQUAL && (i !== iLast || "\n" !== diff[1]));
    }
    return diffs.some((diff)=>diff[0] === DIFF_EQUAL);
}
function diffStringsUnified(a, b, options) {
    if (a !== b && 0 !== a.length && 0 !== b.length) {
        const isMultiline = a.includes("\n") || b.includes("\n");
        const [diffs, truncated] = diffStringsRaw(isMultiline ? `${a}\n` : a, isMultiline ? `${b}\n` : b, true, options);
        if (diff_hasCommonDiff(diffs, isMultiline)) {
            const optionsNormalized = normalizeDiffOptions(options);
            const lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);
            return printDiffLines(lines, truncated, optionsNormalized);
        }
    }
    return diffLinesUnified(a.split("\n"), b.split("\n"), options);
}
function diffStringsRaw(a, b, cleanup, options) {
    const [diffs, truncated] = diffStrings(a, b, options);
    if (cleanup) diff_cleanupSemantic(diffs);
    return [
        diffs,
        truncated
    ];
}
function getCommonMessage(message, options) {
    const { commonColor } = normalizeDiffOptions(options);
    return commonColor(message);
}
const { AsymmetricMatcher: diff_AsymmetricMatcher, DOMCollection: diff_DOMCollection, DOMElement: diff_DOMElement, Immutable: diff_Immutable, ReactElement: diff_ReactElement, ReactTestComponent: diff_ReactTestComponent } = dist_plugins;
const diff_PLUGINS = [
    diff_ReactTestComponent,
    diff_ReactElement,
    diff_DOMElement,
    diff_DOMCollection,
    diff_Immutable,
    diff_AsymmetricMatcher,
    dist_plugins.Error
];
const FORMAT_OPTIONS = {
    maxDepth: 20,
    plugins: diff_PLUGINS
};
const FALLBACK_FORMAT_OPTIONS = {
    callToJSON: false,
    maxDepth: 8,
    plugins: diff_PLUGINS
};
function diff_diff(a, b, options) {
    if (Object.is(a, b)) return "";
    const aType = diff_getType(a);
    let expectedType = aType;
    let omitDifference = false;
    if ("object" === aType && "function" == typeof a.asymmetricMatch) {
        if (a.$$typeof !== Symbol.for("jest.asymmetricMatcher")) return;
        if ("function" != typeof a.getExpectedType) return;
        expectedType = a.getExpectedType();
        omitDifference = "string" === expectedType;
    }
    if (expectedType !== diff_getType(b)) {
        const { aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator } = normalizeDiffOptions(options);
        const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
        let aDisplay = format(a, formatOptions);
        let bDisplay = format(b, formatOptions);
        const MAX_LENGTH = 1e5;
        function truncate(s) {
            return s.length <= MAX_LENGTH ? s : `${s.slice(0, MAX_LENGTH)}...`;
        }
        aDisplay = truncate(aDisplay);
        bDisplay = truncate(bDisplay);
        const aDiff = `${aColor(`${aIndicator} ${aAnnotation}:`)} \n${aDisplay}`;
        const bDiff = `${bColor(`${bIndicator} ${bAnnotation}:`)} \n${bDisplay}`;
        return `${aDiff}\n\n${bDiff}`;
    }
    if (omitDifference) return;
    switch(aType){
        case "string":
            return diffLinesUnified(a.split("\n"), b.split("\n"), options);
        case "boolean":
        case "number":
            return comparePrimitive(a, b, options);
        case "map":
            return compareObjects(sortMap(a), sortMap(b), options);
        case "set":
            return compareObjects(sortSet(a), sortSet(b), options);
        default:
            return compareObjects(a, b, options);
    }
}
function comparePrimitive(a, b, options) {
    const aFormat = format(a, FORMAT_OPTIONS);
    const bFormat = format(b, FORMAT_OPTIONS);
    return aFormat === bFormat ? "" : diffLinesUnified(aFormat.split("\n"), bFormat.split("\n"), options);
}
function sortMap(map) {
    return new Map(Array.from(map.entries()).sort());
}
function sortSet(set) {
    return new Set(Array.from(set.values()).sort());
}
function compareObjects(a, b, options) {
    let difference;
    let hasThrown = false;
    try {
        const formatOptions = getFormatOptions(FORMAT_OPTIONS, options);
        difference = getObjectsDifference(a, b, formatOptions, options);
    } catch  {
        hasThrown = true;
    }
    const noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options);
    if (void 0 === difference || difference === noDiffMessage) {
        const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
        difference = getObjectsDifference(a, b, formatOptions, options);
        if (difference !== noDiffMessage && !hasThrown) difference = `${getCommonMessage(SIMILAR_MESSAGE, options)}\n\n${difference}`;
    }
    return difference;
}
function getFormatOptions(formatOptions, options) {
    const { compareKeys, printBasicPrototype, maxDepth } = normalizeDiffOptions(options);
    return {
        ...formatOptions,
        compareKeys,
        printBasicPrototype,
        maxDepth: maxDepth ?? formatOptions.maxDepth
    };
}
function getObjectsDifference(a, b, formatOptions, options) {
    const formatOptionsZeroIndent = {
        ...formatOptions,
        indent: 0
    };
    const aCompare = format(a, formatOptionsZeroIndent);
    const bCompare = format(b, formatOptionsZeroIndent);
    if (aCompare === bCompare) return getCommonMessage(NO_DIFF_MESSAGE, options);
    {
        const aDisplay = format(a, formatOptions);
        const bDisplay = format(b, formatOptions);
        return diffLinesUnified2(aDisplay.split("\n"), bDisplay.split("\n"), aCompare.split("\n"), bCompare.split("\n"), options);
    }
}
const MAX_DIFF_STRING_LENGTH = 2e4;
function isAsymmetricMatcher(data) {
    const type = helpers_getType(data);
    return "Object" === type && "function" == typeof data.asymmetricMatch;
}
function isReplaceable(obj1, obj2) {
    const obj1Type = helpers_getType(obj1);
    const obj2Type = helpers_getType(obj2);
    return obj1Type === obj2Type && ("Object" === obj1Type || "Array" === obj1Type);
}
function printDiffOrStringify(received, expected, options) {
    const { aAnnotation, bAnnotation } = normalizeDiffOptions(options);
    if ("string" == typeof expected && "string" == typeof received && expected.length > 0 && received.length > 0 && expected.length <= MAX_DIFF_STRING_LENGTH && received.length <= MAX_DIFF_STRING_LENGTH && expected !== received) {
        if (expected.includes("\n") || received.includes("\n")) return diffStringsUnified(expected, received, options);
        const [diffs] = diffStringsRaw(expected, received, true);
        const hasCommonDiff = diffs.some((diff)=>diff[0] === DIFF_EQUAL);
        const printLabel = getLabelPrinter(aAnnotation, bAnnotation);
        const expectedLine = printLabel(aAnnotation) + diff_printExpected(getCommonAndChangedSubstrings(diffs, DIFF_DELETE, hasCommonDiff));
        const receivedLine = printLabel(bAnnotation) + diff_printReceived(getCommonAndChangedSubstrings(diffs, DIFF_INSERT, hasCommonDiff));
        return `${expectedLine}\n${receivedLine}`;
    }
    const clonedExpected = deepClone(expected, {
        forceWritable: true
    });
    const clonedReceived = deepClone(received, {
        forceWritable: true
    });
    const { replacedExpected, replacedActual } = replaceAsymmetricMatcher(clonedReceived, clonedExpected);
    const difference = diff_diff(replacedExpected, replacedActual, options);
    return difference;
}
function replaceAsymmetricMatcher(actual, expected, actualReplaced = new WeakSet(), expectedReplaced = new WeakSet()) {
    if (actual instanceof Error && expected instanceof Error && void 0 !== actual.cause && void 0 === expected.cause) {
        delete actual.cause;
        return {
            replacedActual: actual,
            replacedExpected: expected
        };
    }
    if (!isReplaceable(actual, expected)) return {
        replacedActual: actual,
        replacedExpected: expected
    };
    if (actualReplaced.has(actual) || expectedReplaced.has(expected)) return {
        replacedActual: actual,
        replacedExpected: expected
    };
    actualReplaced.add(actual);
    expectedReplaced.add(expected);
    getOwnProperties(expected).forEach((key)=>{
        const expectedValue = expected[key];
        const actualValue = actual[key];
        if (isAsymmetricMatcher(expectedValue)) {
            if (expectedValue.asymmetricMatch(actualValue)) actual[key] = expectedValue;
        } else if (isAsymmetricMatcher(actualValue)) {
            if (actualValue.asymmetricMatch(expectedValue)) expected[key] = actualValue;
        } else if (isReplaceable(actualValue, expectedValue)) {
            const replaced = replaceAsymmetricMatcher(actualValue, expectedValue, actualReplaced, expectedReplaced);
            actual[key] = replaced.replacedActual;
            expected[key] = replaced.replacedExpected;
        }
    });
    return {
        replacedActual: actual,
        replacedExpected: expected
    };
}
function getLabelPrinter(...strings) {
    const maxLength = strings.reduce((max, string)=>string.length > max ? string.length : max, 0);
    return (string)=>`${string}: ${" ".repeat(maxLength - string.length)}`;
}
const SPACE_SYMBOL = "";
function replaceTrailingSpaces(text) {
    return text.replace(/\s+$/gm, (spaces)=>SPACE_SYMBOL.repeat(spaces.length));
}
function diff_printReceived(object) {
    return node_u.red(replaceTrailingSpaces(stringify(object)));
}
function diff_printExpected(value) {
    return node_u.green(replaceTrailingSpaces(stringify(value)));
}
function getCommonAndChangedSubstrings(diffs, op, hasCommonDiff) {
    return diffs.reduce((reduced, diff)=>reduced + (diff[0] === DIFF_EQUAL ? diff[1] : diff[0] === op ? hasCommonDiff ? node_u.inverse(diff[1]) : diff[1] : ""), "");
}
function S(e, t) {
    if (!e) throw new Error(t);
}
function dist_f(e, t) {
    return typeof t === e;
}
function w(e) {
    return e instanceof Promise;
}
function dist_u(e, t, r) {
    Object.defineProperty(e, t, r);
}
function dist_l(e, t, r) {
    dist_u(e, t, {
        value: r,
        configurable: !0,
        writable: !0
    });
}
var dist_y = Symbol.for("tinyspy:spy");
var dist_x = /* @__PURE__ */ new Set(), dist_h = (e)=>{
    e.called = !1, e.callCount = 0, e.calls = [], e.results = [], e.resolves = [], e.next = [];
}, dist_k = (e)=>(dist_u(e, dist_y, {
        value: {
            reset: ()=>dist_h(e[dist_y])
        }
    }), e[dist_y]), T = (e)=>e[dist_y] || dist_k(e);
function R(e) {
    S(dist_f("function", e) || dist_f("undefined", e), "cannot spy on a non-function value");
    let t = function(...s) {
        let n = T(t);
        n.called = !0, n.callCount++, n.calls.push(s);
        let d = n.next.shift();
        if (d) {
            n.results.push(d);
            let [a, i] = d;
            if ("ok" === a) return i;
            throw i;
        }
        let o, c = "ok", p = n.results.length;
        if (n.impl) try {
            new.target ? o = Reflect.construct(n.impl, s, new.target) : o = n.impl.apply(this, s), c = "ok";
        } catch (a) {
            throw o = a, c = "error", n.results.push([
                c,
                a
            ]), a;
        }
        let g = [
            c,
            o
        ];
        return w(o) && o.then((a)=>n.resolves[p] = [
                "ok",
                a
            ], (a)=>n.resolves[p] = [
                "error",
                a
            ]), n.results.push(g), o;
    };
    dist_l(t, "_isMockFunction", !0), dist_l(t, "length", e ? e.length : 0), dist_l(t, "name", e && e.name || "spy");
    let r = T(t);
    return r.reset(), r.impl = e, t;
}
function dist_v(e) {
    return !!e && !0 === e._isMockFunction;
}
var dist_b = (e, t)=>{
    let r = Object.getOwnPropertyDescriptor(e, t);
    if (r) return [
        e,
        r
    ];
    let s = Object.getPrototypeOf(e);
    for(; null !== s;){
        let n = Object.getOwnPropertyDescriptor(s, t);
        if (n) return [
            s,
            n
        ];
        s = Object.getPrototypeOf(s);
    }
}, P = (e, t)=>{
    null != t && "function" == typeof t && null != t.prototype && Object.setPrototypeOf(e.prototype, t.prototype);
};
function M(e, t, r) {
    S(!dist_f("undefined", e), "spyOn could not find an object to spy upon"), S(dist_f("object", e) || dist_f("function", e), "cannot spyOn on a primitive value");
    let [s, n] = (()=>{
        if (!dist_f("object", t)) return [
            t,
            "value"
        ];
        if ("getter" in t && "setter" in t) throw new Error("cannot spy on both getter and setter");
        if ("getter" in t) return [
            t.getter,
            "get"
        ];
        if ("setter" in t) return [
            t.setter,
            "set"
        ];
        throw new Error("specify getter or setter to spy on");
    })(), [d, o] = dist_b(e, s) || [];
    S(o || s in e, `${String(s)} does not exist`);
    let c = !1;
    "value" === n && o && !o.value && o.get && (n = "get", c = !0, r = o.get());
    let p;
    o ? p = o[n] : "value" !== n ? p = ()=>e[s] : p = e[s], p && dist_j(p) && (p = p[dist_y].getOriginal());
    let g = (I)=>{
        let { value: F, ...O } = o || {
            configurable: !0,
            writable: !0
        };
        "value" !== n && delete O.writable, O[n] = I, dist_u(e, s, O);
    }, a = ()=>{
        d !== e ? Reflect.deleteProperty(e, s) : o && !p ? dist_u(e, s, o) : g(p);
    };
    r || (r = p);
    let i = E(R(r), r);
    "value" === n && P(i, p);
    let m = i[dist_y];
    return dist_l(m, "restore", a), dist_l(m, "getOriginal", ()=>c ? p() : p), dist_l(m, "willCall", (I)=>(m.impl = I, i)), g(c ? ()=>(P(i, r), i) : i), dist_x.add(i), i;
}
var K = /* @__PURE__ */ new Set([
    "length",
    "name",
    "prototype"
]);
function D(e) {
    let t = /* @__PURE__ */ new Set(), r = {};
    for(; e && e !== Object.prototype && e !== Function.prototype;){
        let s = [
            ...Object.getOwnPropertyNames(e),
            ...Object.getOwnPropertySymbols(e)
        ];
        for (let n of s)r[n] || K.has(n) || (t.add(n), r[n] = Object.getOwnPropertyDescriptor(e, n));
        e = Object.getPrototypeOf(e);
    }
    return {
        properties: t,
        descriptors: r
    };
}
function E(e, t) {
    if (!t || dist_y in t) return e;
    let { properties: r, descriptors: s } = D(t);
    for (let n of r){
        let d = s[n];
        dist_b(e, n) || dist_u(e, n, d);
    }
    return e;
}
function dist_j(e) {
    return dist_v(e) && "getOriginal" in e[dist_y];
}
new Set();
function isMockFunction(fn) {
    return "function" == typeof fn && "_isMockFunction" in fn && fn._isMockFunction;
}
const IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
const IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
function isImmutable(v) {
    return v && (v[IS_COLLECTION_SYMBOL] || v[IS_RECORD_SYMBOL]);
}
const OBJECT_PROTO = Object.getPrototypeOf({});
function getUnserializableMessage(err) {
    if (err instanceof Error) return `<unserializable>: ${err.message}`;
    if ("string" == typeof err) return `<unserializable>: ${err}`;
    return "<unserializable>";
}
function serializeValue(val, seen = new WeakMap()) {
    if (!val || "string" == typeof val) return val;
    if (val instanceof Error && "toJSON" in val && "function" == typeof val.toJSON) {
        const jsonValue = val.toJSON();
        if (jsonValue && jsonValue !== val && "object" == typeof jsonValue) {
            if ("string" == typeof val.message) safe(()=>jsonValue.message ?? (jsonValue.message = val.message));
            if ("string" == typeof val.stack) safe(()=>jsonValue.stack ?? (jsonValue.stack = val.stack));
            if ("string" == typeof val.name) safe(()=>jsonValue.name ?? (jsonValue.name = val.name));
            if (null != val.cause) safe(()=>jsonValue.cause ?? (jsonValue.cause = serializeValue(val.cause, seen)));
        }
        return serializeValue(jsonValue, seen);
    }
    if ("function" == typeof val) return `Function<${val.name || "anonymous"}>`;
    if ("symbol" == typeof val) return val.toString();
    if ("object" != typeof val) return val;
    if ("undefined" != typeof Buffer && val instanceof Buffer) return `<Buffer(${val.length}) ...>`;
    if ("undefined" != typeof Uint8Array && val instanceof Uint8Array) return `<Uint8Array(${val.length}) ...>`;
    if (isImmutable(val)) return serializeValue(val.toJSON(), seen);
    if (val instanceof Promise || val.constructor && "AsyncFunction" === val.constructor.prototype) return "Promise";
    if ("undefined" != typeof Element && val instanceof Element) return val.tagName;
    if ("function" == typeof val.asymmetricMatch) return `${val.toString()} ${chunk_commonjsHelpers_format(val.sample)}`;
    if ("function" == typeof val.toJSON) return serializeValue(val.toJSON(), seen);
    if (seen.has(val)) return seen.get(val);
    if (Array.isArray(val)) {
        const clone = new Array(val.length);
        seen.set(val, clone);
        val.forEach((e, i)=>{
            try {
                clone[i] = serializeValue(e, seen);
            } catch (err) {
                clone[i] = getUnserializableMessage(err);
            }
        });
        return clone;
    }
    {
        const clone = Object.create(null);
        seen.set(val, clone);
        let obj = val;
        while(obj && obj !== OBJECT_PROTO){
            Object.getOwnPropertyNames(obj).forEach((key)=>{
                if (key in clone) return;
                try {
                    clone[key] = serializeValue(val[key], seen);
                } catch (err) {
                    delete clone[key];
                    clone[key] = getUnserializableMessage(err);
                }
            });
            obj = Object.getPrototypeOf(obj);
        }
        return clone;
    }
}
function safe(fn) {
    try {
        return fn();
    } catch  {}
}
function normalizeErrorMessage(message) {
    return message.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
}
function processError(_err, diffOptions, seen = new WeakSet()) {
    if (!_err || "object" != typeof _err) return {
        message: String(_err)
    };
    const err = _err;
    if (err.showDiff || void 0 === err.showDiff && void 0 !== err.expected && void 0 !== err.actual) err.diff = printDiffOrStringify(err.actual, err.expected, {
        ...diffOptions,
        ...err.diffOptions
    });
    if ("expected" in err && "string" != typeof err.expected) err.expected = stringify(err.expected, 10);
    if ("actual" in err && "string" != typeof err.actual) err.actual = stringify(err.actual, 10);
    try {
        if ("string" == typeof err.message) err.message = normalizeErrorMessage(err.message);
    } catch  {}
    try {
        if (!seen.has(err) && "object" == typeof err.cause) {
            seen.add(err);
            err.cause = processError(err.cause, diffOptions, seen);
        }
    } catch  {}
    try {
        return serializeValue(err);
    } catch (e) {
        return serializeValue(new Error(`Failed to fully serialize error: ${null == e ? void 0 : e.message}\nInner error message: ${null == err ? void 0 : err.message}`));
    }
}
var __defProp = Object.defineProperty;
var __name = (target, value)=>__defProp(target, "name", {
        value,
        configurable: true
    });
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var utils_exports = {};
__export(utils_exports, {
    addChainableMethod: ()=>addChainableMethod,
    addLengthGuard: ()=>addLengthGuard,
    addMethod: ()=>chai_addMethod,
    addProperty: ()=>addProperty,
    checkError: ()=>check_error_exports,
    compareByInspect: ()=>compareByInspect,
    eql: ()=>deep_eql_default,
    expectTypes: ()=>expectTypes,
    flag: ()=>flag,
    getActual: ()=>getActual,
    getMessage: ()=>getMessage2,
    getName: ()=>getName,
    getOperator: ()=>getOperator,
    getOwnEnumerableProperties: ()=>getOwnEnumerableProperties,
    getOwnEnumerablePropertySymbols: ()=>getOwnEnumerablePropertySymbols,
    getPathInfo: ()=>getPathInfo,
    hasProperty: ()=>hasProperty,
    inspect: ()=>inspect2,
    isNaN: ()=>isNaN2,
    isNumeric: ()=>isNumeric,
    isProxyEnabled: ()=>isProxyEnabled,
    isRegExp: ()=>isRegExp2,
    objDisplay: ()=>chai_objDisplay,
    overwriteChainableMethod: ()=>overwriteChainableMethod,
    overwriteMethod: ()=>overwriteMethod,
    overwriteProperty: ()=>overwriteProperty,
    proxify: ()=>proxify,
    test: ()=>chai_test,
    transferFlags: ()=>transferFlags,
    type: ()=>chai_type
});
var check_error_exports = {};
__export(check_error_exports, {
    compatibleConstructor: ()=>compatibleConstructor,
    compatibleInstance: ()=>compatibleInstance,
    compatibleMessage: ()=>compatibleMessage,
    getConstructorName: ()=>chai_getConstructorName,
    getMessage: ()=>getMessage
});
function isErrorInstance(obj) {
    return obj instanceof Error || "[object Error]" === Object.prototype.toString.call(obj);
}
__name(isErrorInstance, "isErrorInstance");
function isRegExp(obj) {
    return "[object RegExp]" === Object.prototype.toString.call(obj);
}
__name(isRegExp, "isRegExp");
function compatibleInstance(thrown, errorLike) {
    return isErrorInstance(errorLike) && thrown === errorLike;
}
__name(compatibleInstance, "compatibleInstance");
function compatibleConstructor(thrown, errorLike) {
    if (isErrorInstance(errorLike)) return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
    if (("object" == typeof errorLike || "function" == typeof errorLike) && errorLike.prototype) return thrown.constructor === errorLike || thrown instanceof errorLike;
    return false;
}
__name(compatibleConstructor, "compatibleConstructor");
function compatibleMessage(thrown, errMatcher) {
    const comparisonString = "string" == typeof thrown ? thrown : thrown.message;
    if (isRegExp(errMatcher)) return errMatcher.test(comparisonString);
    if ("string" == typeof errMatcher) return -1 !== comparisonString.indexOf(errMatcher);
    return false;
}
__name(compatibleMessage, "compatibleMessage");
function chai_getConstructorName(errorLike) {
    let constructorName = errorLike;
    if (isErrorInstance(errorLike)) constructorName = errorLike.constructor.name;
    else if ("function" == typeof errorLike) {
        constructorName = errorLike.name;
        if ("" === constructorName) {
            const newConstructorName = new errorLike().name;
            constructorName = newConstructorName || constructorName;
        }
    }
    return constructorName;
}
__name(chai_getConstructorName, "getConstructorName");
function getMessage(errorLike) {
    let msg = "";
    if (errorLike && errorLike.message) msg = errorLike.message;
    else if ("string" == typeof errorLike) msg = errorLike;
    return msg;
}
__name(getMessage, "getMessage");
function flag(obj, key, value) {
    let flags = obj.__flags || (obj.__flags = /* @__PURE__ */ Object.create(null));
    if (3 !== arguments.length) return flags[key];
    flags[key] = value;
}
__name(flag, "flag");
function chai_test(obj, args) {
    let negate = flag(obj, "negate"), expr = args[0];
    return negate ? !expr : expr;
}
__name(chai_test, "test");
function chai_type(obj) {
    if (void 0 === obj) return "undefined";
    if (null === obj) return "null";
    const stringTag = obj[Symbol.toStringTag];
    if ("string" == typeof stringTag) return stringTag;
    const type3 = Object.prototype.toString.call(obj).slice(8, -1);
    return type3;
}
__name(chai_type, "type");
var canElideFrames = "captureStackTrace" in Error;
var chai_AssertionError = class _AssertionError extends Error {
    static{
        __name(this, "AssertionError");
    }
    message;
    get name() {
        return "AssertionError";
    }
    get ok() {
        return false;
    }
    constructor(message = "Unspecified AssertionError", props, ssf){
        super(message);
        this.message = message;
        if (canElideFrames) Error.captureStackTrace(this, ssf || _AssertionError);
        for(const key in props)if (!(key in this)) this[key] = props[key];
    }
    toJSON(stack) {
        return {
            ...this,
            name: this.name,
            message: this.message,
            ok: false,
            stack: false !== stack ? this.stack : void 0
        };
    }
};
function expectTypes(obj, types) {
    let flagMsg = flag(obj, "message");
    let ssfi = flag(obj, "ssfi");
    flagMsg = flagMsg ? flagMsg + ": " : "";
    obj = flag(obj, "object");
    types = types.map(function(t) {
        return t.toLowerCase();
    });
    types.sort();
    let str = types.map(function(t, index) {
        let art = ~[
            "a",
            "e",
            "i",
            "o",
            "u"
        ].indexOf(t.charAt(0)) ? "an" : "a";
        let or = types.length > 1 && index === types.length - 1 ? "or " : "";
        return or + art + " " + t;
    }).join(", ");
    let objType = chai_type(obj).toLowerCase();
    if (!types.some(function(expected) {
        return objType === expected;
    })) throw new chai_AssertionError(flagMsg + "object tested must be " + str + ", but " + objType + " given", void 0, ssfi);
}
__name(expectTypes, "expectTypes");
function getActual(obj, args) {
    return args.length > 4 ? args[4] : obj._obj;
}
__name(getActual, "getActual");
var chai_ansiColors = {
    bold: [
        "1",
        "22"
    ],
    dim: [
        "2",
        "22"
    ],
    italic: [
        "3",
        "23"
    ],
    underline: [
        "4",
        "24"
    ],
    inverse: [
        "7",
        "27"
    ],
    hidden: [
        "8",
        "28"
    ],
    strike: [
        "9",
        "29"
    ],
    black: [
        "30",
        "39"
    ],
    red: [
        "31",
        "39"
    ],
    green: [
        "32",
        "39"
    ],
    yellow: [
        "33",
        "39"
    ],
    blue: [
        "34",
        "39"
    ],
    magenta: [
        "35",
        "39"
    ],
    cyan: [
        "36",
        "39"
    ],
    white: [
        "37",
        "39"
    ],
    brightblack: [
        "30;1",
        "39"
    ],
    brightred: [
        "31;1",
        "39"
    ],
    brightgreen: [
        "32;1",
        "39"
    ],
    brightyellow: [
        "33;1",
        "39"
    ],
    brightblue: [
        "34;1",
        "39"
    ],
    brightmagenta: [
        "35;1",
        "39"
    ],
    brightcyan: [
        "36;1",
        "39"
    ],
    brightwhite: [
        "37;1",
        "39"
    ],
    grey: [
        "90",
        "39"
    ]
};
var chai_styles = {
    special: "cyan",
    number: "yellow",
    bigint: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    symbol: "green",
    date: "magenta",
    regexp: "red"
};
var chai_truncator = "\u2026";
function chai_colorise(value, styleType) {
    const color = chai_ansiColors[chai_styles[styleType]] || chai_ansiColors[styleType] || "";
    if (!color) return String(value);
    return `\x1B[${color[0]}m${String(value)}\x1B[${color[1]}m`;
}
__name(chai_colorise, "colorise");
function chai_normaliseOptions({ showHidden = false, depth = 2, colors = false, customInspect = true, showProxy = false, maxArrayLength = 1 / 0, breakLength = 1 / 0, seen = [], truncate: truncate2 = 1 / 0, stylize = String } = {}, inspect3) {
    const options = {
        showHidden: Boolean(showHidden),
        depth: Number(depth),
        colors: Boolean(colors),
        customInspect: Boolean(customInspect),
        showProxy: Boolean(showProxy),
        maxArrayLength: Number(maxArrayLength),
        breakLength: Number(breakLength),
        truncate: Number(truncate2),
        seen,
        inspect: inspect3,
        stylize
    };
    if (options.colors) options.stylize = chai_colorise;
    return options;
}
__name(chai_normaliseOptions, "normaliseOptions");
function chai_isHighSurrogate(char) {
    return char >= "\uD800" && char <= "\uDBFF";
}
__name(chai_isHighSurrogate, "isHighSurrogate");
function chai_truncate(string, length, tail = chai_truncator) {
    string = String(string);
    const tailLength = tail.length;
    const stringLength = string.length;
    if (tailLength > length && stringLength > tailLength) return tail;
    if (stringLength > length && stringLength > tailLength) {
        let end = length - tailLength;
        if (end > 0 && chai_isHighSurrogate(string[end - 1])) end -= 1;
        return `${string.slice(0, end)}${tail}`;
    }
    return string;
}
__name(chai_truncate, "truncate");
function chai_inspectList(list, options, inspectItem, separator = ", ") {
    inspectItem = inspectItem || options.inspect;
    const size = list.length;
    if (0 === size) return "";
    const originalLength = options.truncate;
    let output = "";
    let peek = "";
    let truncated = "";
    for(let i = 0; i < size; i += 1){
        const last = i + 1 === list.length;
        const secondToLast = i + 2 === list.length;
        truncated = `${chai_truncator}(${list.length - i})`;
        const value = list[i];
        options.truncate = originalLength - output.length - (last ? 0 : separator.length);
        const string = peek || inspectItem(value, options) + (last ? "" : separator);
        const nextLength = output.length + string.length;
        const truncatedLength = nextLength + truncated.length;
        if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) break;
        if (!last && !secondToLast && truncatedLength > originalLength) break;
        peek = last ? "" : inspectItem(list[i + 1], options) + (secondToLast ? "" : separator);
        if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) break;
        output += string;
        if (!last && !secondToLast && nextLength + peek.length >= originalLength) {
            truncated = `${chai_truncator}(${list.length - i - 1})`;
            break;
        }
        truncated = "";
    }
    return `${output}${truncated}`;
}
__name(chai_inspectList, "inspectList");
function chai_quoteComplexKey(key) {
    if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) return key;
    return JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
__name(chai_quoteComplexKey, "quoteComplexKey");
function chai_inspectProperty([key, value], options) {
    options.truncate -= 2;
    if ("string" == typeof key) key = chai_quoteComplexKey(key);
    else if ("number" != typeof key) key = `[${options.inspect(key, options)}]`;
    options.truncate -= key.length;
    value = options.inspect(value, options);
    return `${key}: ${value}`;
}
__name(chai_inspectProperty, "inspectProperty");
function chai_inspectArray(array, options) {
    const nonIndexProperties = Object.keys(array).slice(array.length);
    if (!array.length && !nonIndexProperties.length) return "[]";
    options.truncate -= 4;
    const listContents = chai_inspectList(array, options);
    options.truncate -= listContents.length;
    let propertyContents = "";
    if (nonIndexProperties.length) propertyContents = chai_inspectList(nonIndexProperties.map((key)=>[
            key,
            array[key]
        ]), options, chai_inspectProperty);
    return `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(chai_inspectArray, "inspectArray");
var chai_getArrayName = /* @__PURE__ */ __name((array)=>{
    if ("function" == typeof Buffer && array instanceof Buffer) return "Buffer";
    if (array[Symbol.toStringTag]) return array[Symbol.toStringTag];
    return array.constructor.name;
}, "getArrayName");
function chai_inspectTypedArray(array, options) {
    const name = chai_getArrayName(array);
    options.truncate -= name.length + 4;
    const nonIndexProperties = Object.keys(array).slice(array.length);
    if (!array.length && !nonIndexProperties.length) return `${name}[]`;
    let output = "";
    for(let i = 0; i < array.length; i++){
        const string = `${options.stylize(chai_truncate(array[i], options.truncate), "number")}${i === array.length - 1 ? "" : ", "}`;
        options.truncate -= string.length;
        if (array[i] !== array.length && options.truncate <= 3) {
            output += `${chai_truncator}(${array.length - array[i] + 1})`;
            break;
        }
        output += string;
    }
    let propertyContents = "";
    if (nonIndexProperties.length) propertyContents = chai_inspectList(nonIndexProperties.map((key)=>[
            key,
            array[key]
        ]), options, chai_inspectProperty);
    return `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(chai_inspectTypedArray, "inspectTypedArray");
function chai_inspectDate(dateObject, options) {
    const stringRepresentation = dateObject.toJSON();
    if (null === stringRepresentation) return "Invalid Date";
    const split = stringRepresentation.split("T");
    const date = split[0];
    return options.stylize(`${date}T${chai_truncate(split[1], options.truncate - date.length - 1)}`, "date");
}
__name(chai_inspectDate, "inspectDate");
function chai_inspectFunction(func, options) {
    const functionType = func[Symbol.toStringTag] || "Function";
    const name = func.name;
    if (!name) return options.stylize(`[${functionType}]`, "special");
    return options.stylize(`[${functionType} ${chai_truncate(name, options.truncate - 11)}]`, "special");
}
__name(chai_inspectFunction, "inspectFunction");
function chai_inspectMapEntry([key, value], options) {
    options.truncate -= 4;
    key = options.inspect(key, options);
    options.truncate -= key.length;
    value = options.inspect(value, options);
    return `${key} => ${value}`;
}
__name(chai_inspectMapEntry, "inspectMapEntry");
function chai_mapToEntries(map) {
    const entries = [];
    map.forEach((value, key)=>{
        entries.push([
            key,
            value
        ]);
    });
    return entries;
}
__name(chai_mapToEntries, "mapToEntries");
function chai_inspectMap(map, options) {
    if (0 === map.size) return "Map{}";
    options.truncate -= 7;
    return `Map{ ${chai_inspectList(chai_mapToEntries(map), options, chai_inspectMapEntry)} }`;
}
__name(chai_inspectMap, "inspectMap");
var chai_isNaN = Number.isNaN || ((i)=>i !== i);
function chai_inspectNumber(number, options) {
    if (chai_isNaN(number)) return options.stylize("NaN", "number");
    if (number === 1 / 0) return options.stylize("Infinity", "number");
    if (number === -1 / 0) return options.stylize("-Infinity", "number");
    if (0 === number) return options.stylize(1 / number === 1 / 0 ? "+0" : "-0", "number");
    return options.stylize(chai_truncate(String(number), options.truncate), "number");
}
__name(chai_inspectNumber, "inspectNumber");
function chai_inspectBigInt(number, options) {
    let nums = chai_truncate(number.toString(), options.truncate - 1);
    if (nums !== chai_truncator) nums += "n";
    return options.stylize(nums, "bigint");
}
__name(chai_inspectBigInt, "inspectBigInt");
function chai_inspectRegExp(value, options) {
    const flags = value.toString().split("/")[2];
    const sourceLength = options.truncate - (2 + flags.length);
    const source = value.source;
    return options.stylize(`/${chai_truncate(source, sourceLength)}/${flags}`, "regexp");
}
__name(chai_inspectRegExp, "inspectRegExp");
function chai_arrayFromSet(set2) {
    const values = [];
    set2.forEach((value)=>{
        values.push(value);
    });
    return values;
}
__name(chai_arrayFromSet, "arrayFromSet");
function chai_inspectSet(set2, options) {
    if (0 === set2.size) return "Set{}";
    options.truncate -= 7;
    return `Set{ ${chai_inspectList(chai_arrayFromSet(set2), options)} }`;
}
__name(chai_inspectSet, "inspectSet");
var chai_stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g");
var chai_escapeCharacters = {
    "\b": "\\b",
    "	": "\\t",
    "\n": "\\n",
    "\f": "\\f",
    "\r": "\\r",
    "'": "\\'",
    "\\": "\\\\"
};
var chai_hex = 16;
var chai_unicodeLength = 4;
function chai_escape(char) {
    return chai_escapeCharacters[char] || `\\u${`0000${char.charCodeAt(0).toString(chai_hex)}`.slice(-chai_unicodeLength)}`;
}
__name(chai_escape, "escape");
function chai_inspectString(string, options) {
    if (chai_stringEscapeChars.test(string)) string = string.replace(chai_stringEscapeChars, chai_escape);
    return options.stylize(`'${chai_truncate(string, options.truncate - 2)}'`, "string");
}
__name(chai_inspectString, "inspectString");
function chai_inspectSymbol(value) {
    if ("description" in Symbol.prototype) return value.description ? `Symbol(${value.description})` : "Symbol()";
    return value.toString();
}
__name(chai_inspectSymbol, "inspectSymbol");
var chai_getPromiseValue = /* @__PURE__ */ __name(()=>"Promise{\u2026}", "getPromiseValue");
var promise_default = chai_getPromiseValue;
function chai_inspectObject(object, options) {
    const properties = Object.getOwnPropertyNames(object);
    const symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];
    if (0 === properties.length && 0 === symbols.length) return "{}";
    options.truncate -= 4;
    options.seen = options.seen || [];
    if (options.seen.includes(object)) return "[Circular]";
    options.seen.push(object);
    const propertyContents = chai_inspectList(properties.map((key)=>[
            key,
            object[key]
        ]), options, chai_inspectProperty);
    const symbolContents = chai_inspectList(symbols.map((key)=>[
            key,
            object[key]
        ]), options, chai_inspectProperty);
    options.seen.pop();
    let sep = "";
    if (propertyContents && symbolContents) sep = ", ";
    return `{ ${propertyContents}${sep}${symbolContents} }`;
}
__name(chai_inspectObject, "inspectObject");
var chai_toStringTag = "undefined" != typeof Symbol && Symbol.toStringTag ? Symbol.toStringTag : false;
function chai_inspectClass(value, options) {
    let name = "";
    if (chai_toStringTag && chai_toStringTag in value) name = value[chai_toStringTag];
    name = name || value.constructor.name;
    if (!name || "_class" === name) name = "<Anonymous Class>";
    options.truncate -= name.length;
    return `${name}${chai_inspectObject(value, options)}`;
}
__name(chai_inspectClass, "inspectClass");
function chai_inspectArguments(args, options) {
    if (0 === args.length) return "Arguments[]";
    options.truncate -= 13;
    return `Arguments[ ${chai_inspectList(args, options)} ]`;
}
__name(chai_inspectArguments, "inspectArguments");
var chai_errorKeys = [
    "stack",
    "line",
    "column",
    "name",
    "message",
    "fileName",
    "lineNumber",
    "columnNumber",
    "number",
    "description",
    "cause"
];
function inspectObject2(error, options) {
    const properties = Object.getOwnPropertyNames(error).filter((key)=>-1 === chai_errorKeys.indexOf(key));
    const name = error.name;
    options.truncate -= name.length;
    let message = "";
    if ("string" == typeof error.message) message = chai_truncate(error.message, options.truncate);
    else properties.unshift("message");
    message = message ? `: ${message}` : "";
    options.truncate -= message.length + 5;
    options.seen = options.seen || [];
    if (options.seen.includes(error)) return "[Circular]";
    options.seen.push(error);
    const propertyContents = chai_inspectList(properties.map((key)=>[
            key,
            error[key]
        ]), options, chai_inspectProperty);
    return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
}
__name(inspectObject2, "inspectObject");
function chai_inspectAttribute([key, value], options) {
    options.truncate -= 3;
    if (!value) return `${options.stylize(String(key), "yellow")}`;
    return `${options.stylize(String(key), "yellow")}=${options.stylize(`"${value}"`, "string")}`;
}
__name(chai_inspectAttribute, "inspectAttribute");
function chai_inspectNodeCollection(collection, options) {
    return chai_inspectList(collection, options, chai_inspectNode, "\n");
}
__name(chai_inspectNodeCollection, "inspectNodeCollection");
function chai_inspectNode(node, options) {
    switch(node.nodeType){
        case 1:
            return chai_inspectHTML(node, options);
        case 3:
            return options.inspect(node.data, options);
        default:
            return options.inspect(node, options);
    }
}
__name(chai_inspectNode, "inspectNode");
function chai_inspectHTML(element, options) {
    const properties = element.getAttributeNames();
    const name = element.tagName.toLowerCase();
    const head = options.stylize(`<${name}`, "special");
    const headClose = options.stylize(">", "special");
    const tail = options.stylize(`</${name}>`, "special");
    options.truncate -= 2 * name.length + 5;
    let propertyContents = "";
    if (properties.length > 0) {
        propertyContents += " ";
        propertyContents += chai_inspectList(properties.map((key)=>[
                key,
                element.getAttribute(key)
            ]), options, chai_inspectAttribute, " ");
    }
    options.truncate -= propertyContents.length;
    const truncate2 = options.truncate;
    let children = chai_inspectNodeCollection(element.children, options);
    if (children && children.length > truncate2) children = `${chai_truncator}(${element.children.length})`;
    return `${head}${propertyContents}${headClose}${children}${tail}`;
}
__name(chai_inspectHTML, "inspectHTML");
var chai_symbolsSupported = "function" == typeof Symbol && "function" == typeof Symbol.for;
var chai_chaiInspect = chai_symbolsSupported ? Symbol.for("chai/inspect") : "@@chai/inspect";
var chai_nodeInspect = Symbol.for("nodejs.util.inspect.custom");
var chai_constructorMap = /* @__PURE__ */ new WeakMap();
var chai_stringTagMap = {};
var chai_baseTypesMap = {
    undefined: /* @__PURE__ */ __name((value, options)=>options.stylize("undefined", "undefined"), "undefined"),
    null: /* @__PURE__ */ __name((value, options)=>options.stylize("null", "null"), "null"),
    boolean: /* @__PURE__ */ __name((value, options)=>options.stylize(String(value), "boolean"), "boolean"),
    Boolean: /* @__PURE__ */ __name((value, options)=>options.stylize(String(value), "boolean"), "Boolean"),
    number: chai_inspectNumber,
    Number: chai_inspectNumber,
    bigint: chai_inspectBigInt,
    BigInt: chai_inspectBigInt,
    string: chai_inspectString,
    String: chai_inspectString,
    function: chai_inspectFunction,
    Function: chai_inspectFunction,
    symbol: chai_inspectSymbol,
    Symbol: chai_inspectSymbol,
    Array: chai_inspectArray,
    Date: chai_inspectDate,
    Map: chai_inspectMap,
    Set: chai_inspectSet,
    RegExp: chai_inspectRegExp,
    Promise: promise_default,
    WeakSet: /* @__PURE__ */ __name((value, options)=>options.stylize("WeakSet{\u2026}", "special"), "WeakSet"),
    WeakMap: /* @__PURE__ */ __name((value, options)=>options.stylize("WeakMap{\u2026}", "special"), "WeakMap"),
    Arguments: chai_inspectArguments,
    Int8Array: chai_inspectTypedArray,
    Uint8Array: chai_inspectTypedArray,
    Uint8ClampedArray: chai_inspectTypedArray,
    Int16Array: chai_inspectTypedArray,
    Uint16Array: chai_inspectTypedArray,
    Int32Array: chai_inspectTypedArray,
    Uint32Array: chai_inspectTypedArray,
    Float32Array: chai_inspectTypedArray,
    Float64Array: chai_inspectTypedArray,
    Generator: /* @__PURE__ */ __name(()=>"", "Generator"),
    DataView: /* @__PURE__ */ __name(()=>"", "DataView"),
    ArrayBuffer: /* @__PURE__ */ __name(()=>"", "ArrayBuffer"),
    Error: inspectObject2,
    HTMLCollection: chai_inspectNodeCollection,
    NodeList: chai_inspectNodeCollection
};
var chai_inspectCustom = /* @__PURE__ */ __name((value, options, type3)=>{
    if (chai_chaiInspect in value && "function" == typeof value[chai_chaiInspect]) return value[chai_chaiInspect](options);
    if (chai_nodeInspect in value && "function" == typeof value[chai_nodeInspect]) return value[chai_nodeInspect](options.depth, options);
    if ("inspect" in value && "function" == typeof value.inspect) return value.inspect(options.depth, options);
    if ("constructor" in value && chai_constructorMap.has(value.constructor)) return chai_constructorMap.get(value.constructor)(value, options);
    if (chai_stringTagMap[type3]) return chai_stringTagMap[type3](value, options);
    return "";
}, "inspectCustom");
var chai_toString = Object.prototype.toString;
function chai_inspect(value, opts = {}) {
    const options = chai_normaliseOptions(opts, chai_inspect);
    const { customInspect } = options;
    let type3 = null === value ? "null" : typeof value;
    if ("object" === type3) type3 = chai_toString.call(value).slice(8, -1);
    if (type3 in chai_baseTypesMap) return chai_baseTypesMap[type3](value, options);
    if (customInspect && value) {
        const output = chai_inspectCustom(value, options, type3);
        if (output) {
            if ("string" == typeof output) return output;
            return chai_inspect(output, options);
        }
    }
    const proto = value ? Object.getPrototypeOf(value) : false;
    if (proto === Object.prototype || null === proto) return chai_inspectObject(value, options);
    if (value && "function" == typeof HTMLElement && value instanceof HTMLElement) return chai_inspectHTML(value, options);
    if ("constructor" in value) {
        if (value.constructor !== Object) return chai_inspectClass(value, options);
        return chai_inspectObject(value, options);
    }
    if (value === Object(value)) return chai_inspectObject(value, options);
    return options.stylize(String(value), type3);
}
__name(chai_inspect, "inspect");
var chai_config = {
    includeStack: false,
    showDiff: true,
    truncateThreshold: 40,
    useProxy: true,
    proxyExcludedKeys: [
        "then",
        "catch",
        "inspect",
        "toJSON"
    ],
    deepEqual: null
};
function inspect2(obj, showHidden, depth, colors) {
    let options = {
        colors,
        depth: void 0 === depth ? 2 : depth,
        showHidden,
        truncate: chai_config.truncateThreshold ? chai_config.truncateThreshold : 1 / 0
    };
    return chai_inspect(obj, options);
}
__name(inspect2, "inspect");
function chai_objDisplay(obj) {
    let str = inspect2(obj), type3 = Object.prototype.toString.call(obj);
    if (!chai_config.truncateThreshold || !(str.length >= chai_config.truncateThreshold)) return str;
    if ("[object Function]" === type3) return obj.name && "" !== obj.name ? "[Function: " + obj.name + "]" : "[Function]";
    if ("[object Array]" === type3) return "[ Array(" + obj.length + ") ]";
    {
        if ("[object Object]" !== type3) return str;
        let keys = Object.keys(obj), kstr = keys.length > 2 ? keys.splice(0, 2).join(", ") + ", ..." : keys.join(", ");
        return "{ Object (" + kstr + ") }";
    }
}
__name(chai_objDisplay, "objDisplay");
function getMessage2(obj, args) {
    let negate = flag(obj, "negate");
    let val = flag(obj, "object");
    let expected = args[3];
    let actual = getActual(obj, args);
    let msg = negate ? args[2] : args[1];
    let flagMsg = flag(obj, "message");
    if ("function" == typeof msg) msg = msg();
    msg = msg || "";
    msg = msg.replace(/#\{this\}/g, function() {
        return chai_objDisplay(val);
    }).replace(/#\{act\}/g, function() {
        return chai_objDisplay(actual);
    }).replace(/#\{exp\}/g, function() {
        return chai_objDisplay(expected);
    });
    return flagMsg ? flagMsg + ": " + msg : msg;
}
__name(getMessage2, "getMessage");
function transferFlags(assertion, object, includeAll) {
    let flags = assertion.__flags || (assertion.__flags = /* @__PURE__ */ Object.create(null));
    if (!object.__flags) object.__flags = /* @__PURE__ */ Object.create(null);
    includeAll = 3 === arguments.length ? includeAll : true;
    for(let flag3 in flags)if (includeAll || "object" !== flag3 && "ssfi" !== flag3 && "lockSsfi" !== flag3 && "message" != flag3) object.__flags[flag3] = flags[flag3];
}
__name(transferFlags, "transferFlags");
function type2(obj) {
    if (void 0 === obj) return "undefined";
    if (null === obj) return "null";
    const stringTag = obj[Symbol.toStringTag];
    if ("string" == typeof stringTag) return stringTag;
    const sliceStart = 8;
    const sliceEnd = -1;
    return Object.prototype.toString.call(obj).slice(sliceStart, sliceEnd);
}
__name(type2, "type");
function FakeMap() {
    this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
__name(FakeMap, "FakeMap");
FakeMap.prototype = {
    get: /* @__PURE__ */ __name(function get(key) {
        return key[this._key];
    }, "get"),
    set: /* @__PURE__ */ __name(function set(key, value) {
        if (Object.isExtensible(key)) Object.defineProperty(key, this._key, {
            value,
            configurable: true
        });
    }, "set")
};
var MemoizeMap = "function" == typeof WeakMap ? WeakMap : FakeMap;
function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
    if (!memoizeMap || chai_isPrimitive(leftHandOperand) || chai_isPrimitive(rightHandOperand)) return null;
    var leftHandMap = memoizeMap.get(leftHandOperand);
    if (leftHandMap) {
        var result = leftHandMap.get(rightHandOperand);
        if ("boolean" == typeof result) return result;
    }
    return null;
}
__name(memoizeCompare, "memoizeCompare");
function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
    if (!memoizeMap || chai_isPrimitive(leftHandOperand) || chai_isPrimitive(rightHandOperand)) return;
    var leftHandMap = memoizeMap.get(leftHandOperand);
    if (leftHandMap) leftHandMap.set(rightHandOperand, result);
    else {
        leftHandMap = new MemoizeMap();
        leftHandMap.set(rightHandOperand, result);
        memoizeMap.set(leftHandOperand, leftHandMap);
    }
}
__name(memoizeSet, "memoizeSet");
var deep_eql_default = deepEqual;
function deepEqual(leftHandOperand, rightHandOperand, options) {
    if (options && options.comparator) return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
    if (null !== simpleResult) return simpleResult;
    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
}
__name(deepEqual, "deepEqual");
function simpleEqual(leftHandOperand, rightHandOperand) {
    if (leftHandOperand === rightHandOperand) return 0 !== leftHandOperand || 1 / leftHandOperand === 1 / rightHandOperand;
    if (leftHandOperand !== leftHandOperand && rightHandOperand !== rightHandOperand) return true;
    if (chai_isPrimitive(leftHandOperand) || chai_isPrimitive(rightHandOperand)) return false;
    return null;
}
__name(simpleEqual, "simpleEqual");
function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
    options = options || {};
    options.memoize = false === options.memoize ? false : options.memoize || new MemoizeMap();
    var comparator = options && options.comparator;
    var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);
    if (null !== memoizeResultLeft) return memoizeResultLeft;
    var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);
    if (null !== memoizeResultRight) return memoizeResultRight;
    if (comparator) {
        var comparatorResult = comparator(leftHandOperand, rightHandOperand);
        if (false === comparatorResult || true === comparatorResult) {
            memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
            return comparatorResult;
        }
        var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
        if (null !== simpleResult) return simpleResult;
    }
    var leftHandType = type2(leftHandOperand);
    if (leftHandType !== type2(rightHandOperand)) {
        memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
        return false;
    }
    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);
    var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
    return result;
}
__name(extensiveDeepEqual, "extensiveDeepEqual");
function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
    switch(leftHandType){
        case "String":
        case "Number":
        case "Boolean":
        case "Date":
            return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());
        case "Promise":
        case "Symbol":
        case "function":
        case "WeakMap":
        case "WeakSet":
            return leftHandOperand === rightHandOperand;
        case "Error":
            return keysEqual(leftHandOperand, rightHandOperand, [
                "name",
                "message",
                "code"
            ], options);
        case "Arguments":
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "Array":
            return iterableEqual(leftHandOperand, rightHandOperand, options);
        case "RegExp":
            return regexpEqual(leftHandOperand, rightHandOperand);
        case "Generator":
            return generatorEqual(leftHandOperand, rightHandOperand, options);
        case "DataView":
            return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);
        case "ArrayBuffer":
            return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);
        case "Set":
            return entriesEqual(leftHandOperand, rightHandOperand, options);
        case "Map":
            return entriesEqual(leftHandOperand, rightHandOperand, options);
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.Instant":
        case "Temporal.ZonedDateTime":
        case "Temporal.PlainYearMonth":
        case "Temporal.PlainMonthDay":
            return leftHandOperand.equals(rightHandOperand);
        case "Temporal.Duration":
            return leftHandOperand.total("nanoseconds") === rightHandOperand.total("nanoseconds");
        case "Temporal.TimeZone":
        case "Temporal.Calendar":
            return leftHandOperand.toString() === rightHandOperand.toString();
        default:
            return objectEqual(leftHandOperand, rightHandOperand, options);
    }
}
__name(extensiveDeepEqualByType, "extensiveDeepEqualByType");
function regexpEqual(leftHandOperand, rightHandOperand) {
    return leftHandOperand.toString() === rightHandOperand.toString();
}
__name(regexpEqual, "regexpEqual");
function entriesEqual(leftHandOperand, rightHandOperand, options) {
    try {
        if (leftHandOperand.size !== rightHandOperand.size) return false;
        if (0 === leftHandOperand.size) return true;
    } catch (sizeError) {
        return false;
    }
    var leftHandItems = [];
    var rightHandItems = [];
    leftHandOperand.forEach(/* @__PURE__ */ __name(function gatherEntries(key, value) {
        leftHandItems.push([
            key,
            value
        ]);
    }, "gatherEntries"));
    rightHandOperand.forEach(/* @__PURE__ */ __name(function gatherEntries(key, value) {
        rightHandItems.push([
            key,
            value
        ]);
    }, "gatherEntries"));
    return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
}
__name(entriesEqual, "entriesEqual");
function iterableEqual(leftHandOperand, rightHandOperand, options) {
    var length = leftHandOperand.length;
    if (length !== rightHandOperand.length) return false;
    if (0 === length) return true;
    var index = -1;
    while(++index < length)if (false === deepEqual(leftHandOperand[index], rightHandOperand[index], options)) return false;
    return true;
}
__name(iterableEqual, "iterableEqual");
function generatorEqual(leftHandOperand, rightHandOperand, options) {
    return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
}
__name(generatorEqual, "generatorEqual");
function hasIteratorFunction(target) {
    return "undefined" != typeof Symbol && "object" == typeof target && void 0 !== Symbol.iterator && "function" == typeof target[Symbol.iterator];
}
__name(hasIteratorFunction, "hasIteratorFunction");
function getIteratorEntries(target) {
    if (hasIteratorFunction(target)) try {
        return getGeneratorEntries(target[Symbol.iterator]());
    } catch (iteratorError) {}
    return [];
}
__name(getIteratorEntries, "getIteratorEntries");
function getGeneratorEntries(generator) {
    var generatorResult = generator.next();
    var accumulator = [
        generatorResult.value
    ];
    while(false === generatorResult.done){
        generatorResult = generator.next();
        accumulator.push(generatorResult.value);
    }
    return accumulator;
}
__name(getGeneratorEntries, "getGeneratorEntries");
function getEnumerableKeys(target) {
    var keys = [];
    for(var key in target)keys.push(key);
    return keys;
}
__name(getEnumerableKeys, "getEnumerableKeys");
function getEnumerableSymbols(target) {
    var keys = [];
    var allKeys = Object.getOwnPropertySymbols(target);
    for(var i = 0; i < allKeys.length; i += 1){
        var key = allKeys[i];
        if (Object.getOwnPropertyDescriptor(target, key).enumerable) keys.push(key);
    }
    return keys;
}
__name(getEnumerableSymbols, "getEnumerableSymbols");
function keysEqual(leftHandOperand, rightHandOperand, keys, options) {
    var length = keys.length;
    if (0 === length) return true;
    for(var i = 0; i < length; i += 1)if (false === deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options)) return false;
    return true;
}
__name(keysEqual, "keysEqual");
function objectEqual(leftHandOperand, rightHandOperand, options) {
    var leftHandKeys = getEnumerableKeys(leftHandOperand);
    var rightHandKeys = getEnumerableKeys(rightHandOperand);
    var leftHandSymbols = getEnumerableSymbols(leftHandOperand);
    var rightHandSymbols = getEnumerableSymbols(rightHandOperand);
    leftHandKeys = leftHandKeys.concat(leftHandSymbols);
    rightHandKeys = rightHandKeys.concat(rightHandSymbols);
    if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
        if (false === iterableEqual(mapSymbols(leftHandKeys).sort(), mapSymbols(rightHandKeys).sort())) return false;
        return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
    }
    var leftHandEntries = getIteratorEntries(leftHandOperand);
    var rightHandEntries = getIteratorEntries(rightHandOperand);
    if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
        leftHandEntries.sort();
        rightHandEntries.sort();
        return iterableEqual(leftHandEntries, rightHandEntries, options);
    }
    if (0 === leftHandKeys.length && 0 === leftHandEntries.length && 0 === rightHandKeys.length && 0 === rightHandEntries.length) return true;
    return false;
}
__name(objectEqual, "objectEqual");
function chai_isPrimitive(value) {
    return null === value || "object" != typeof value;
}
__name(chai_isPrimitive, "isPrimitive");
function mapSymbols(arr) {
    return arr.map(/* @__PURE__ */ __name(function mapSymbol(entry) {
        if ("symbol" == typeof entry) return entry.toString();
        return entry;
    }, "mapSymbol"));
}
__name(mapSymbols, "mapSymbols");
function hasProperty(obj, name) {
    if (null == obj) return false;
    return name in Object(obj);
}
__name(hasProperty, "hasProperty");
function parsePath(path) {
    const str = path.replace(/([^\\])\[/g, "$1.[");
    const parts = str.match(/(\\\.|[^.]+?)+/g);
    return parts.map((value)=>{
        if ("constructor" === value || "__proto__" === value || "prototype" === value) return {};
        const regexp = /^\[(\d+)\]$/;
        const mArr = regexp.exec(value);
        let parsed = null;
        parsed = mArr ? {
            i: parseFloat(mArr[1])
        } : {
            p: value.replace(/\\([.[\]])/g, "$1")
        };
        return parsed;
    });
}
__name(parsePath, "parsePath");
function internalGetPathValue(obj, parsed, pathDepth) {
    let temporaryValue = obj;
    let res = null;
    pathDepth = void 0 === pathDepth ? parsed.length : pathDepth;
    for(let i = 0; i < pathDepth; i++){
        const part = parsed[i];
        if (temporaryValue) {
            temporaryValue = void 0 === part.p ? temporaryValue[part.i] : temporaryValue[part.p];
            if (i === pathDepth - 1) res = temporaryValue;
        }
    }
    return res;
}
__name(internalGetPathValue, "internalGetPathValue");
function getPathInfo(obj, path) {
    const parsed = parsePath(path);
    const last = parsed[parsed.length - 1];
    const info = {
        parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
        name: last.p || last.i,
        value: internalGetPathValue(obj, parsed)
    };
    info.exists = hasProperty(info.parent, info.name);
    return info;
}
__name(getPathInfo, "getPathInfo");
var Assertion = class _Assertion {
    static{
        __name(this, "Assertion");
    }
    __flags = {};
    constructor(obj, msg, ssfi, lockSsfi){
        flag(this, "ssfi", ssfi || _Assertion);
        flag(this, "lockSsfi", lockSsfi);
        flag(this, "object", obj);
        flag(this, "message", msg);
        flag(this, "eql", chai_config.deepEqual || deep_eql_default);
        return proxify(this);
    }
    static get includeStack() {
        console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");
        return chai_config.includeStack;
    }
    static set includeStack(value) {
        console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");
        chai_config.includeStack = value;
    }
    static get showDiff() {
        console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");
        return chai_config.showDiff;
    }
    static set showDiff(value) {
        console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");
        chai_config.showDiff = value;
    }
    static addProperty(name, fn) {
        addProperty(this.prototype, name, fn);
    }
    static addMethod(name, fn) {
        chai_addMethod(this.prototype, name, fn);
    }
    static addChainableMethod(name, fn, chainingBehavior) {
        addChainableMethod(this.prototype, name, fn, chainingBehavior);
    }
    static overwriteProperty(name, fn) {
        overwriteProperty(this.prototype, name, fn);
    }
    static overwriteMethod(name, fn) {
        overwriteMethod(this.prototype, name, fn);
    }
    static overwriteChainableMethod(name, fn, chainingBehavior) {
        overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
    }
    assert(_expr, msg, _negateMsg, expected, _actual, showDiff) {
        const ok = chai_test(this, arguments);
        if (false !== showDiff) showDiff = true;
        if (void 0 === expected && void 0 === _actual) showDiff = false;
        if (true !== chai_config.showDiff) showDiff = false;
        if (!ok) {
            msg = getMessage2(this, arguments);
            const actual = getActual(this, arguments);
            const assertionErrorObjectProperties = {
                actual,
                expected,
                showDiff
            };
            const operator = getOperator(this, arguments);
            if (operator) assertionErrorObjectProperties.operator = operator;
            throw new chai_AssertionError(msg, assertionErrorObjectProperties, chai_config.includeStack ? this.assert : flag(this, "ssfi"));
        }
    }
    get _obj() {
        return flag(this, "object");
    }
    set _obj(val) {
        flag(this, "object", val);
    }
};
function isProxyEnabled() {
    return chai_config.useProxy && "undefined" != typeof Proxy && "undefined" != typeof Reflect;
}
__name(isProxyEnabled, "isProxyEnabled");
function addProperty(ctx, name, getter) {
    getter = void 0 === getter ? function() {} : getter;
    Object.defineProperty(ctx, name, {
        get: /* @__PURE__ */ __name(function propertyGetter() {
            if (!isProxyEnabled() && !flag(this, "lockSsfi")) flag(this, "ssfi", propertyGetter);
            let result = getter.call(this);
            if (void 0 !== result) return result;
            let newAssertion = new Assertion();
            transferFlags(this, newAssertion);
            return newAssertion;
        }, "propertyGetter"),
        configurable: true
    });
}
__name(addProperty, "addProperty");
var fnLengthDesc = Object.getOwnPropertyDescriptor(function() {}, "length");
function addLengthGuard(fn, assertionName, isChainable) {
    if (!fnLengthDesc.configurable) return fn;
    Object.defineProperty(fn, "length", {
        get: /* @__PURE__ */ __name(function() {
            if (isChainable) throw Error("Invalid Chai property: " + assertionName + '.length. Due to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.');
            throw Error("Invalid Chai property: " + assertionName + '.length. See docs for proper usage of "' + assertionName + '".');
        }, "get")
    });
    return fn;
}
__name(addLengthGuard, "addLengthGuard");
function getProperties(object) {
    let result = Object.getOwnPropertyNames(object);
    function addProperty2(property) {
        if (-1 === result.indexOf(property)) result.push(property);
    }
    __name(addProperty2, "addProperty");
    let proto = Object.getPrototypeOf(object);
    while(null !== proto){
        Object.getOwnPropertyNames(proto).forEach(addProperty2);
        proto = Object.getPrototypeOf(proto);
    }
    return result;
}
__name(getProperties, "getProperties");
var builtins = [
    "__flags",
    "__methods",
    "_obj",
    "assert"
];
function proxify(obj, nonChainableMethodName) {
    if (!isProxyEnabled()) return obj;
    return new Proxy(obj, {
        get: /* @__PURE__ */ __name(function proxyGetter(target, property) {
            if ("string" == typeof property && -1 === chai_config.proxyExcludedKeys.indexOf(property) && !Reflect.has(target, property)) {
                if (nonChainableMethodName) throw Error("Invalid Chai property: " + nonChainableMethodName + "." + property + '. See docs for proper usage of "' + nonChainableMethodName + '".');
                let suggestion = null;
                let suggestionDistance = 4;
                getProperties(target).forEach(function(prop) {
                    if (!Object.prototype.hasOwnProperty(prop) && -1 === builtins.indexOf(prop)) {
                        let dist = stringDistanceCapped(property, prop, suggestionDistance);
                        if (dist < suggestionDistance) {
                            suggestion = prop;
                            suggestionDistance = dist;
                        }
                    }
                });
                if (null !== suggestion) throw Error("Invalid Chai property: " + property + '. Did you mean "' + suggestion + '"?');
                throw Error("Invalid Chai property: " + property);
            }
            if (-1 === builtins.indexOf(property) && !flag(target, "lockSsfi")) flag(target, "ssfi", proxyGetter);
            return Reflect.get(target, property);
        }, "proxyGetter")
    });
}
__name(proxify, "proxify");
function stringDistanceCapped(strA, strB, cap) {
    if (Math.abs(strA.length - strB.length) >= cap) return cap;
    let memo = [];
    for(let i = 0; i <= strA.length; i++){
        memo[i] = Array(strB.length + 1).fill(0);
        memo[i][0] = i;
    }
    for(let j = 0; j < strB.length; j++)memo[0][j] = j;
    for(let i = 1; i <= strA.length; i++){
        let ch = strA.charCodeAt(i - 1);
        for(let j = 1; j <= strB.length; j++){
            if (Math.abs(i - j) >= cap) {
                memo[i][j] = cap;
                continue;
            }
            memo[i][j] = Math.min(memo[i - 1][j] + 1, memo[i][j - 1] + 1, memo[i - 1][j - 1] + (ch === strB.charCodeAt(j - 1) ? 0 : 1));
        }
    }
    return memo[strA.length][strB.length];
}
__name(stringDistanceCapped, "stringDistanceCapped");
function chai_addMethod(ctx, name, method) {
    let methodWrapper = /* @__PURE__ */ __name(function() {
        if (!flag(this, "lockSsfi")) flag(this, "ssfi", methodWrapper);
        let result = method.apply(this, arguments);
        if (void 0 !== result) return result;
        let newAssertion = new Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
    }, "methodWrapper");
    addLengthGuard(methodWrapper, name, false);
    ctx[name] = proxify(methodWrapper, name);
}
__name(chai_addMethod, "addMethod");
function overwriteProperty(ctx, name, getter) {
    let _get = Object.getOwnPropertyDescriptor(ctx, name), _super = /* @__PURE__ */ __name(function() {}, "_super");
    if (_get && "function" == typeof _get.get) _super = _get.get;
    Object.defineProperty(ctx, name, {
        get: /* @__PURE__ */ __name(function overwritingPropertyGetter() {
            if (!isProxyEnabled() && !flag(this, "lockSsfi")) flag(this, "ssfi", overwritingPropertyGetter);
            let origLockSsfi = flag(this, "lockSsfi");
            flag(this, "lockSsfi", true);
            let result = getter(_super).call(this);
            flag(this, "lockSsfi", origLockSsfi);
            if (void 0 !== result) return result;
            let newAssertion = new Assertion();
            transferFlags(this, newAssertion);
            return newAssertion;
        }, "overwritingPropertyGetter"),
        configurable: true
    });
}
__name(overwriteProperty, "overwriteProperty");
function overwriteMethod(ctx, name, method) {
    let _method = ctx[name], _super = /* @__PURE__ */ __name(function() {
        throw new Error(name + " is not a function");
    }, "_super");
    if (_method && "function" == typeof _method) _super = _method;
    let overwritingMethodWrapper = /* @__PURE__ */ __name(function() {
        if (!flag(this, "lockSsfi")) flag(this, "ssfi", overwritingMethodWrapper);
        let origLockSsfi = flag(this, "lockSsfi");
        flag(this, "lockSsfi", true);
        let result = method(_super).apply(this, arguments);
        flag(this, "lockSsfi", origLockSsfi);
        if (void 0 !== result) return result;
        let newAssertion = new Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
    }, "overwritingMethodWrapper");
    addLengthGuard(overwritingMethodWrapper, name, false);
    ctx[name] = proxify(overwritingMethodWrapper, name);
}
__name(overwriteMethod, "overwriteMethod");
var canSetPrototype = "function" == typeof Object.setPrototypeOf;
var chai_testFn = /* @__PURE__ */ __name(function() {}, "testFn");
var excludeNames = Object.getOwnPropertyNames(chai_testFn).filter(function(name) {
    let propDesc = Object.getOwnPropertyDescriptor(chai_testFn, name);
    if ("object" != typeof propDesc) return true;
    return !propDesc.configurable;
});
var call = Function.prototype.call;
var apply = Function.prototype.apply;
function addChainableMethod(ctx, name, method, chainingBehavior) {
    if ("function" != typeof chainingBehavior) chainingBehavior = /* @__PURE__ */ __name(function() {}, "chainingBehavior");
    let chainableBehavior = {
        method,
        chainingBehavior
    };
    if (!ctx.__methods) ctx.__methods = {};
    ctx.__methods[name] = chainableBehavior;
    Object.defineProperty(ctx, name, {
        get: /* @__PURE__ */ __name(function chainableMethodGetter() {
            chainableBehavior.chainingBehavior.call(this);
            let chainableMethodWrapper = /* @__PURE__ */ __name(function() {
                if (!flag(this, "lockSsfi")) flag(this, "ssfi", chainableMethodWrapper);
                let result = chainableBehavior.method.apply(this, arguments);
                if (void 0 !== result) return result;
                let newAssertion = new Assertion();
                transferFlags(this, newAssertion);
                return newAssertion;
            }, "chainableMethodWrapper");
            addLengthGuard(chainableMethodWrapper, name, true);
            if (canSetPrototype) {
                let prototype = Object.create(this);
                prototype.call = call;
                prototype.apply = apply;
                Object.setPrototypeOf(chainableMethodWrapper, prototype);
            } else {
                let asserterNames = Object.getOwnPropertyNames(ctx);
                asserterNames.forEach(function(asserterName) {
                    if (-1 !== excludeNames.indexOf(asserterName)) return;
                    let pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
                    Object.defineProperty(chainableMethodWrapper, asserterName, pd);
                });
            }
            transferFlags(this, chainableMethodWrapper);
            return proxify(chainableMethodWrapper);
        }, "chainableMethodGetter"),
        configurable: true
    });
}
__name(addChainableMethod, "addChainableMethod");
function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
    let chainableBehavior = ctx.__methods[name];
    let _chainingBehavior = chainableBehavior.chainingBehavior;
    chainableBehavior.chainingBehavior = /* @__PURE__ */ __name(function overwritingChainableMethodGetter() {
        let result = chainingBehavior(_chainingBehavior).call(this);
        if (void 0 !== result) return result;
        let newAssertion = new Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
    }, "overwritingChainableMethodGetter");
    let _method = chainableBehavior.method;
    chainableBehavior.method = /* @__PURE__ */ __name(function overwritingChainableMethodWrapper() {
        let result = method(_method).apply(this, arguments);
        if (void 0 !== result) return result;
        let newAssertion = new Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
    }, "overwritingChainableMethodWrapper");
}
__name(overwriteChainableMethod, "overwriteChainableMethod");
function compareByInspect(a, b) {
    return inspect2(a) < inspect2(b) ? -1 : 1;
}
__name(compareByInspect, "compareByInspect");
function getOwnEnumerablePropertySymbols(obj) {
    if ("function" != typeof Object.getOwnPropertySymbols) return [];
    return Object.getOwnPropertySymbols(obj).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
    });
}
__name(getOwnEnumerablePropertySymbols, "getOwnEnumerablePropertySymbols");
function getOwnEnumerableProperties(obj) {
    return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
}
__name(getOwnEnumerableProperties, "getOwnEnumerableProperties");
var isNaN2 = Number.isNaN;
function isObjectType(obj) {
    let objectType = chai_type(obj);
    let objectTypes = [
        "Array",
        "Object",
        "Function"
    ];
    return -1 !== objectTypes.indexOf(objectType);
}
__name(isObjectType, "isObjectType");
function getOperator(obj, args) {
    let operator = flag(obj, "operator");
    let negate = flag(obj, "negate");
    let expected = args[3];
    let msg = negate ? args[2] : args[1];
    if (operator) return operator;
    if ("function" == typeof msg) msg = msg();
    msg = msg || "";
    if (!msg) return;
    if (/\shave\s/.test(msg)) return;
    let isObject = isObjectType(expected);
    if (/\snot\s/.test(msg)) return isObject ? "notDeepStrictEqual" : "notStrictEqual";
    return isObject ? "deepStrictEqual" : "strictEqual";
}
__name(getOperator, "getOperator");
function getName(fn) {
    return fn.name;
}
__name(getName, "getName");
function isRegExp2(obj) {
    return "[object RegExp]" === Object.prototype.toString.call(obj);
}
__name(isRegExp2, "isRegExp");
function isNumeric(obj) {
    return [
        "Number",
        "BigInt"
    ].includes(chai_type(obj));
}
__name(isNumeric, "isNumeric");
var { flag: flag2 } = utils_exports;
[
    "to",
    "be",
    "been",
    "is",
    "and",
    "has",
    "have",
    "with",
    "that",
    "which",
    "at",
    "of",
    "same",
    "but",
    "does",
    "still",
    "also"
].forEach(function(chain) {
    Assertion.addProperty(chain);
});
Assertion.addProperty("not", function() {
    flag2(this, "negate", true);
});
Assertion.addProperty("deep", function() {
    flag2(this, "deep", true);
});
Assertion.addProperty("nested", function() {
    flag2(this, "nested", true);
});
Assertion.addProperty("own", function() {
    flag2(this, "own", true);
});
Assertion.addProperty("ordered", function() {
    flag2(this, "ordered", true);
});
Assertion.addProperty("any", function() {
    flag2(this, "any", true);
    flag2(this, "all", false);
});
Assertion.addProperty("all", function() {
    flag2(this, "all", true);
    flag2(this, "any", false);
});
var functionTypes = {
    function: [
        "function",
        "asyncfunction",
        "generatorfunction",
        "asyncgeneratorfunction"
    ],
    asyncfunction: [
        "asyncfunction",
        "asyncgeneratorfunction"
    ],
    generatorfunction: [
        "generatorfunction",
        "asyncgeneratorfunction"
    ],
    asyncgeneratorfunction: [
        "asyncgeneratorfunction"
    ]
};
function an(type3, msg) {
    if (msg) flag2(this, "message", msg);
    type3 = type3.toLowerCase();
    let obj = flag2(this, "object"), article = ~[
        "a",
        "e",
        "i",
        "o",
        "u"
    ].indexOf(type3.charAt(0)) ? "an " : "a ";
    const detectedType = chai_type(obj).toLowerCase();
    if (functionTypes["function"].includes(type3)) this.assert(functionTypes[type3].includes(detectedType), "expected #{this} to be " + article + type3, "expected #{this} not to be " + article + type3);
    else this.assert(type3 === detectedType, "expected #{this} to be " + article + type3, "expected #{this} not to be " + article + type3);
}
__name(an, "an");
Assertion.addChainableMethod("an", an);
Assertion.addChainableMethod("a", an);
function SameValueZero(a, b) {
    return isNaN2(a) && isNaN2(b) || a === b;
}
__name(SameValueZero, "SameValueZero");
function includeChainingBehavior() {
    flag2(this, "contains", true);
}
__name(includeChainingBehavior, "includeChainingBehavior");
function include(val, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), objType = chai_type(obj).toLowerCase(), flagMsg = flag2(this, "message"), negate = flag2(this, "negate"), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), descriptor = isDeep ? "deep " : "", isEql = isDeep ? flag2(this, "eql") : SameValueZero;
    flagMsg = flagMsg ? flagMsg + ": " : "";
    let included = false;
    switch(objType){
        case "string":
            included = -1 !== obj.indexOf(val);
            break;
        case "weakset":
            if (isDeep) throw new chai_AssertionError(flagMsg + "unable to use .deep.include with WeakSet", void 0, ssfi);
            included = obj.has(val);
            break;
        case "map":
            obj.forEach(function(item) {
                included = included || isEql(item, val);
            });
            break;
        case "set":
            if (isDeep) obj.forEach(function(item) {
                included = included || isEql(item, val);
            });
            else included = obj.has(val);
            break;
        case "array":
            included = isDeep ? obj.some(function(item) {
                return isEql(item, val);
            }) : -1 !== obj.indexOf(val);
            break;
        default:
            {
                if (val !== Object(val)) throw new chai_AssertionError(flagMsg + "the given combination of arguments (" + objType + " and " + chai_type(val).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + chai_type(val).toLowerCase(), void 0, ssfi);
                let props = Object.keys(val);
                let firstErr = null;
                let numErrs = 0;
                props.forEach(function(prop) {
                    let propAssertion = new Assertion(obj);
                    transferFlags(this, propAssertion, true);
                    flag2(propAssertion, "lockSsfi", true);
                    if (!negate || 1 === props.length) return void propAssertion.property(prop, val[prop]);
                    try {
                        propAssertion.property(prop, val[prop]);
                    } catch (err) {
                        if (!check_error_exports.compatibleConstructor(err, chai_AssertionError)) throw err;
                        if (null === firstErr) firstErr = err;
                        numErrs++;
                    }
                }, this);
                if (negate && props.length > 1 && numErrs === props.length) throw firstErr;
                return;
            }
    }
    this.assert(included, "expected #{this} to " + descriptor + "include " + inspect2(val), "expected #{this} to not " + descriptor + "include " + inspect2(val));
}
__name(include, "include");
Assertion.addChainableMethod("include", include, includeChainingBehavior);
Assertion.addChainableMethod("contain", include, includeChainingBehavior);
Assertion.addChainableMethod("contains", include, includeChainingBehavior);
Assertion.addChainableMethod("includes", include, includeChainingBehavior);
Assertion.addProperty("ok", function() {
    this.assert(flag2(this, "object"), "expected #{this} to be truthy", "expected #{this} to be falsy");
});
Assertion.addProperty("true", function() {
    this.assert(true === flag2(this, "object"), "expected #{this} to be true", "expected #{this} to be false", !flag2(this, "negate"));
});
Assertion.addProperty("numeric", function() {
    const object = flag2(this, "object");
    this.assert([
        "Number",
        "BigInt"
    ].includes(chai_type(object)), "expected #{this} to be numeric", "expected #{this} to not be numeric", !flag2(this, "negate"));
});
Assertion.addProperty("callable", function() {
    const val = flag2(this, "object");
    const ssfi = flag2(this, "ssfi");
    const message = flag2(this, "message");
    const msg = message ? `${message}: ` : "";
    const negate = flag2(this, "negate");
    const assertionMessage = negate ? `${msg}expected ${inspect2(val)} not to be a callable function` : `${msg}expected ${inspect2(val)} to be a callable function`;
    const isCallable = [
        "Function",
        "AsyncFunction",
        "GeneratorFunction",
        "AsyncGeneratorFunction"
    ].includes(chai_type(val));
    if (isCallable && negate || !isCallable && !negate) throw new chai_AssertionError(assertionMessage, void 0, ssfi);
});
Assertion.addProperty("false", function() {
    this.assert(false === flag2(this, "object"), "expected #{this} to be false", "expected #{this} to be true", !!flag2(this, "negate"));
});
Assertion.addProperty("null", function() {
    this.assert(null === flag2(this, "object"), "expected #{this} to be null", "expected #{this} not to be null");
});
Assertion.addProperty("undefined", function() {
    this.assert(void 0 === flag2(this, "object"), "expected #{this} to be undefined", "expected #{this} not to be undefined");
});
Assertion.addProperty("NaN", function() {
    this.assert(isNaN2(flag2(this, "object")), "expected #{this} to be NaN", "expected #{this} not to be NaN");
});
function assertExist() {
    let val = flag2(this, "object");
    this.assert(null != val, "expected #{this} to exist", "expected #{this} to not exist");
}
__name(assertExist, "assertExist");
Assertion.addProperty("exist", assertExist);
Assertion.addProperty("exists", assertExist);
Assertion.addProperty("empty", function() {
    let val = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), itemsCount;
    flagMsg = flagMsg ? flagMsg + ": " : "";
    switch(chai_type(val).toLowerCase()){
        case "array":
        case "string":
            itemsCount = val.length;
            break;
        case "map":
        case "set":
            itemsCount = val.size;
            break;
        case "weakmap":
        case "weakset":
            throw new chai_AssertionError(flagMsg + ".empty was passed a weak collection", void 0, ssfi);
        case "function":
            {
                const msg = flagMsg + ".empty was passed a function " + getName(val);
                throw new chai_AssertionError(msg.trim(), void 0, ssfi);
            }
        default:
            if (val !== Object(val)) throw new chai_AssertionError(flagMsg + ".empty was passed non-string primitive " + inspect2(val), void 0, ssfi);
            itemsCount = Object.keys(val).length;
    }
    this.assert(0 === itemsCount, "expected #{this} to be empty", "expected #{this} not to be empty");
});
function checkArguments() {
    let obj = flag2(this, "object"), type3 = chai_type(obj);
    this.assert("Arguments" === type3, "expected #{this} to be arguments but got " + type3, "expected #{this} to not be arguments");
}
__name(checkArguments, "checkArguments");
Assertion.addProperty("arguments", checkArguments);
Assertion.addProperty("Arguments", checkArguments);
function assertEqual(val, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object");
    if (flag2(this, "deep")) {
        let prevLockSsfi = flag2(this, "lockSsfi");
        flag2(this, "lockSsfi", true);
        this.eql(val);
        flag2(this, "lockSsfi", prevLockSsfi);
    } else this.assert(val === obj, "expected #{this} to equal #{exp}", "expected #{this} to not equal #{exp}", val, this._obj, true);
}
__name(assertEqual, "assertEqual");
Assertion.addMethod("equal", assertEqual);
Assertion.addMethod("equals", assertEqual);
Assertion.addMethod("eq", assertEqual);
function assertEql(obj, msg) {
    if (msg) flag2(this, "message", msg);
    let eql = flag2(this, "eql");
    this.assert(eql(obj, flag2(this, "object")), "expected #{this} to deeply equal #{exp}", "expected #{this} to not deeply equal #{exp}", obj, this._obj, true);
}
__name(assertEql, "assertEql");
Assertion.addMethod("eql", assertEql);
Assertion.addMethod("eqls", assertEql);
function assertAbove(n, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = chai_type(obj).toLowerCase(), nType = chai_type(n).toLowerCase();
    if (doLength && "map" !== objType && "set" !== objType) new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
    if (doLength || "date" !== objType || "date" === nType) {
        if (!isNumeric(n) && (doLength || isNumeric(obj))) throw new chai_AssertionError(msgPrefix + "the argument to above must be a number", void 0, ssfi);
        else if (!doLength && "date" !== objType && !isNumeric(obj)) {
            let printObj = "string" === objType ? "'" + obj + "'" : obj;
            throw new chai_AssertionError(msgPrefix + "expected " + printObj + " to be a number or a date", void 0, ssfi);
        }
    } else throw new chai_AssertionError(msgPrefix + "the argument to above must be a date", void 0, ssfi);
    if (doLength) {
        let descriptor = "length", itemsCount;
        if ("map" === objType || "set" === objType) {
            descriptor = "size";
            itemsCount = obj.size;
        } else itemsCount = obj.length;
        this.assert(itemsCount > n, "expected #{this} to have a " + descriptor + " above #{exp} but got #{act}", "expected #{this} to not have a " + descriptor + " above #{exp}", n, itemsCount);
    } else this.assert(obj > n, "expected #{this} to be above #{exp}", "expected #{this} to be at most #{exp}", n);
}
__name(assertAbove, "assertAbove");
Assertion.addMethod("above", assertAbove);
Assertion.addMethod("gt", assertAbove);
Assertion.addMethod("greaterThan", assertAbove);
function assertLeast(n, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = chai_type(obj).toLowerCase(), nType = chai_type(n).toLowerCase(), errorMessage, shouldThrow = true;
    if (doLength && "map" !== objType && "set" !== objType) new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
    if (doLength || "date" !== objType || "date" === nType) if (!isNumeric(n) && (doLength || isNumeric(obj))) errorMessage = msgPrefix + "the argument to least must be a number";
    else if (doLength || "date" === objType || isNumeric(obj)) shouldThrow = false;
    else {
        let printObj = "string" === objType ? "'" + obj + "'" : obj;
        errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
    }
    else errorMessage = msgPrefix + "the argument to least must be a date";
    if (shouldThrow) throw new chai_AssertionError(errorMessage, void 0, ssfi);
    if (doLength) {
        let descriptor = "length", itemsCount;
        if ("map" === objType || "set" === objType) {
            descriptor = "size";
            itemsCount = obj.size;
        } else itemsCount = obj.length;
        this.assert(itemsCount >= n, "expected #{this} to have a " + descriptor + " at least #{exp} but got #{act}", "expected #{this} to have a " + descriptor + " below #{exp}", n, itemsCount);
    } else this.assert(obj >= n, "expected #{this} to be at least #{exp}", "expected #{this} to be below #{exp}", n);
}
__name(assertLeast, "assertLeast");
Assertion.addMethod("least", assertLeast);
Assertion.addMethod("gte", assertLeast);
Assertion.addMethod("greaterThanOrEqual", assertLeast);
function assertBelow(n, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = chai_type(obj).toLowerCase(), nType = chai_type(n).toLowerCase(), errorMessage, shouldThrow = true;
    if (doLength && "map" !== objType && "set" !== objType) new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
    if (doLength || "date" !== objType || "date" === nType) if (!isNumeric(n) && (doLength || isNumeric(obj))) errorMessage = msgPrefix + "the argument to below must be a number";
    else if (doLength || "date" === objType || isNumeric(obj)) shouldThrow = false;
    else {
        let printObj = "string" === objType ? "'" + obj + "'" : obj;
        errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
    }
    else errorMessage = msgPrefix + "the argument to below must be a date";
    if (shouldThrow) throw new chai_AssertionError(errorMessage, void 0, ssfi);
    if (doLength) {
        let descriptor = "length", itemsCount;
        if ("map" === objType || "set" === objType) {
            descriptor = "size";
            itemsCount = obj.size;
        } else itemsCount = obj.length;
        this.assert(itemsCount < n, "expected #{this} to have a " + descriptor + " below #{exp} but got #{act}", "expected #{this} to not have a " + descriptor + " below #{exp}", n, itemsCount);
    } else this.assert(obj < n, "expected #{this} to be below #{exp}", "expected #{this} to be at least #{exp}", n);
}
__name(assertBelow, "assertBelow");
Assertion.addMethod("below", assertBelow);
Assertion.addMethod("lt", assertBelow);
Assertion.addMethod("lessThan", assertBelow);
function assertMost(n, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = chai_type(obj).toLowerCase(), nType = chai_type(n).toLowerCase(), errorMessage, shouldThrow = true;
    if (doLength && "map" !== objType && "set" !== objType) new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
    if (doLength || "date" !== objType || "date" === nType) if (!isNumeric(n) && (doLength || isNumeric(obj))) errorMessage = msgPrefix + "the argument to most must be a number";
    else if (doLength || "date" === objType || isNumeric(obj)) shouldThrow = false;
    else {
        let printObj = "string" === objType ? "'" + obj + "'" : obj;
        errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
    }
    else errorMessage = msgPrefix + "the argument to most must be a date";
    if (shouldThrow) throw new chai_AssertionError(errorMessage, void 0, ssfi);
    if (doLength) {
        let descriptor = "length", itemsCount;
        if ("map" === objType || "set" === objType) {
            descriptor = "size";
            itemsCount = obj.size;
        } else itemsCount = obj.length;
        this.assert(itemsCount <= n, "expected #{this} to have a " + descriptor + " at most #{exp} but got #{act}", "expected #{this} to have a " + descriptor + " above #{exp}", n, itemsCount);
    } else this.assert(obj <= n, "expected #{this} to be at most #{exp}", "expected #{this} to be above #{exp}", n);
}
__name(assertMost, "assertMost");
Assertion.addMethod("most", assertMost);
Assertion.addMethod("lte", assertMost);
Assertion.addMethod("lessThanOrEqual", assertMost);
Assertion.addMethod("within", function(start, finish, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = chai_type(obj).toLowerCase(), startType = chai_type(start).toLowerCase(), finishType = chai_type(finish).toLowerCase(), errorMessage, shouldThrow = true, range = "date" === startType && "date" === finishType ? start.toISOString() + ".." + finish.toISOString() : start + ".." + finish;
    if (doLength && "map" !== objType && "set" !== objType) new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
    if (doLength || "date" !== objType || "date" === startType && "date" === finishType) if ((!isNumeric(start) || !isNumeric(finish)) && (doLength || isNumeric(obj))) errorMessage = msgPrefix + "the arguments to within must be numbers";
    else if (doLength || "date" === objType || isNumeric(obj)) shouldThrow = false;
    else {
        let printObj = "string" === objType ? "'" + obj + "'" : obj;
        errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
    }
    else errorMessage = msgPrefix + "the arguments to within must be dates";
    if (shouldThrow) throw new chai_AssertionError(errorMessage, void 0, ssfi);
    if (doLength) {
        let descriptor = "length", itemsCount;
        if ("map" === objType || "set" === objType) {
            descriptor = "size";
            itemsCount = obj.size;
        } else itemsCount = obj.length;
        this.assert(itemsCount >= start && itemsCount <= finish, "expected #{this} to have a " + descriptor + " within " + range, "expected #{this} to not have a " + descriptor + " within " + range);
    } else this.assert(obj >= start && obj <= finish, "expected #{this} to be within " + range, "expected #{this} to not be within " + range);
});
function assertInstanceOf(constructor, msg) {
    if (msg) flag2(this, "message", msg);
    let target = flag2(this, "object");
    let ssfi = flag2(this, "ssfi");
    let flagMsg = flag2(this, "message");
    let isInstanceOf;
    try {
        isInstanceOf = target instanceof constructor;
    } catch (err) {
        if (err instanceof TypeError) {
            flagMsg = flagMsg ? flagMsg + ": " : "";
            throw new chai_AssertionError(flagMsg + "The instanceof assertion needs a constructor but " + chai_type(constructor) + " was given.", void 0, ssfi);
        }
        throw err;
    }
    let name = getName(constructor);
    if (null == name) name = "an unnamed constructor";
    this.assert(isInstanceOf, "expected #{this} to be an instance of " + name, "expected #{this} to not be an instance of " + name);
}
__name(assertInstanceOf, "assertInstanceOf");
Assertion.addMethod("instanceof", assertInstanceOf);
Assertion.addMethod("instanceOf", assertInstanceOf);
function assertProperty(name, val, msg) {
    if (msg) flag2(this, "message", msg);
    let isNested = flag2(this, "nested"), isOwn = flag2(this, "own"), flagMsg = flag2(this, "message"), obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), nameType = typeof name;
    flagMsg = flagMsg ? flagMsg + ": " : "";
    if (isNested) {
        if ("string" !== nameType) throw new chai_AssertionError(flagMsg + "the argument to property must be a string when using nested syntax", void 0, ssfi);
    } else if ("string" !== nameType && "number" !== nameType && "symbol" !== nameType) throw new chai_AssertionError(flagMsg + "the argument to property must be a string, number, or symbol", void 0, ssfi);
    if (isNested && isOwn) throw new chai_AssertionError(flagMsg + 'The "nested" and "own" flags cannot be combined.', void 0, ssfi);
    if (null == obj) throw new chai_AssertionError(flagMsg + "Target cannot be null or undefined.", void 0, ssfi);
    let isDeep = flag2(this, "deep"), negate = flag2(this, "negate"), pathInfo = isNested ? getPathInfo(obj, name) : null, value = isNested ? pathInfo.value : obj[name], isEql = isDeep ? flag2(this, "eql") : (val1, val2)=>val1 === val2;
    let descriptor = "";
    if (isDeep) descriptor += "deep ";
    if (isOwn) descriptor += "own ";
    if (isNested) descriptor += "nested ";
    descriptor += "property ";
    let hasProperty2;
    hasProperty2 = isOwn ? Object.prototype.hasOwnProperty.call(obj, name) : isNested ? pathInfo.exists : hasProperty(obj, name);
    if (!negate || 1 === arguments.length) this.assert(hasProperty2, "expected #{this} to have " + descriptor + inspect2(name), "expected #{this} to not have " + descriptor + inspect2(name));
    if (arguments.length > 1) this.assert(hasProperty2 && isEql(val, value), "expected #{this} to have " + descriptor + inspect2(name) + " of #{exp}, but got #{act}", "expected #{this} to not have " + descriptor + inspect2(name) + " of #{act}", val, value);
    flag2(this, "object", value);
}
__name(assertProperty, "assertProperty");
Assertion.addMethod("property", assertProperty);
function assertOwnProperty(_name, _value, _msg) {
    flag2(this, "own", true);
    assertProperty.apply(this, arguments);
}
__name(assertOwnProperty, "assertOwnProperty");
Assertion.addMethod("ownProperty", assertOwnProperty);
Assertion.addMethod("haveOwnProperty", assertOwnProperty);
function assertOwnPropertyDescriptor(name, descriptor, msg) {
    if ("string" == typeof descriptor) {
        msg = descriptor;
        descriptor = null;
    }
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object");
    let actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
    let eql = flag2(this, "eql");
    if (actualDescriptor && descriptor) this.assert(eql(descriptor, actualDescriptor), "expected the own property descriptor for " + inspect2(name) + " on #{this} to match " + inspect2(descriptor) + ", got " + inspect2(actualDescriptor), "expected the own property descriptor for " + inspect2(name) + " on #{this} to not match " + inspect2(descriptor), descriptor, actualDescriptor, true);
    else this.assert(actualDescriptor, "expected #{this} to have an own property descriptor for " + inspect2(name), "expected #{this} to not have an own property descriptor for " + inspect2(name));
    flag2(this, "object", actualDescriptor);
}
__name(assertOwnPropertyDescriptor, "assertOwnPropertyDescriptor");
Assertion.addMethod("ownPropertyDescriptor", assertOwnPropertyDescriptor);
Assertion.addMethod("haveOwnPropertyDescriptor", assertOwnPropertyDescriptor);
function assertLengthChain() {
    flag2(this, "doLength", true);
}
__name(assertLengthChain, "assertLengthChain");
function assertLength(n, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), objType = chai_type(obj).toLowerCase(), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), descriptor = "length", itemsCount;
    switch(objType){
        case "map":
        case "set":
            descriptor = "size";
            itemsCount = obj.size;
            break;
        default:
            new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
            itemsCount = obj.length;
    }
    this.assert(itemsCount == n, "expected #{this} to have a " + descriptor + " of #{exp} but got #{act}", "expected #{this} to not have a " + descriptor + " of #{act}", n, itemsCount);
}
__name(assertLength, "assertLength");
Assertion.addChainableMethod("length", assertLength, assertLengthChain);
Assertion.addChainableMethod("lengthOf", assertLength, assertLengthChain);
function assertMatch(re, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object");
    this.assert(re.exec(obj), "expected #{this} to match " + re, "expected #{this} not to match " + re);
}
__name(assertMatch, "assertMatch");
Assertion.addMethod("match", assertMatch);
Assertion.addMethod("matches", assertMatch);
Assertion.addMethod("string", function(str, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
    new Assertion(obj, flagMsg, ssfi, true).is.a("string");
    this.assert(~obj.indexOf(str), "expected #{this} to contain " + inspect2(str), "expected #{this} to not contain " + inspect2(str));
});
function assertKeys(keys) {
    let obj = flag2(this, "object"), objType = chai_type(obj), keysType = chai_type(keys), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), str, deepStr = "", actual, ok = true, flagMsg = flag2(this, "message");
    flagMsg = flagMsg ? flagMsg + ": " : "";
    let mixedArgsMsg = flagMsg + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
    if ("Map" === objType || "Set" === objType) {
        deepStr = isDeep ? "deeply " : "";
        actual = [];
        obj.forEach(function(val, key) {
            actual.push(key);
        });
        if ("Array" !== keysType) keys = Array.prototype.slice.call(arguments);
    } else {
        actual = getOwnEnumerableProperties(obj);
        switch(keysType){
            case "Array":
                if (arguments.length > 1) throw new chai_AssertionError(mixedArgsMsg, void 0, ssfi);
                break;
            case "Object":
                if (arguments.length > 1) throw new chai_AssertionError(mixedArgsMsg, void 0, ssfi);
                keys = Object.keys(keys);
                break;
            default:
                keys = Array.prototype.slice.call(arguments);
        }
        keys = keys.map(function(val) {
            return "symbol" == typeof val ? val : String(val);
        });
    }
    if (!keys.length) throw new chai_AssertionError(flagMsg + "keys required", void 0, ssfi);
    let len = keys.length, any = flag2(this, "any"), all = flag2(this, "all"), expected = keys, isEql = isDeep ? flag2(this, "eql") : (val1, val2)=>val1 === val2;
    if (!any && !all) all = true;
    if (any) ok = expected.some(function(expectedKey) {
        return actual.some(function(actualKey) {
            return isEql(expectedKey, actualKey);
        });
    });
    if (all) {
        ok = expected.every(function(expectedKey) {
            return actual.some(function(actualKey) {
                return isEql(expectedKey, actualKey);
            });
        });
        if (!flag2(this, "contains")) ok = ok && keys.length == actual.length;
    }
    if (len > 1) {
        keys = keys.map(function(key) {
            return inspect2(key);
        });
        let last = keys.pop();
        if (all) str = keys.join(", ") + ", and " + last;
        if (any) str = keys.join(", ") + ", or " + last;
    } else str = inspect2(keys[0]);
    str = (len > 1 ? "keys " : "key ") + str;
    str = (flag2(this, "contains") ? "contain " : "have ") + str;
    this.assert(ok, "expected #{this} to " + deepStr + str, "expected #{this} to not " + deepStr + str, expected.slice(0).sort(compareByInspect), actual.sort(compareByInspect), true);
}
__name(assertKeys, "assertKeys");
Assertion.addMethod("keys", assertKeys);
Assertion.addMethod("key", assertKeys);
function assertThrows(errorLike, errMsgMatcher, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), negate = flag2(this, "negate") || false;
    new Assertion(obj, flagMsg, ssfi, true).is.a("function");
    if (isRegExp2(errorLike) || "string" == typeof errorLike) {
        errMsgMatcher = errorLike;
        errorLike = null;
    }
    let caughtErr;
    let errorWasThrown = false;
    try {
        obj();
    } catch (err) {
        errorWasThrown = true;
        caughtErr = err;
    }
    let everyArgIsUndefined = void 0 === errorLike && void 0 === errMsgMatcher;
    let everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
    let errorLikeFail = false;
    let errMsgMatcherFail = false;
    if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
        let errorLikeString = "an error";
        if (errorLike instanceof Error) errorLikeString = "#{exp}";
        else if (errorLike) errorLikeString = check_error_exports.getConstructorName(errorLike);
        let actual = caughtErr;
        if (caughtErr instanceof Error) actual = caughtErr.toString();
        else if ("string" == typeof caughtErr) actual = caughtErr;
        else if (caughtErr && ("object" == typeof caughtErr || "function" == typeof caughtErr)) try {
            actual = check_error_exports.getConstructorName(caughtErr);
        } catch (_err) {}
        this.assert(errorWasThrown, "expected #{this} to throw " + errorLikeString, "expected #{this} to not throw an error but #{act} was thrown", errorLike && errorLike.toString(), actual);
    }
    if (errorLike && caughtErr) {
        if (errorLike instanceof Error) {
            let isCompatibleInstance = check_error_exports.compatibleInstance(caughtErr, errorLike);
            if (isCompatibleInstance === negate) if (everyArgIsDefined && negate) errorLikeFail = true;
            else this.assert(negate, "expected #{this} to throw #{exp} but #{act} was thrown", "expected #{this} to not throw #{exp}" + (caughtErr && !negate ? " but #{act} was thrown" : ""), errorLike.toString(), caughtErr.toString());
        }
        let isCompatibleConstructor = check_error_exports.compatibleConstructor(caughtErr, errorLike);
        if (isCompatibleConstructor === negate) if (everyArgIsDefined && negate) errorLikeFail = true;
        else this.assert(negate, "expected #{this} to throw #{exp} but #{act} was thrown", "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""), errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr));
    }
    if (caughtErr && null != errMsgMatcher) {
        let placeholder = "including";
        if (isRegExp2(errMsgMatcher)) placeholder = "matching";
        let isCompatibleMessage = check_error_exports.compatibleMessage(caughtErr, errMsgMatcher);
        if (isCompatibleMessage === negate) if (everyArgIsDefined && negate) errMsgMatcherFail = true;
        else this.assert(negate, "expected #{this} to throw error " + placeholder + " #{exp} but got #{act}", "expected #{this} to throw error not " + placeholder + " #{exp}", errMsgMatcher, check_error_exports.getMessage(caughtErr));
    }
    if (errorLikeFail && errMsgMatcherFail) this.assert(negate, "expected #{this} to throw #{exp} but #{act} was thrown", "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""), errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr));
    flag2(this, "object", caughtErr);
}
__name(assertThrows, "assertThrows");
Assertion.addMethod("throw", assertThrows);
Assertion.addMethod("throws", assertThrows);
Assertion.addMethod("Throw", assertThrows);
function respondTo(method, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), itself = flag2(this, "itself"), context = "function" != typeof obj || itself ? obj[method] : obj.prototype[method];
    this.assert("function" == typeof context, "expected #{this} to respond to " + inspect2(method), "expected #{this} to not respond to " + inspect2(method));
}
__name(respondTo, "respondTo");
Assertion.addMethod("respondTo", respondTo);
Assertion.addMethod("respondsTo", respondTo);
Assertion.addProperty("itself", function() {
    flag2(this, "itself", true);
});
function satisfy(matcher, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object");
    let result = matcher(obj);
    this.assert(result, "expected #{this} to satisfy " + chai_objDisplay(matcher), "expected #{this} to not satisfy" + chai_objDisplay(matcher), !flag2(this, "negate"), result);
}
__name(satisfy, "satisfy");
Assertion.addMethod("satisfy", satisfy);
Assertion.addMethod("satisfies", satisfy);
function closeTo(expected, delta, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
    new Assertion(obj, flagMsg, ssfi, true).is.numeric;
    let message = "A `delta` value is required for `closeTo`";
    if (void 0 == delta) throw new chai_AssertionError(flagMsg ? `${flagMsg}: ${message}` : message, void 0, ssfi);
    new Assertion(delta, flagMsg, ssfi, true).is.numeric;
    message = "A `expected` value is required for `closeTo`";
    if (void 0 == expected) throw new chai_AssertionError(flagMsg ? `${flagMsg}: ${message}` : message, void 0, ssfi);
    new Assertion(expected, flagMsg, ssfi, true).is.numeric;
    const abs = /* @__PURE__ */ __name((x)=>x < 0n ? -x : x, "abs");
    const strip = /* @__PURE__ */ __name((number)=>parseFloat(parseFloat(number).toPrecision(12)), "strip");
    this.assert(strip(abs(obj - expected)) <= delta, "expected #{this} to be close to " + expected + " +/- " + delta, "expected #{this} not to be close to " + expected + " +/- " + delta);
}
__name(closeTo, "closeTo");
Assertion.addMethod("closeTo", closeTo);
Assertion.addMethod("approximately", closeTo);
function isSubsetOf(_subset, _superset, cmp, contains, ordered) {
    let superset = Array.from(_superset);
    let subset = Array.from(_subset);
    if (!contains) {
        if (subset.length !== superset.length) return false;
        superset = superset.slice();
    }
    return subset.every(function(elem, idx) {
        if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];
        if (!cmp) {
            let matchIdx = superset.indexOf(elem);
            if (-1 === matchIdx) return false;
            if (!contains) superset.splice(matchIdx, 1);
            return true;
        }
        return superset.some(function(elem2, matchIdx) {
            if (!cmp(elem, elem2)) return false;
            if (!contains) superset.splice(matchIdx, 1);
            return true;
        });
    });
}
__name(isSubsetOf, "isSubsetOf");
Assertion.addMethod("members", function(subset, msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
    new Assertion(obj, flagMsg, ssfi, true).to.be.iterable;
    new Assertion(subset, flagMsg, ssfi, true).to.be.iterable;
    let contains = flag2(this, "contains");
    let ordered = flag2(this, "ordered");
    let subject, failMsg, failNegateMsg;
    if (contains) {
        subject = ordered ? "an ordered superset" : "a superset";
        failMsg = "expected #{this} to be " + subject + " of #{exp}";
        failNegateMsg = "expected #{this} to not be " + subject + " of #{exp}";
    } else {
        subject = ordered ? "ordered members" : "members";
        failMsg = "expected #{this} to have the same " + subject + " as #{exp}";
        failNegateMsg = "expected #{this} to not have the same " + subject + " as #{exp}";
    }
    let cmp = flag2(this, "deep") ? flag2(this, "eql") : void 0;
    this.assert(isSubsetOf(subset, obj, cmp, contains, ordered), failMsg, failNegateMsg, subset, obj, true);
});
Assertion.addProperty("iterable", function(msg) {
    if (msg) flag2(this, "message", msg);
    let obj = flag2(this, "object");
    this.assert(void 0 != obj && obj[Symbol.iterator], "expected #{this} to be an iterable", "expected #{this} to not be an iterable", obj);
});
function oneOf(list, msg) {
    if (msg) flag2(this, "message", msg);
    let expected = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), contains = flag2(this, "contains"), isDeep = flag2(this, "deep"), eql = flag2(this, "eql");
    new Assertion(list, flagMsg, ssfi, true).to.be.an("array");
    if (contains) this.assert(list.some(function(possibility) {
        return expected.indexOf(possibility) > -1;
    }), "expected #{this} to contain one of #{exp}", "expected #{this} to not contain one of #{exp}", list, expected);
    else if (isDeep) this.assert(list.some(function(possibility) {
        return eql(expected, possibility);
    }), "expected #{this} to deeply equal one of #{exp}", "expected #{this} to deeply equal one of #{exp}", list, expected);
    else this.assert(list.indexOf(expected) > -1, "expected #{this} to be one of #{exp}", "expected #{this} to not be one of #{exp}", list, expected);
}
__name(oneOf, "oneOf");
Assertion.addMethod("oneOf", oneOf);
function assertChanges(subject, prop, msg) {
    if (msg) flag2(this, "message", msg);
    let fn = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
    new Assertion(fn, flagMsg, ssfi, true).is.a("function");
    let initial;
    if (prop) {
        new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
        initial = subject[prop];
    } else {
        new Assertion(subject, flagMsg, ssfi, true).is.a("function");
        initial = subject();
    }
    fn();
    let final = null == prop ? subject() : subject[prop];
    let msgObj = null == prop ? initial : "." + prop;
    flag2(this, "deltaMsgObj", msgObj);
    flag2(this, "initialDeltaValue", initial);
    flag2(this, "finalDeltaValue", final);
    flag2(this, "deltaBehavior", "change");
    flag2(this, "realDelta", final !== initial);
    this.assert(initial !== final, "expected " + msgObj + " to change", "expected " + msgObj + " to not change");
}
__name(assertChanges, "assertChanges");
Assertion.addMethod("change", assertChanges);
Assertion.addMethod("changes", assertChanges);
function assertIncreases(subject, prop, msg) {
    if (msg) flag2(this, "message", msg);
    let fn = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
    new Assertion(fn, flagMsg, ssfi, true).is.a("function");
    let initial;
    if (prop) {
        new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
        initial = subject[prop];
    } else {
        new Assertion(subject, flagMsg, ssfi, true).is.a("function");
        initial = subject();
    }
    new Assertion(initial, flagMsg, ssfi, true).is.a("number");
    fn();
    let final = null == prop ? subject() : subject[prop];
    let msgObj = null == prop ? initial : "." + prop;
    flag2(this, "deltaMsgObj", msgObj);
    flag2(this, "initialDeltaValue", initial);
    flag2(this, "finalDeltaValue", final);
    flag2(this, "deltaBehavior", "increase");
    flag2(this, "realDelta", final - initial);
    this.assert(final - initial > 0, "expected " + msgObj + " to increase", "expected " + msgObj + " to not increase");
}
__name(assertIncreases, "assertIncreases");
Assertion.addMethod("increase", assertIncreases);
Assertion.addMethod("increases", assertIncreases);
function assertDecreases(subject, prop, msg) {
    if (msg) flag2(this, "message", msg);
    let fn = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
    new Assertion(fn, flagMsg, ssfi, true).is.a("function");
    let initial;
    if (prop) {
        new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
        initial = subject[prop];
    } else {
        new Assertion(subject, flagMsg, ssfi, true).is.a("function");
        initial = subject();
    }
    new Assertion(initial, flagMsg, ssfi, true).is.a("number");
    fn();
    let final = null == prop ? subject() : subject[prop];
    let msgObj = null == prop ? initial : "." + prop;
    flag2(this, "deltaMsgObj", msgObj);
    flag2(this, "initialDeltaValue", initial);
    flag2(this, "finalDeltaValue", final);
    flag2(this, "deltaBehavior", "decrease");
    flag2(this, "realDelta", initial - final);
    this.assert(final - initial < 0, "expected " + msgObj + " to decrease", "expected " + msgObj + " to not decrease");
}
__name(assertDecreases, "assertDecreases");
Assertion.addMethod("decrease", assertDecreases);
Assertion.addMethod("decreases", assertDecreases);
function assertDelta(delta, msg) {
    if (msg) flag2(this, "message", msg);
    let msgObj = flag2(this, "deltaMsgObj");
    let initial = flag2(this, "initialDeltaValue");
    let final = flag2(this, "finalDeltaValue");
    let behavior = flag2(this, "deltaBehavior");
    let realDelta = flag2(this, "realDelta");
    let expression;
    expression = "change" === behavior ? Math.abs(final - initial) === Math.abs(delta) : realDelta === Math.abs(delta);
    this.assert(expression, "expected " + msgObj + " to " + behavior + " by " + delta, "expected " + msgObj + " to not " + behavior + " by " + delta);
}
__name(assertDelta, "assertDelta");
Assertion.addMethod("by", assertDelta);
Assertion.addProperty("extensible", function() {
    let obj = flag2(this, "object");
    let isExtensible = obj === Object(obj) && Object.isExtensible(obj);
    this.assert(isExtensible, "expected #{this} to be extensible", "expected #{this} to not be extensible");
});
Assertion.addProperty("sealed", function() {
    let obj = flag2(this, "object");
    let isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;
    this.assert(isSealed, "expected #{this} to be sealed", "expected #{this} to not be sealed");
});
Assertion.addProperty("frozen", function() {
    let obj = flag2(this, "object");
    let isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;
    this.assert(isFrozen, "expected #{this} to be frozen", "expected #{this} to not be frozen");
});
Assertion.addProperty("finite", function(_msg) {
    let obj = flag2(this, "object");
    this.assert("number" == typeof obj && isFinite(obj), "expected #{this} to be a finite number", "expected #{this} to not be a finite number");
});
function compareSubset(expected, actual) {
    if (expected === actual) return true;
    if (typeof actual !== typeof expected) return false;
    if ("object" != typeof expected || null === expected) return expected === actual;
    if (!actual) return false;
    if (Array.isArray(expected)) {
        if (!Array.isArray(actual)) return false;
        return expected.every(function(exp) {
            return actual.some(function(act) {
                return compareSubset(exp, act);
            });
        });
    }
    if (expected instanceof Date) if (actual instanceof Date) return expected.getTime() === actual.getTime();
    else return false;
    return Object.keys(expected).every(function(key) {
        let expectedValue = expected[key];
        let actualValue = actual[key];
        if ("object" == typeof expectedValue && null !== expectedValue && null !== actualValue) return compareSubset(expectedValue, actualValue);
        if ("function" == typeof expectedValue) return expectedValue(actualValue);
        return actualValue === expectedValue;
    });
}
__name(compareSubset, "compareSubset");
Assertion.addMethod("containSubset", function(expected) {
    const actual = flag(this, "object");
    const showDiff = chai_config.showDiff;
    this.assert(compareSubset(expected, actual), "expected #{act} to contain subset #{exp}", "expected #{act} to not contain subset #{exp}", expected, actual, showDiff);
});
function chai_expect(val, message) {
    return new Assertion(val, message);
}
__name(chai_expect, "expect");
chai_expect.fail = function(actual, expected, message, operator) {
    if (arguments.length < 2) {
        message = actual;
        actual = void 0;
    }
    message = message || "expect.fail()";
    throw new chai_AssertionError(message, {
        actual,
        expected,
        operator
    }, chai_expect.fail);
};
var should_exports = {};
__export(should_exports, {
    Should: ()=>Should,
    should: ()=>should
});
function loadShould() {
    function shouldGetter() {
        if (this instanceof String || this instanceof Number || this instanceof Boolean || "function" == typeof Symbol && this instanceof Symbol || "function" == typeof BigInt && this instanceof BigInt) return new Assertion(this.valueOf(), null, shouldGetter);
        return new Assertion(this, null, shouldGetter);
    }
    __name(shouldGetter, "shouldGetter");
    function shouldSetter(value) {
        Object.defineProperty(this, "should", {
            value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    }
    __name(shouldSetter, "shouldSetter");
    Object.defineProperty(Object.prototype, "should", {
        set: shouldSetter,
        get: shouldGetter,
        configurable: true
    });
    let should2 = {};
    should2.fail = function(actual, expected, message, operator) {
        if (arguments.length < 2) {
            message = actual;
            actual = void 0;
        }
        message = message || "should.fail()";
        throw new chai_AssertionError(message, {
            actual,
            expected,
            operator
        }, should2.fail);
    };
    should2.equal = function(actual, expected, message) {
        new Assertion(actual, message).to.equal(expected);
    };
    should2.Throw = function(fn, errt, errs, msg) {
        new Assertion(fn, msg).to.Throw(errt, errs);
    };
    should2.exist = function(val, msg) {
        new Assertion(val, msg).to.exist;
    };
    should2.not = {};
    should2.not.equal = function(actual, expected, msg) {
        new Assertion(actual, msg).to.not.equal(expected);
    };
    should2.not.Throw = function(fn, errt, errs, msg) {
        new Assertion(fn, msg).to.not.Throw(errt, errs);
    };
    should2.not.exist = function(val, msg) {
        new Assertion(val, msg).to.not.exist;
    };
    should2["throw"] = should2["Throw"];
    should2.not["throw"] = should2.not["Throw"];
    return should2;
}
__name(loadShould, "loadShould");
var should = loadShould;
var Should = loadShould;
function chai_assert(express, errmsg) {
    let test2 = new Assertion(null, null, chai_assert, true);
    test2.assert(express, errmsg, "[ negation message unavailable ]");
}
__name(chai_assert, "assert");
chai_assert.fail = function(actual, expected, message, operator) {
    if (arguments.length < 2) {
        message = actual;
        actual = void 0;
    }
    message = message || "assert.fail()";
    throw new chai_AssertionError(message, {
        actual,
        expected,
        operator
    }, chai_assert.fail);
};
chai_assert.isOk = function(val, msg) {
    new Assertion(val, msg, chai_assert.isOk, true).is.ok;
};
chai_assert.isNotOk = function(val, msg) {
    new Assertion(val, msg, chai_assert.isNotOk, true).is.not.ok;
};
chai_assert.equal = function(act, exp, msg) {
    let test2 = new Assertion(act, msg, chai_assert.equal, true);
    test2.assert(exp == flag(test2, "object"), "expected #{this} to equal #{exp}", "expected #{this} to not equal #{act}", exp, act, true);
};
chai_assert.notEqual = function(act, exp, msg) {
    let test2 = new Assertion(act, msg, chai_assert.notEqual, true);
    test2.assert(exp != flag(test2, "object"), "expected #{this} to not equal #{exp}", "expected #{this} to equal #{act}", exp, act, true);
};
chai_assert.strictEqual = function(act, exp, msg) {
    new Assertion(act, msg, chai_assert.strictEqual, true).to.equal(exp);
};
chai_assert.notStrictEqual = function(act, exp, msg) {
    new Assertion(act, msg, chai_assert.notStrictEqual, true).to.not.equal(exp);
};
chai_assert.deepEqual = chai_assert.deepStrictEqual = function(act, exp, msg) {
    new Assertion(act, msg, chai_assert.deepEqual, true).to.eql(exp);
};
chai_assert.notDeepEqual = function(act, exp, msg) {
    new Assertion(act, msg, chai_assert.notDeepEqual, true).to.not.eql(exp);
};
chai_assert.isAbove = function(val, abv, msg) {
    new Assertion(val, msg, chai_assert.isAbove, true).to.be.above(abv);
};
chai_assert.isAtLeast = function(val, atlst, msg) {
    new Assertion(val, msg, chai_assert.isAtLeast, true).to.be.least(atlst);
};
chai_assert.isBelow = function(val, blw, msg) {
    new Assertion(val, msg, chai_assert.isBelow, true).to.be.below(blw);
};
chai_assert.isAtMost = function(val, atmst, msg) {
    new Assertion(val, msg, chai_assert.isAtMost, true).to.be.most(atmst);
};
chai_assert.isTrue = function(val, msg) {
    new Assertion(val, msg, chai_assert.isTrue, true).is["true"];
};
chai_assert.isNotTrue = function(val, msg) {
    new Assertion(val, msg, chai_assert.isNotTrue, true).to.not.equal(true);
};
chai_assert.isFalse = function(val, msg) {
    new Assertion(val, msg, chai_assert.isFalse, true).is["false"];
};
chai_assert.isNotFalse = function(val, msg) {
    new Assertion(val, msg, chai_assert.isNotFalse, true).to.not.equal(false);
};
chai_assert.isNull = function(val, msg) {
    new Assertion(val, msg, chai_assert.isNull, true).to.equal(null);
};
chai_assert.isNotNull = function(val, msg) {
    new Assertion(val, msg, chai_assert.isNotNull, true).to.not.equal(null);
};
chai_assert.isNaN = function(val, msg) {
    new Assertion(val, msg, chai_assert.isNaN, true).to.be.NaN;
};
chai_assert.isNotNaN = function(value, message) {
    new Assertion(value, message, chai_assert.isNotNaN, true).not.to.be.NaN;
};
chai_assert.exists = function(val, msg) {
    new Assertion(val, msg, chai_assert.exists, true).to.exist;
};
chai_assert.notExists = function(val, msg) {
    new Assertion(val, msg, chai_assert.notExists, true).to.not.exist;
};
chai_assert.isUndefined = function(val, msg) {
    new Assertion(val, msg, chai_assert.isUndefined, true).to.equal(void 0);
};
chai_assert.isDefined = function(val, msg) {
    new Assertion(val, msg, chai_assert.isDefined, true).to.not.equal(void 0);
};
chai_assert.isCallable = function(value, message) {
    new Assertion(value, message, chai_assert.isCallable, true).is.callable;
};
chai_assert.isNotCallable = function(value, message) {
    new Assertion(value, message, chai_assert.isNotCallable, true).is.not.callable;
};
chai_assert.isObject = function(val, msg) {
    new Assertion(val, msg, chai_assert.isObject, true).to.be.a("object");
};
chai_assert.isNotObject = function(val, msg) {
    new Assertion(val, msg, chai_assert.isNotObject, true).to.not.be.a("object");
};
chai_assert.isArray = function(val, msg) {
    new Assertion(val, msg, chai_assert.isArray, true).to.be.an("array");
};
chai_assert.isNotArray = function(val, msg) {
    new Assertion(val, msg, chai_assert.isNotArray, true).to.not.be.an("array");
};
chai_assert.isString = function(val, msg) {
    new Assertion(val, msg, chai_assert.isString, true).to.be.a("string");
};
chai_assert.isNotString = function(val, msg) {
    new Assertion(val, msg, chai_assert.isNotString, true).to.not.be.a("string");
};
chai_assert.isNumber = function(val, msg) {
    new Assertion(val, msg, chai_assert.isNumber, true).to.be.a("number");
};
chai_assert.isNotNumber = function(val, msg) {
    new Assertion(val, msg, chai_assert.isNotNumber, true).to.not.be.a("number");
};
chai_assert.isNumeric = function(val, msg) {
    new Assertion(val, msg, chai_assert.isNumeric, true).is.numeric;
};
chai_assert.isNotNumeric = function(val, msg) {
    new Assertion(val, msg, chai_assert.isNotNumeric, true).is.not.numeric;
};
chai_assert.isFinite = function(val, msg) {
    new Assertion(val, msg, chai_assert.isFinite, true).to.be.finite;
};
chai_assert.isBoolean = function(val, msg) {
    new Assertion(val, msg, chai_assert.isBoolean, true).to.be.a("boolean");
};
chai_assert.isNotBoolean = function(val, msg) {
    new Assertion(val, msg, chai_assert.isNotBoolean, true).to.not.be.a("boolean");
};
chai_assert.typeOf = function(val, type3, msg) {
    new Assertion(val, msg, chai_assert.typeOf, true).to.be.a(type3);
};
chai_assert.notTypeOf = function(value, type3, message) {
    new Assertion(value, message, chai_assert.notTypeOf, true).to.not.be.a(type3);
};
chai_assert.instanceOf = function(val, type3, msg) {
    new Assertion(val, msg, chai_assert.instanceOf, true).to.be.instanceOf(type3);
};
chai_assert.notInstanceOf = function(val, type3, msg) {
    new Assertion(val, msg, chai_assert.notInstanceOf, true).to.not.be.instanceOf(type3);
};
chai_assert.include = function(exp, inc, msg) {
    new Assertion(exp, msg, chai_assert.include, true).include(inc);
};
chai_assert.notInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, chai_assert.notInclude, true).not.include(inc);
};
chai_assert.deepInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, chai_assert.deepInclude, true).deep.include(inc);
};
chai_assert.notDeepInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, chai_assert.notDeepInclude, true).not.deep.include(inc);
};
chai_assert.nestedInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, chai_assert.nestedInclude, true).nested.include(inc);
};
chai_assert.notNestedInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, chai_assert.notNestedInclude, true).not.nested.include(inc);
};
chai_assert.deepNestedInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, chai_assert.deepNestedInclude, true).deep.nested.include(inc);
};
chai_assert.notDeepNestedInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, chai_assert.notDeepNestedInclude, true).not.deep.nested.include(inc);
};
chai_assert.ownInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, chai_assert.ownInclude, true).own.include(inc);
};
chai_assert.notOwnInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, chai_assert.notOwnInclude, true).not.own.include(inc);
};
chai_assert.deepOwnInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, chai_assert.deepOwnInclude, true).deep.own.include(inc);
};
chai_assert.notDeepOwnInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, chai_assert.notDeepOwnInclude, true).not.deep.own.include(inc);
};
chai_assert.match = function(exp, re, msg) {
    new Assertion(exp, msg, chai_assert.match, true).to.match(re);
};
chai_assert.notMatch = function(exp, re, msg) {
    new Assertion(exp, msg, chai_assert.notMatch, true).to.not.match(re);
};
chai_assert.property = function(obj, prop, msg) {
    new Assertion(obj, msg, chai_assert.property, true).to.have.property(prop);
};
chai_assert.notProperty = function(obj, prop, msg) {
    new Assertion(obj, msg, chai_assert.notProperty, true).to.not.have.property(prop);
};
chai_assert.propertyVal = function(obj, prop, val, msg) {
    new Assertion(obj, msg, chai_assert.propertyVal, true).to.have.property(prop, val);
};
chai_assert.notPropertyVal = function(obj, prop, val, msg) {
    new Assertion(obj, msg, chai_assert.notPropertyVal, true).to.not.have.property(prop, val);
};
chai_assert.deepPropertyVal = function(obj, prop, val, msg) {
    new Assertion(obj, msg, chai_assert.deepPropertyVal, true).to.have.deep.property(prop, val);
};
chai_assert.notDeepPropertyVal = function(obj, prop, val, msg) {
    new Assertion(obj, msg, chai_assert.notDeepPropertyVal, true).to.not.have.deep.property(prop, val);
};
chai_assert.ownProperty = function(obj, prop, msg) {
    new Assertion(obj, msg, chai_assert.ownProperty, true).to.have.own.property(prop);
};
chai_assert.notOwnProperty = function(obj, prop, msg) {
    new Assertion(obj, msg, chai_assert.notOwnProperty, true).to.not.have.own.property(prop);
};
chai_assert.ownPropertyVal = function(obj, prop, value, msg) {
    new Assertion(obj, msg, chai_assert.ownPropertyVal, true).to.have.own.property(prop, value);
};
chai_assert.notOwnPropertyVal = function(obj, prop, value, msg) {
    new Assertion(obj, msg, chai_assert.notOwnPropertyVal, true).to.not.have.own.property(prop, value);
};
chai_assert.deepOwnPropertyVal = function(obj, prop, value, msg) {
    new Assertion(obj, msg, chai_assert.deepOwnPropertyVal, true).to.have.deep.own.property(prop, value);
};
chai_assert.notDeepOwnPropertyVal = function(obj, prop, value, msg) {
    new Assertion(obj, msg, chai_assert.notDeepOwnPropertyVal, true).to.not.have.deep.own.property(prop, value);
};
chai_assert.nestedProperty = function(obj, prop, msg) {
    new Assertion(obj, msg, chai_assert.nestedProperty, true).to.have.nested.property(prop);
};
chai_assert.notNestedProperty = function(obj, prop, msg) {
    new Assertion(obj, msg, chai_assert.notNestedProperty, true).to.not.have.nested.property(prop);
};
chai_assert.nestedPropertyVal = function(obj, prop, val, msg) {
    new Assertion(obj, msg, chai_assert.nestedPropertyVal, true).to.have.nested.property(prop, val);
};
chai_assert.notNestedPropertyVal = function(obj, prop, val, msg) {
    new Assertion(obj, msg, chai_assert.notNestedPropertyVal, true).to.not.have.nested.property(prop, val);
};
chai_assert.deepNestedPropertyVal = function(obj, prop, val, msg) {
    new Assertion(obj, msg, chai_assert.deepNestedPropertyVal, true).to.have.deep.nested.property(prop, val);
};
chai_assert.notDeepNestedPropertyVal = function(obj, prop, val, msg) {
    new Assertion(obj, msg, chai_assert.notDeepNestedPropertyVal, true).to.not.have.deep.nested.property(prop, val);
};
chai_assert.lengthOf = function(exp, len, msg) {
    new Assertion(exp, msg, chai_assert.lengthOf, true).to.have.lengthOf(len);
};
chai_assert.hasAnyKeys = function(obj, keys, msg) {
    new Assertion(obj, msg, chai_assert.hasAnyKeys, true).to.have.any.keys(keys);
};
chai_assert.hasAllKeys = function(obj, keys, msg) {
    new Assertion(obj, msg, chai_assert.hasAllKeys, true).to.have.all.keys(keys);
};
chai_assert.containsAllKeys = function(obj, keys, msg) {
    new Assertion(obj, msg, chai_assert.containsAllKeys, true).to.contain.all.keys(keys);
};
chai_assert.doesNotHaveAnyKeys = function(obj, keys, msg) {
    new Assertion(obj, msg, chai_assert.doesNotHaveAnyKeys, true).to.not.have.any.keys(keys);
};
chai_assert.doesNotHaveAllKeys = function(obj, keys, msg) {
    new Assertion(obj, msg, chai_assert.doesNotHaveAllKeys, true).to.not.have.all.keys(keys);
};
chai_assert.hasAnyDeepKeys = function(obj, keys, msg) {
    new Assertion(obj, msg, chai_assert.hasAnyDeepKeys, true).to.have.any.deep.keys(keys);
};
chai_assert.hasAllDeepKeys = function(obj, keys, msg) {
    new Assertion(obj, msg, chai_assert.hasAllDeepKeys, true).to.have.all.deep.keys(keys);
};
chai_assert.containsAllDeepKeys = function(obj, keys, msg) {
    new Assertion(obj, msg, chai_assert.containsAllDeepKeys, true).to.contain.all.deep.keys(keys);
};
chai_assert.doesNotHaveAnyDeepKeys = function(obj, keys, msg) {
    new Assertion(obj, msg, chai_assert.doesNotHaveAnyDeepKeys, true).to.not.have.any.deep.keys(keys);
};
chai_assert.doesNotHaveAllDeepKeys = function(obj, keys, msg) {
    new Assertion(obj, msg, chai_assert.doesNotHaveAllDeepKeys, true).to.not.have.all.deep.keys(keys);
};
chai_assert.throws = function(fn, errorLike, errMsgMatcher, msg) {
    if ("string" == typeof errorLike || errorLike instanceof RegExp) {
        errMsgMatcher = errorLike;
        errorLike = null;
    }
    let assertErr = new Assertion(fn, msg, chai_assert.throws, true).to.throw(errorLike, errMsgMatcher);
    return flag(assertErr, "object");
};
chai_assert.doesNotThrow = function(fn, errorLike, errMsgMatcher, message) {
    if ("string" == typeof errorLike || errorLike instanceof RegExp) {
        errMsgMatcher = errorLike;
        errorLike = null;
    }
    new Assertion(fn, message, chai_assert.doesNotThrow, true).to.not.throw(errorLike, errMsgMatcher);
};
chai_assert.operator = function(val, operator, val2, msg) {
    let ok;
    switch(operator){
        case "==":
            ok = val == val2;
            break;
        case "===":
            ok = val === val2;
            break;
        case ">":
            ok = val > val2;
            break;
        case ">=":
            ok = val >= val2;
            break;
        case "<":
            ok = val < val2;
            break;
        case "<=":
            ok = val <= val2;
            break;
        case "!=":
            ok = val != val2;
            break;
        case "!==":
            ok = val !== val2;
            break;
        default:
            msg = msg ? msg + ": " : msg;
            throw new chai_AssertionError(msg + 'Invalid operator "' + operator + '"', void 0, chai_assert.operator);
    }
    let test2 = new Assertion(ok, msg, chai_assert.operator, true);
    test2.assert(true === flag(test2, "object"), "expected " + inspect2(val) + " to be " + operator + " " + inspect2(val2), "expected " + inspect2(val) + " to not be " + operator + " " + inspect2(val2));
};
chai_assert.closeTo = function(act, exp, delta, msg) {
    new Assertion(act, msg, chai_assert.closeTo, true).to.be.closeTo(exp, delta);
};
chai_assert.approximately = function(act, exp, delta, msg) {
    new Assertion(act, msg, chai_assert.approximately, true).to.be.approximately(exp, delta);
};
chai_assert.sameMembers = function(set1, set2, msg) {
    new Assertion(set1, msg, chai_assert.sameMembers, true).to.have.same.members(set2);
};
chai_assert.notSameMembers = function(set1, set2, msg) {
    new Assertion(set1, msg, chai_assert.notSameMembers, true).to.not.have.same.members(set2);
};
chai_assert.sameDeepMembers = function(set1, set2, msg) {
    new Assertion(set1, msg, chai_assert.sameDeepMembers, true).to.have.same.deep.members(set2);
};
chai_assert.notSameDeepMembers = function(set1, set2, msg) {
    new Assertion(set1, msg, chai_assert.notSameDeepMembers, true).to.not.have.same.deep.members(set2);
};
chai_assert.sameOrderedMembers = function(set1, set2, msg) {
    new Assertion(set1, msg, chai_assert.sameOrderedMembers, true).to.have.same.ordered.members(set2);
};
chai_assert.notSameOrderedMembers = function(set1, set2, msg) {
    new Assertion(set1, msg, chai_assert.notSameOrderedMembers, true).to.not.have.same.ordered.members(set2);
};
chai_assert.sameDeepOrderedMembers = function(set1, set2, msg) {
    new Assertion(set1, msg, chai_assert.sameDeepOrderedMembers, true).to.have.same.deep.ordered.members(set2);
};
chai_assert.notSameDeepOrderedMembers = function(set1, set2, msg) {
    new Assertion(set1, msg, chai_assert.notSameDeepOrderedMembers, true).to.not.have.same.deep.ordered.members(set2);
};
chai_assert.includeMembers = function(superset, subset, msg) {
    new Assertion(superset, msg, chai_assert.includeMembers, true).to.include.members(subset);
};
chai_assert.notIncludeMembers = function(superset, subset, msg) {
    new Assertion(superset, msg, chai_assert.notIncludeMembers, true).to.not.include.members(subset);
};
chai_assert.includeDeepMembers = function(superset, subset, msg) {
    new Assertion(superset, msg, chai_assert.includeDeepMembers, true).to.include.deep.members(subset);
};
chai_assert.notIncludeDeepMembers = function(superset, subset, msg) {
    new Assertion(superset, msg, chai_assert.notIncludeDeepMembers, true).to.not.include.deep.members(subset);
};
chai_assert.includeOrderedMembers = function(superset, subset, msg) {
    new Assertion(superset, msg, chai_assert.includeOrderedMembers, true).to.include.ordered.members(subset);
};
chai_assert.notIncludeOrderedMembers = function(superset, subset, msg) {
    new Assertion(superset, msg, chai_assert.notIncludeOrderedMembers, true).to.not.include.ordered.members(subset);
};
chai_assert.includeDeepOrderedMembers = function(superset, subset, msg) {
    new Assertion(superset, msg, chai_assert.includeDeepOrderedMembers, true).to.include.deep.ordered.members(subset);
};
chai_assert.notIncludeDeepOrderedMembers = function(superset, subset, msg) {
    new Assertion(superset, msg, chai_assert.notIncludeDeepOrderedMembers, true).to.not.include.deep.ordered.members(subset);
};
chai_assert.oneOf = function(inList, list, msg) {
    new Assertion(inList, msg, chai_assert.oneOf, true).to.be.oneOf(list);
};
chai_assert.isIterable = function(obj, msg) {
    if (void 0 == obj || !obj[Symbol.iterator]) {
        msg = msg ? `${msg} expected ${inspect2(obj)} to be an iterable` : `expected ${inspect2(obj)} to be an iterable`;
        throw new chai_AssertionError(msg, void 0, chai_assert.isIterable);
    }
};
chai_assert.changes = function(fn, obj, prop, msg) {
    if (3 === arguments.length && "function" == typeof obj) {
        msg = prop;
        prop = null;
    }
    new Assertion(fn, msg, chai_assert.changes, true).to.change(obj, prop);
};
chai_assert.changesBy = function(fn, obj, prop, delta, msg) {
    if (4 === arguments.length && "function" == typeof obj) {
        let tmpMsg = delta;
        delta = prop;
        msg = tmpMsg;
    } else if (3 === arguments.length) {
        delta = prop;
        prop = null;
    }
    new Assertion(fn, msg, chai_assert.changesBy, true).to.change(obj, prop).by(delta);
};
chai_assert.doesNotChange = function(fn, obj, prop, msg) {
    if (3 === arguments.length && "function" == typeof obj) {
        msg = prop;
        prop = null;
    }
    return new Assertion(fn, msg, chai_assert.doesNotChange, true).to.not.change(obj, prop);
};
chai_assert.changesButNotBy = function(fn, obj, prop, delta, msg) {
    if (4 === arguments.length && "function" == typeof obj) {
        let tmpMsg = delta;
        delta = prop;
        msg = tmpMsg;
    } else if (3 === arguments.length) {
        delta = prop;
        prop = null;
    }
    new Assertion(fn, msg, chai_assert.changesButNotBy, true).to.change(obj, prop).but.not.by(delta);
};
chai_assert.increases = function(fn, obj, prop, msg) {
    if (3 === arguments.length && "function" == typeof obj) {
        msg = prop;
        prop = null;
    }
    return new Assertion(fn, msg, chai_assert.increases, true).to.increase(obj, prop);
};
chai_assert.increasesBy = function(fn, obj, prop, delta, msg) {
    if (4 === arguments.length && "function" == typeof obj) {
        let tmpMsg = delta;
        delta = prop;
        msg = tmpMsg;
    } else if (3 === arguments.length) {
        delta = prop;
        prop = null;
    }
    new Assertion(fn, msg, chai_assert.increasesBy, true).to.increase(obj, prop).by(delta);
};
chai_assert.doesNotIncrease = function(fn, obj, prop, msg) {
    if (3 === arguments.length && "function" == typeof obj) {
        msg = prop;
        prop = null;
    }
    return new Assertion(fn, msg, chai_assert.doesNotIncrease, true).to.not.increase(obj, prop);
};
chai_assert.increasesButNotBy = function(fn, obj, prop, delta, msg) {
    if (4 === arguments.length && "function" == typeof obj) {
        let tmpMsg = delta;
        delta = prop;
        msg = tmpMsg;
    } else if (3 === arguments.length) {
        delta = prop;
        prop = null;
    }
    new Assertion(fn, msg, chai_assert.increasesButNotBy, true).to.increase(obj, prop).but.not.by(delta);
};
chai_assert.decreases = function(fn, obj, prop, msg) {
    if (3 === arguments.length && "function" == typeof obj) {
        msg = prop;
        prop = null;
    }
    return new Assertion(fn, msg, chai_assert.decreases, true).to.decrease(obj, prop);
};
chai_assert.decreasesBy = function(fn, obj, prop, delta, msg) {
    if (4 === arguments.length && "function" == typeof obj) {
        let tmpMsg = delta;
        delta = prop;
        msg = tmpMsg;
    } else if (3 === arguments.length) {
        delta = prop;
        prop = null;
    }
    new Assertion(fn, msg, chai_assert.decreasesBy, true).to.decrease(obj, prop).by(delta);
};
chai_assert.doesNotDecrease = function(fn, obj, prop, msg) {
    if (3 === arguments.length && "function" == typeof obj) {
        msg = prop;
        prop = null;
    }
    return new Assertion(fn, msg, chai_assert.doesNotDecrease, true).to.not.decrease(obj, prop);
};
chai_assert.doesNotDecreaseBy = function(fn, obj, prop, delta, msg) {
    if (4 === arguments.length && "function" == typeof obj) {
        let tmpMsg = delta;
        delta = prop;
        msg = tmpMsg;
    } else if (3 === arguments.length) {
        delta = prop;
        prop = null;
    }
    return new Assertion(fn, msg, chai_assert.doesNotDecreaseBy, true).to.not.decrease(obj, prop).by(delta);
};
chai_assert.decreasesButNotBy = function(fn, obj, prop, delta, msg) {
    if (4 === arguments.length && "function" == typeof obj) {
        let tmpMsg = delta;
        delta = prop;
        msg = tmpMsg;
    } else if (3 === arguments.length) {
        delta = prop;
        prop = null;
    }
    new Assertion(fn, msg, chai_assert.decreasesButNotBy, true).to.decrease(obj, prop).but.not.by(delta);
};
chai_assert.ifError = function(val) {
    if (val) throw val;
};
chai_assert.isExtensible = function(obj, msg) {
    new Assertion(obj, msg, chai_assert.isExtensible, true).to.be.extensible;
};
chai_assert.isNotExtensible = function(obj, msg) {
    new Assertion(obj, msg, chai_assert.isNotExtensible, true).to.not.be.extensible;
};
chai_assert.isSealed = function(obj, msg) {
    new Assertion(obj, msg, chai_assert.isSealed, true).to.be.sealed;
};
chai_assert.isNotSealed = function(obj, msg) {
    new Assertion(obj, msg, chai_assert.isNotSealed, true).to.not.be.sealed;
};
chai_assert.isFrozen = function(obj, msg) {
    new Assertion(obj, msg, chai_assert.isFrozen, true).to.be.frozen;
};
chai_assert.isNotFrozen = function(obj, msg) {
    new Assertion(obj, msg, chai_assert.isNotFrozen, true).to.not.be.frozen;
};
chai_assert.isEmpty = function(val, msg) {
    new Assertion(val, msg, chai_assert.isEmpty, true).to.be.empty;
};
chai_assert.isNotEmpty = function(val, msg) {
    new Assertion(val, msg, chai_assert.isNotEmpty, true).to.not.be.empty;
};
chai_assert.containsSubset = function(val, exp, msg) {
    new Assertion(val, msg).to.containSubset(exp);
};
chai_assert.doesNotContainSubset = function(val, exp, msg) {
    new Assertion(val, msg).to.not.containSubset(exp);
};
var aliases = [
    [
        "isOk",
        "ok"
    ],
    [
        "isNotOk",
        "notOk"
    ],
    [
        "throws",
        "throw"
    ],
    [
        "throws",
        "Throw"
    ],
    [
        "isExtensible",
        "extensible"
    ],
    [
        "isNotExtensible",
        "notExtensible"
    ],
    [
        "isSealed",
        "sealed"
    ],
    [
        "isNotSealed",
        "notSealed"
    ],
    [
        "isFrozen",
        "frozen"
    ],
    [
        "isNotFrozen",
        "notFrozen"
    ],
    [
        "isEmpty",
        "empty"
    ],
    [
        "isNotEmpty",
        "notEmpty"
    ],
    [
        "isCallable",
        "isFunction"
    ],
    [
        "isNotCallable",
        "isNotFunction"
    ],
    [
        "containsSubset",
        "containSubset"
    ]
];
for (const [name, as] of aliases)chai_assert[as] = chai_assert[name];
var used = [];
function use(fn) {
    const exports = {
        use: use,
        AssertionError: chai_AssertionError,
        util: utils_exports,
        config: chai_config,
        expect: chai_expect,
        assert: chai_assert,
        Assertion: Assertion,
        ...should_exports
    };
    if (!~used.indexOf(fn)) {
        fn(exports, utils_exports);
        used.push(fn);
    }
    return exports;
}
__name(use, "use");
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */ /*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*! Bundled license information:

deep-eql/index.js:
  (*!
   * deep-eql
   * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Check to see if the MemoizeMap has recorded a result of the two operands
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @returns {Boolean|null} result
  *)
  (*!
   * Set the result of the equality into the MemoizeMap
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @param {Boolean} result
  *)
  (*!
   * Primary Export
   *)
  (*!
   * The main logic of the `deepEqual` function.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (optional) Additional options
   * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
   * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
      complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
      references to blow the stack.
   * @return {Boolean} equal match
  *)
  (*!
   * Compare two Regular Expressions for equality.
   *
   * @param {RegExp} leftHandOperand
   * @param {RegExp} rightHandOperand
   * @return {Boolean} result
   *)
  (*!
   * Compare two Sets/Maps for equality. Faster than other equality functions.
   *
   * @param {Set} leftHandOperand
   * @param {Set} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for generator objects such as those returned by generator functions.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Determine if the given object has an @@iterator function.
   *
   * @param {Object} target
   * @return {Boolean} `true` if the object has an @@iterator function.
   *)
  (*!
   * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
   * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
   *
   * @param {Object} target
   * @returns {Array} an array of entries from the @@iterator function
   *)
  (*!
   * Gets all entries from a Generator. This will consume the generator - which could have side effects.
   *
   * @param {Generator} target
   * @returns {Array} an array of entries from the Generator.
   *)
  (*!
   * Gets all own and inherited enumerable keys from a target.
   *
   * @param {Object} target
   * @returns {Array} an array of own and inherited enumerable keys from the target.
   *)
  (*!
   * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
   * each key. If any value of the given key is not equal, the function will return false (early).
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
   * for each enumerable key in the object.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Returns true if the argument is a primitive.
   *
   * This intentionally returns true for all objects that can be compared by reference,
   * including functions and symbols.
   *
   * @param {Mixed} value
   * @return {Boolean} result
   *)
*/ const MATCHERS_OBJECT = Symbol.for("matchers-object");
const JEST_MATCHERS_OBJECT = Symbol.for("$$jest-matchers-object");
const GLOBAL_EXPECT = Symbol.for("expect-global");
const ASYMMETRIC_MATCHERS_OBJECT = Symbol.for("asymmetric-matchers-object");
const customMatchers = {
    toSatisfy (actual, expected, message) {
        const { printReceived, printExpected, matcherHint } = this.utils;
        const pass = expected(actual);
        return {
            pass,
            message: ()=>pass ? `\
${matcherHint(".not.toSatisfy", "received", "")}

Expected value to not satisfy:
${message || printExpected(expected)}
Received:
${printReceived(actual)}` : `\
${matcherHint(".toSatisfy", "received", "")}

Expected value to satisfy:
${message || printExpected(expected)}

Received:
${printReceived(actual)}`
        };
    },
    toBeOneOf (actual, expected) {
        const { equals, customTesters } = this;
        const { printReceived, printExpected, matcherHint } = this.utils;
        if (!Array.isArray(expected)) throw new TypeError(`You must provide an array to ${matcherHint(".toBeOneOf")}, not '${typeof expected}'.`);
        const pass = 0 === expected.length || expected.some((item)=>equals(item, actual, customTesters));
        return {
            pass,
            message: ()=>pass ? `\
${matcherHint(".not.toBeOneOf", "received", "")}

Expected value to not be one of:
${printExpected(expected)}
Received:
${printReceived(actual)}` : `\
${matcherHint(".toBeOneOf", "received", "")}

Expected value to be one of:
${printExpected(expected)}

Received:
${printReceived(actual)}`
        };
    }
};
const EXPECTED_COLOR = node_u.green;
const RECEIVED_COLOR = node_u.red;
const INVERTED_COLOR = node_u.inverse;
const BOLD_WEIGHT = node_u.bold;
const DIM_COLOR = node_u.dim;
function dist_matcherHint(matcherName, received = "received", expected = "expected", options = {}) {
    const { comment = "", isDirectExpectCall = false, isNot = false, promise = "", secondArgument = "", expectedColor = EXPECTED_COLOR, receivedColor = RECEIVED_COLOR, secondArgumentColor = EXPECTED_COLOR } = options;
    let hint = "";
    let dimString = "expect";
    if (!isDirectExpectCall && "" !== received) {
        hint += DIM_COLOR(`${dimString}(`) + receivedColor(received);
        dimString = ")";
    }
    if ("" !== promise) {
        hint += DIM_COLOR(`${dimString}.`) + promise;
        dimString = "";
    }
    if (isNot) {
        hint += `${DIM_COLOR(`${dimString}.`)}not`;
        dimString = "";
    }
    if (matcherName.includes(".")) dimString += matcherName;
    else {
        hint += DIM_COLOR(`${dimString}.`) + matcherName;
        dimString = "";
    }
    if ("" === expected) dimString += "()";
    else {
        hint += DIM_COLOR(`${dimString}(`) + expectedColor(expected);
        if (secondArgument) hint += DIM_COLOR(", ") + secondArgumentColor(secondArgument);
        dimString = ")";
    }
    if ("" !== comment) dimString += ` // ${comment}`;
    if ("" !== dimString) hint += DIM_COLOR(dimString);
    return hint;
}
const dist_SPACE_SYMBOL = "";
function dist_replaceTrailingSpaces(text) {
    return text.replace(/\s+$/gm, (spaces)=>dist_SPACE_SYMBOL.repeat(spaces.length));
}
function dist_printReceived(object) {
    return RECEIVED_COLOR(dist_replaceTrailingSpaces(stringify(object)));
}
function dist_printExpected(value) {
    return EXPECTED_COLOR(dist_replaceTrailingSpaces(stringify(value)));
}
function getMatcherUtils() {
    return {
        EXPECTED_COLOR: EXPECTED_COLOR,
        RECEIVED_COLOR: RECEIVED_COLOR,
        INVERTED_COLOR: INVERTED_COLOR,
        BOLD_WEIGHT: BOLD_WEIGHT,
        DIM_COLOR: DIM_COLOR,
        diff: diff_diff,
        matcherHint: dist_matcherHint,
        printReceived: dist_printReceived,
        printExpected: dist_printExpected,
        printDiffOrStringify: printDiffOrStringify,
        printWithType: printWithType
    };
}
function printWithType(name, value, print) {
    const type = helpers_getType(value);
    const hasType = "null" !== type && "undefined" !== type ? `${name} has type:  ${type}\n` : "";
    const hasValue = `${name} has value: ${print(value)}`;
    return hasType + hasValue;
}
function addCustomEqualityTesters(newTesters) {
    if (!Array.isArray(newTesters)) throw new TypeError(`expect.customEqualityTesters: Must be set to an array of Testers. Was given "${helpers_getType(newTesters)}"`);
    globalThis[JEST_MATCHERS_OBJECT].customEqualityTesters.push(...newTesters);
}
function getCustomEqualityTesters() {
    return globalThis[JEST_MATCHERS_OBJECT].customEqualityTesters;
}
function dist_equals(a, b, customTesters, strictCheck) {
    customTesters = customTesters || [];
    return eq(a, b, [], [], customTesters, strictCheck ? dist_hasKey : hasDefinedKey);
}
Function.prototype.toString;
function isAsymmetric(obj) {
    return !!obj && "object" == typeof obj && "asymmetricMatch" in obj && isA("Function", obj.asymmetricMatch);
}
function asymmetricMatch(a, b) {
    const asymmetricA = isAsymmetric(a);
    const asymmetricB = isAsymmetric(b);
    if (asymmetricA && asymmetricB) return;
    if (asymmetricA) return a.asymmetricMatch(b);
    if (asymmetricB) return b.asymmetricMatch(a);
}
function eq(a, b, aStack, bStack, customTesters, hasKey) {
    let result = true;
    const asymmetricResult = asymmetricMatch(a, b);
    if (void 0 !== asymmetricResult) return asymmetricResult;
    const testerContext = {
        equals: dist_equals
    };
    for(let i = 0; i < customTesters.length; i++){
        const customTesterResult = customTesters[i].call(testerContext, a, b, customTesters);
        if (void 0 !== customTesterResult) return customTesterResult;
    }
    if ("function" == typeof URL && a instanceof URL && b instanceof URL) return a.href === b.href;
    if (Object.is(a, b)) return true;
    if (null === a || null === b) return a === b;
    const className = Object.prototype.toString.call(a);
    if (className !== Object.prototype.toString.call(b)) return false;
    switch(className){
        case "[object Boolean]":
        case "[object String]":
        case "[object Number]":
            if (typeof a !== typeof b) return false;
            if ("object" != typeof a && "object" != typeof b) return Object.is(a, b);
            return Object.is(a.valueOf(), b.valueOf());
        case "[object Date]":
            {
                const numA = +a;
                const numB = +b;
                return numA === numB || Number.isNaN(numA) && Number.isNaN(numB);
            }
        case "[object RegExp]":
            return a.source === b.source && a.flags === b.flags;
        case "[object Temporal.Instant]":
        case "[object Temporal.ZonedDateTime]":
        case "[object Temporal.PlainDateTime]":
        case "[object Temporal.PlainDate]":
        case "[object Temporal.PlainTime]":
        case "[object Temporal.PlainYearMonth]":
        case "[object Temporal.PlainMonthDay]":
            return a.equals(b);
        case "[object Temporal.Duration]":
            return a.toString() === b.toString();
    }
    if ("object" != typeof a || "object" != typeof b) return false;
    if (isDomNode(a) && isDomNode(b)) return a.isEqualNode(b);
    let length = aStack.length;
    while(length--)if (aStack[length] === a) return bStack[length] === b;
    else if (bStack[length] === b) return false;
    aStack.push(a);
    bStack.push(b);
    if ("[object Array]" === className && a.length !== b.length) return false;
    if (a instanceof Error && b instanceof Error) try {
        return isErrorEqual(a, b, aStack, bStack, customTesters, hasKey);
    } finally{
        aStack.pop();
        bStack.pop();
    }
    const aKeys = dist_keys(a, hasKey);
    let key;
    let size = aKeys.length;
    if (dist_keys(b, hasKey).length !== size) return false;
    while(size--){
        key = aKeys[size];
        result = hasKey(b, key) && eq(a[key], b[key], aStack, bStack, customTesters, hasKey);
        if (!result) return false;
    }
    aStack.pop();
    bStack.pop();
    return result;
}
function isErrorEqual(a, b, aStack, bStack, customTesters, hasKey) {
    let result = Object.getPrototypeOf(a) === Object.getPrototypeOf(b) && a.name === b.name && a.message === b.message;
    if (void 0 !== b.cause) result && (result = eq(a.cause, b.cause, aStack, bStack, customTesters, hasKey));
    if (a instanceof AggregateError && b instanceof AggregateError) result && (result = eq(a.errors, b.errors, aStack, bStack, customTesters, hasKey));
    result && (result = eq({
        ...a
    }, {
        ...b
    }, aStack, bStack, customTesters, hasKey));
    return result;
}
function dist_keys(obj, hasKey) {
    const keys = [];
    for(const key in obj)if (hasKey(obj, key)) keys.push(key);
    return keys.concat(Object.getOwnPropertySymbols(obj).filter((symbol)=>Object.getOwnPropertyDescriptor(obj, symbol).enumerable));
}
function hasDefinedKey(obj, key) {
    return dist_hasKey(obj, key) && void 0 !== obj[key];
}
function dist_hasKey(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
function isA(typeName, value) {
    return Object.prototype.toString.apply(value) === `[object ${typeName}]`;
}
function isDomNode(obj) {
    return null !== obj && "object" == typeof obj && "nodeType" in obj && "number" == typeof obj.nodeType && "nodeName" in obj && "string" == typeof obj.nodeName && "isEqualNode" in obj && "function" == typeof obj.isEqualNode;
}
const dist_IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
const dist_IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
const dist_IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
const dist_IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
const dist_IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
function isImmutableUnorderedKeyed(maybeKeyed) {
    return !!(maybeKeyed && maybeKeyed[dist_IS_KEYED_SENTINEL] && !maybeKeyed[dist_IS_ORDERED_SENTINEL]);
}
function isImmutableUnorderedSet(maybeSet) {
    return !!(maybeSet && maybeSet[dist_IS_SET_SENTINEL] && !maybeSet[dist_IS_ORDERED_SENTINEL]);
}
function isObjectLiteral(source) {
    return null != source && "object" == typeof source && !Array.isArray(source);
}
function isImmutableList(source) {
    return Boolean(source && isObjectLiteral(source) && source[dist_IS_LIST_SENTINEL]);
}
function isImmutableOrderedKeyed(source) {
    return Boolean(source && isObjectLiteral(source) && source[dist_IS_KEYED_SENTINEL] && source[dist_IS_ORDERED_SENTINEL]);
}
function isImmutableOrderedSet(source) {
    return Boolean(source && isObjectLiteral(source) && source[dist_IS_SET_SENTINEL] && source[dist_IS_ORDERED_SENTINEL]);
}
function isImmutableRecord(source) {
    return Boolean(source && isObjectLiteral(source) && source[dist_IS_RECORD_SYMBOL]);
}
const IteratorSymbol = Symbol.iterator;
function hasIterator(object) {
    return !!(null != object && object[IteratorSymbol]);
}
function iterableEquality(a, b, customTesters = [], aStack = [], bStack = []) {
    if ("object" != typeof a || "object" != typeof b || Array.isArray(a) || Array.isArray(b) || !hasIterator(a) || !hasIterator(b)) return;
    if (a.constructor !== b.constructor) return false;
    let length = aStack.length;
    while(length--)if (aStack[length] === a) return bStack[length] === b;
    aStack.push(a);
    bStack.push(b);
    const filteredCustomTesters = [
        ...customTesters.filter((t)=>t !== iterableEquality),
        iterableEqualityWithStack
    ];
    function iterableEqualityWithStack(a, b) {
        return iterableEquality(a, b, [
            ...customTesters
        ], [
            ...aStack
        ], [
            ...bStack
        ]);
    }
    if (void 0 !== a.size) {
        if (a.size !== b.size) return false;
        else if (isA("Set", a) || isImmutableUnorderedSet(a)) {
            let allFound = true;
            for (const aValue of a)if (!b.has(aValue)) {
                let has = false;
                for (const bValue of b){
                    const isEqual = dist_equals(aValue, bValue, filteredCustomTesters);
                    if (true === isEqual) has = true;
                }
                if (false === has) {
                    allFound = false;
                    break;
                }
            }
            aStack.pop();
            bStack.pop();
            return allFound;
        } else if (isA("Map", a) || isImmutableUnorderedKeyed(a)) {
            let allFound = true;
            for (const aEntry of a)if (!b.has(aEntry[0]) || !dist_equals(aEntry[1], b.get(aEntry[0]), filteredCustomTesters)) {
                let has = false;
                for (const bEntry of b){
                    const matchedKey = dist_equals(aEntry[0], bEntry[0], filteredCustomTesters);
                    let matchedValue = false;
                    if (true === matchedKey) matchedValue = dist_equals(aEntry[1], bEntry[1], filteredCustomTesters);
                    if (true === matchedValue) has = true;
                }
                if (false === has) {
                    allFound = false;
                    break;
                }
            }
            aStack.pop();
            bStack.pop();
            return allFound;
        }
    }
    const bIterator = b[IteratorSymbol]();
    for (const aValue of a){
        const nextB = bIterator.next();
        if (nextB.done || !dist_equals(aValue, nextB.value, filteredCustomTesters)) return false;
    }
    if (!bIterator.next().done) return false;
    if (!isImmutableList(a) && !isImmutableOrderedKeyed(a) && !isImmutableOrderedSet(a) && !isImmutableRecord(a)) {
        const aEntries = Object.entries(a);
        const bEntries = Object.entries(b);
        if (!dist_equals(aEntries, bEntries, filteredCustomTesters)) return false;
    }
    aStack.pop();
    bStack.pop();
    return true;
}
function hasPropertyInObject(object, key) {
    const shouldTerminate = !object || "object" != typeof object || object === Object.prototype;
    if (shouldTerminate) return false;
    return Object.prototype.hasOwnProperty.call(object, key) || hasPropertyInObject(Object.getPrototypeOf(object), key);
}
function isObjectWithKeys(a) {
    return helpers_isObject(a) && !(a instanceof Error) && !Array.isArray(a) && !(a instanceof Date);
}
function subsetEquality(object, subset, customTesters = []) {
    const filteredCustomTesters = customTesters.filter((t)=>t !== subsetEquality);
    const subsetEqualityWithContext = (seenReferences = new WeakMap())=>(object, subset)=>{
            if (!isObjectWithKeys(subset)) return;
            return Object.keys(subset).every((key)=>{
                if (null != subset[key] && "object" == typeof subset[key]) {
                    if (seenReferences.has(subset[key])) return dist_equals(object[key], subset[key], filteredCustomTesters);
                    seenReferences.set(subset[key], true);
                }
                const result = null != object && hasPropertyInObject(object, key) && dist_equals(object[key], subset[key], [
                    ...filteredCustomTesters,
                    subsetEqualityWithContext(seenReferences)
                ]);
                seenReferences.delete(subset[key]);
                return result;
            });
        };
    return subsetEqualityWithContext()(object, subset);
}
function typeEquality(a, b) {
    if (null == a || null == b || a.constructor === b.constructor) return;
    return false;
}
function arrayBufferEquality(a, b) {
    let dataViewA = a;
    let dataViewB = b;
    if (!(a instanceof DataView && b instanceof DataView)) {
        if (!(a instanceof ArrayBuffer) || !(b instanceof ArrayBuffer)) return;
        try {
            dataViewA = new DataView(a);
            dataViewB = new DataView(b);
        } catch  {
            return;
        }
    }
    if (dataViewA.byteLength !== dataViewB.byteLength) return false;
    for(let i = 0; i < dataViewA.byteLength; i++)if (dataViewA.getUint8(i) !== dataViewB.getUint8(i)) return false;
    return true;
}
function sparseArrayEquality(a, b, customTesters = []) {
    if (!Array.isArray(a) || !Array.isArray(b)) return;
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    const filteredCustomTesters = customTesters.filter((t)=>t !== sparseArrayEquality);
    return dist_equals(a, b, filteredCustomTesters, true) && dist_equals(aKeys, bKeys);
}
function generateToBeMessage(deepEqualityName, expected = "#{this}", actual = "#{exp}") {
    const toBeMessage = `expected ${expected} to be ${actual} // Object.is equality`;
    if ([
        "toStrictEqual",
        "toEqual"
    ].includes(deepEqualityName)) return `${toBeMessage}\n\nIf it should pass with deep equality, replace "toBe" with "${deepEqualityName}"\n\nExpected: ${expected}\nReceived: serializes to the same string\n`;
    return toBeMessage;
}
function pluralize(word, count) {
    return `${count} ${word}${1 === count ? "" : "s"}`;
}
function getObjectKeys(object) {
    return [
        ...Object.keys(object),
        ...Object.getOwnPropertySymbols(object).filter((s)=>{
            var _Object$getOwnPropert;
            return null == (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(object, s)) ? void 0 : _Object$getOwnPropert.enumerable;
        })
    ];
}
function getObjectSubset(object, subset, customTesters) {
    let stripped = 0;
    const getObjectSubsetWithContext = (seenReferences = new WeakMap())=>(object, subset)=>{
            if (Array.isArray(object)) {
                if (Array.isArray(subset) && subset.length === object.length) return subset.map((sub, i)=>getObjectSubsetWithContext(seenReferences)(object[i], sub));
            } else if (object instanceof Date) ;
            else if (helpers_isObject(object) && helpers_isObject(subset)) {
                if (dist_equals(object, subset, [
                    ...customTesters,
                    iterableEquality,
                    subsetEquality
                ])) return subset;
                const trimmed = {};
                seenReferences.set(object, trimmed);
                if ("function" == typeof object.constructor && "string" == typeof object.constructor.name) Object.defineProperty(trimmed, "constructor", {
                    enumerable: false,
                    value: object.constructor
                });
                for (const key of getObjectKeys(object))if (hasPropertyInObject(subset, key)) trimmed[key] = seenReferences.has(object[key]) ? seenReferences.get(object[key]) : getObjectSubsetWithContext(seenReferences)(object[key], subset[key]);
                else if (!seenReferences.has(object[key])) {
                    stripped += 1;
                    if (helpers_isObject(object[key])) stripped += getObjectKeys(object[key]).length;
                    getObjectSubsetWithContext(seenReferences)(object[key], subset[key]);
                }
                if (getObjectKeys(trimmed).length > 0) return trimmed;
            }
            return object;
        };
    return {
        subset: getObjectSubsetWithContext()(object, subset),
        stripped
    };
}
if (!Object.prototype.hasOwnProperty.call(globalThis, MATCHERS_OBJECT)) {
    const globalState = new WeakMap();
    const matchers = Object.create(null);
    const customEqualityTesters = [];
    const asymmetricMatchers = Object.create(null);
    Object.defineProperty(globalThis, MATCHERS_OBJECT, {
        get: ()=>globalState
    });
    Object.defineProperty(globalThis, JEST_MATCHERS_OBJECT, {
        configurable: true,
        get: ()=>({
                state: globalState.get(globalThis[GLOBAL_EXPECT]),
                matchers,
                customEqualityTesters
            })
    });
    Object.defineProperty(globalThis, ASYMMETRIC_MATCHERS_OBJECT, {
        get: ()=>asymmetricMatchers
    });
}
function getState(expect) {
    return globalThis[MATCHERS_OBJECT].get(expect);
}
function setState(state, expect) {
    const map = globalThis[MATCHERS_OBJECT];
    const current = map.get(expect) || {};
    const results = Object.defineProperties(current, {
        ...Object.getOwnPropertyDescriptors(current),
        ...Object.getOwnPropertyDescriptors(state)
    });
    map.set(expect, results);
}
class dist_AsymmetricMatcher {
    $$typeof = Symbol.for("jest.asymmetricMatcher");
    constructor(sample, inverse = false){
        this.sample = sample;
        this.inverse = inverse;
    }
    getMatcherContext(expect) {
        return {
            ...getState(expect || globalThis[GLOBAL_EXPECT]),
            equals: dist_equals,
            isNot: this.inverse,
            customTesters: getCustomEqualityTesters(),
            utils: {
                ...getMatcherUtils(),
                diff: diff_diff,
                stringify: stringify,
                iterableEquality: iterableEquality,
                subsetEquality: subsetEquality
            }
        };
    }
}
dist_AsymmetricMatcher.prototype[Symbol.for("chai/inspect")] = function(options) {
    const result = stringify(this, options.depth, {
        min: true
    });
    if (result.length <= options.truncate) return result;
    return `${this.toString()}{}`;
};
class StringContaining extends dist_AsymmetricMatcher {
    constructor(sample, inverse = false){
        if (!isA("String", sample)) throw new Error("Expected is not a string");
        super(sample, inverse);
    }
    asymmetricMatch(other) {
        const result = isA("String", other) && other.includes(this.sample);
        return this.inverse ? !result : result;
    }
    toString() {
        return `String${this.inverse ? "Not" : ""}Containing`;
    }
    getExpectedType() {
        return "string";
    }
}
class Anything extends dist_AsymmetricMatcher {
    asymmetricMatch(other) {
        return null != other;
    }
    toString() {
        return "Anything";
    }
    toAsymmetricMatcher() {
        return "Anything";
    }
}
class ObjectContaining extends dist_AsymmetricMatcher {
    constructor(sample, inverse = false){
        super(sample, inverse);
    }
    getPrototype(obj) {
        if (Object.getPrototypeOf) return Object.getPrototypeOf(obj);
        if (obj.constructor.prototype === obj) return null;
        return obj.constructor.prototype;
    }
    hasProperty(obj, property) {
        if (!obj) return false;
        if (Object.prototype.hasOwnProperty.call(obj, property)) return true;
        return this.hasProperty(this.getPrototype(obj), property);
    }
    asymmetricMatch(other) {
        if ("object" != typeof this.sample) throw new TypeError(`You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`);
        let result = true;
        const matcherContext = this.getMatcherContext();
        for(const property in this.sample)if (!this.hasProperty(other, property) || !dist_equals(this.sample[property], other[property], matcherContext.customTesters)) {
            result = false;
            break;
        }
        return this.inverse ? !result : result;
    }
    toString() {
        return `Object${this.inverse ? "Not" : ""}Containing`;
    }
    getExpectedType() {
        return "object";
    }
}
class ArrayContaining extends dist_AsymmetricMatcher {
    constructor(sample, inverse = false){
        super(sample, inverse);
    }
    asymmetricMatch(other) {
        if (!Array.isArray(this.sample)) throw new TypeError(`You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`);
        const matcherContext = this.getMatcherContext();
        const result = 0 === this.sample.length || Array.isArray(other) && this.sample.every((item)=>other.some((another)=>dist_equals(item, another, matcherContext.customTesters)));
        return this.inverse ? !result : result;
    }
    toString() {
        return `Array${this.inverse ? "Not" : ""}Containing`;
    }
    getExpectedType() {
        return "array";
    }
}
class Any extends dist_AsymmetricMatcher {
    constructor(sample){
        if (void 0 === sample) throw new TypeError("any() expects to be passed a constructor function. Please pass one or use anything() to match any object.");
        super(sample);
    }
    fnNameFor(func) {
        if (func.name) return func.name;
        const functionToString = Function.prototype.toString;
        const matches = functionToString.call(func).match(/^(?:async)?\s*function\s*(?:\*\s*)?([\w$]+)\s*\(/);
        return matches ? matches[1] : "<anonymous>";
    }
    asymmetricMatch(other) {
        if (this.sample === String) return "string" == typeof other || other instanceof String;
        if (this.sample === Number) return "number" == typeof other || other instanceof Number;
        if (this.sample === Function) return "function" == typeof other || "function" == typeof other;
        if (this.sample === Boolean) return "boolean" == typeof other || other instanceof Boolean;
        if (this.sample === BigInt) return "bigint" == typeof other || other instanceof BigInt;
        if (this.sample === Symbol) return "symbol" == typeof other || other instanceof Symbol;
        if (this.sample === Object) return "object" == typeof other;
        return other instanceof this.sample;
    }
    toString() {
        return "Any";
    }
    getExpectedType() {
        if (this.sample === String) return "string";
        if (this.sample === Number) return "number";
        if (this.sample === Function) return "function";
        if (this.sample === Object) return "object";
        if (this.sample === Boolean) return "boolean";
        return this.fnNameFor(this.sample);
    }
    toAsymmetricMatcher() {
        return `Any<${this.fnNameFor(this.sample)}>`;
    }
}
class StringMatching extends dist_AsymmetricMatcher {
    constructor(sample, inverse = false){
        if (!isA("String", sample) && !isA("RegExp", sample)) throw new Error("Expected is not a String or a RegExp");
        super(new RegExp(sample), inverse);
    }
    asymmetricMatch(other) {
        const result = isA("String", other) && this.sample.test(other);
        return this.inverse ? !result : result;
    }
    toString() {
        return `String${this.inverse ? "Not" : ""}Matching`;
    }
    getExpectedType() {
        return "string";
    }
}
class CloseTo extends dist_AsymmetricMatcher {
    precision;
    constructor(sample, precision = 2, inverse = false){
        if (!isA("Number", sample)) throw new Error("Expected is not a Number");
        if (!isA("Number", precision)) throw new Error("Precision is not a Number");
        super(sample);
        this.inverse = inverse;
        this.precision = precision;
    }
    asymmetricMatch(other) {
        if (!isA("Number", other)) return false;
        let result = false;
        result = other === 1 / 0 && this.sample === 1 / 0 ? true : other === -1 / 0 && this.sample === -1 / 0 ? true : Math.abs(this.sample - other) < 10 ** -this.precision / 2;
        return this.inverse ? !result : result;
    }
    toString() {
        return `Number${this.inverse ? "Not" : ""}CloseTo`;
    }
    getExpectedType() {
        return "number";
    }
    toAsymmetricMatcher() {
        return [
            this.toString(),
            this.sample,
            `(${pluralize("digit", this.precision)})`
        ].join(" ");
    }
}
const JestAsymmetricMatchers = (chai, utils)=>{
    utils.addMethod(chai.expect, "anything", ()=>new Anything());
    utils.addMethod(chai.expect, "any", (expected)=>new Any(expected));
    utils.addMethod(chai.expect, "stringContaining", (expected)=>new StringContaining(expected));
    utils.addMethod(chai.expect, "objectContaining", (expected)=>new ObjectContaining(expected));
    utils.addMethod(chai.expect, "arrayContaining", (expected)=>new ArrayContaining(expected));
    utils.addMethod(chai.expect, "stringMatching", (expected)=>new StringMatching(expected));
    utils.addMethod(chai.expect, "closeTo", (expected, precision)=>new CloseTo(expected, precision));
    chai.expect.not = {
        stringContaining: (expected)=>new StringContaining(expected, true),
        objectContaining: (expected)=>new ObjectContaining(expected, true),
        arrayContaining: (expected)=>new ArrayContaining(expected, true),
        stringMatching: (expected)=>new StringMatching(expected, true),
        closeTo: (expected, precision)=>new CloseTo(expected, precision, true)
    };
};
function createAssertionMessage(util, assertion, hasArgs) {
    const not = util.flag(assertion, "negate") ? "not." : "";
    const name = `${util.flag(assertion, "_name")}(${hasArgs ? "expected" : ""})`;
    const promiseName = util.flag(assertion, "promise");
    const promise = promiseName ? `.${promiseName}` : "";
    return `expect(actual)${promise}.${not}${name}`;
}
function recordAsyncExpect(_test, promise, assertion, error) {
    const test = _test;
    if (test && promise instanceof Promise) {
        promise = promise.finally(()=>{
            if (!test.promises) return;
            const index = test.promises.indexOf(promise);
            if (-1 !== index) test.promises.splice(index, 1);
        });
        if (!test.promises) test.promises = [];
        test.promises.push(promise);
        let resolved = false;
        test.onFinished ?? (test.onFinished = []);
        test.onFinished.push(()=>{
            if (!resolved) {
                var _vitest_worker__;
                const processor = (null == (_vitest_worker__ = globalThis.__vitest_worker__) ? void 0 : _vitest_worker__.onFilterStackTrace) || ((s)=>s || "");
                const stack = processor(error.stack);
                console.warn([
                    `Promise returned by \`${assertion}\` was not awaited. `,
                    "Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ",
                    "Please remember to await the assertion.\n",
                    stack
                ].join(""));
            }
        });
        return {
            then (onFulfilled, onRejected) {
                resolved = true;
                return promise.then(onFulfilled, onRejected);
            },
            catch (onRejected) {
                return promise.catch(onRejected);
            },
            finally (onFinally) {
                return promise.finally(onFinally);
            },
            [Symbol.toStringTag]: "Promise"
        };
    }
    return promise;
}
function handleTestError(test, err) {
    var _test$result;
    test.result || (test.result = {
        state: "fail"
    });
    test.result.state = "fail";
    (_test$result = test.result).errors || (_test$result.errors = []);
    test.result.errors.push(processError(err));
}
function wrapAssertion(utils, name, fn) {
    return function(...args) {
        if ("withTest" !== name) utils.flag(this, "_name", name);
        if (!utils.flag(this, "soft")) return fn.apply(this, args);
        const test = utils.flag(this, "vitest-test");
        if (!test) throw new Error("expect.soft() can only be used inside a test");
        try {
            const result = fn.apply(this, args);
            if (result && "object" == typeof result && "function" == typeof result.then) return result.then(noop, (err)=>{
                handleTestError(test, err);
            });
            return result;
        } catch (err) {
            handleTestError(test, err);
        }
    };
}
const JestChaiExpect = (chai, utils)=>{
    const { AssertionError } = chai;
    const customTesters = getCustomEqualityTesters();
    function def(name, fn) {
        const addMethod = (n)=>{
            const softWrapper = wrapAssertion(utils, n, fn);
            utils.addMethod(chai.Assertion.prototype, n, softWrapper);
            utils.addMethod(globalThis[JEST_MATCHERS_OBJECT].matchers, n, softWrapper);
        };
        if (Array.isArray(name)) name.forEach((n)=>addMethod(n));
        else addMethod(name);
    }
    [
        "throw",
        "throws",
        "Throw"
    ].forEach((m)=>{
        utils.overwriteMethod(chai.Assertion.prototype, m, (_super)=>function(...args) {
                const promise = utils.flag(this, "promise");
                const object = utils.flag(this, "object");
                const isNot = utils.flag(this, "negate");
                if ("rejects" === promise) utils.flag(this, "object", ()=>{
                    throw object;
                });
                else if ("resolves" === promise && "function" != typeof object) if (isNot) return;
                else {
                    const message = utils.flag(this, "message") || "expected promise to throw an error, but it didn't";
                    const error = {
                        showDiff: false
                    };
                    throw new AssertionError(message, error, utils.flag(this, "ssfi"));
                }
                _super.apply(this, args);
            });
    });
    def("withTest", function(test) {
        utils.flag(this, "vitest-test", test);
        return this;
    });
    def("toEqual", function(expected) {
        const actual = utils.flag(this, "object");
        const equal = dist_equals(actual, expected, [
            ...customTesters,
            iterableEquality
        ]);
        return this.assert(equal, "expected #{this} to deeply equal #{exp}", "expected #{this} to not deeply equal #{exp}", expected, actual);
    });
    def("toStrictEqual", function(expected) {
        const obj = utils.flag(this, "object");
        const equal = dist_equals(obj, expected, [
            ...customTesters,
            iterableEquality,
            typeEquality,
            sparseArrayEquality,
            arrayBufferEquality
        ], true);
        return this.assert(equal, "expected #{this} to strictly equal #{exp}", "expected #{this} to not strictly equal #{exp}", expected, obj);
    });
    def("toBe", function(expected) {
        const actual = this._obj;
        const pass = Object.is(actual, expected);
        let deepEqualityName = "";
        if (!pass) {
            const toStrictEqualPass = dist_equals(actual, expected, [
                ...customTesters,
                iterableEquality,
                typeEquality,
                sparseArrayEquality,
                arrayBufferEquality
            ], true);
            if (toStrictEqualPass) deepEqualityName = "toStrictEqual";
            else {
                const toEqualPass = dist_equals(actual, expected, [
                    ...customTesters,
                    iterableEquality
                ]);
                if (toEqualPass) deepEqualityName = "toEqual";
            }
        }
        return this.assert(pass, generateToBeMessage(deepEqualityName), "expected #{this} not to be #{exp} // Object.is equality", expected, actual);
    });
    def("toMatchObject", function(expected) {
        const actual = this._obj;
        const pass = dist_equals(actual, expected, [
            ...customTesters,
            iterableEquality,
            subsetEquality
        ]);
        const isNot = utils.flag(this, "negate");
        const { subset: actualSubset, stripped } = getObjectSubset(actual, expected, customTesters);
        if (pass && isNot || !pass && !isNot) {
            const msg = utils.getMessage(this, [
                pass,
                "expected #{this} to match object #{exp}",
                "expected #{this} to not match object #{exp}",
                expected,
                actualSubset,
                false
            ]);
            const message = 0 === stripped ? msg : `${msg}\n(${stripped} matching ${1 === stripped ? "property" : "properties"} omitted from actual)`;
            throw new AssertionError(message, {
                showDiff: true,
                expected,
                actual: actualSubset
            });
        }
    });
    def("toMatch", function(expected) {
        const actual = this._obj;
        if ("string" != typeof actual) throw new TypeError(`.toMatch() expects to receive a string, but got ${typeof actual}`);
        return this.assert("string" == typeof expected ? actual.includes(expected) : actual.match(expected), "expected #{this} to match #{exp}", "expected #{this} not to match #{exp}", expected, actual);
    });
    def("toContain", function(item) {
        const actual = this._obj;
        if ("undefined" != typeof Node && actual instanceof Node) {
            if (!(item instanceof Node)) throw new TypeError(`toContain() expected a DOM node as the argument, but got ${typeof item}`);
            return this.assert(actual.contains(item), "expected #{this} to contain element #{exp}", "expected #{this} not to contain element #{exp}", item, actual);
        }
        if ("undefined" != typeof DOMTokenList && actual instanceof DOMTokenList) {
            assertTypes(item, "class name", [
                "string"
            ]);
            const isNot = utils.flag(this, "negate");
            const expectedClassList = isNot ? actual.value.replace(item, "").trim() : `${actual.value} ${item}`;
            return this.assert(actual.contains(item), `expected "${actual.value}" to contain "${item}"`, `expected "${actual.value}" not to contain "${item}"`, expectedClassList, actual.value);
        }
        if ("string" == typeof actual && "string" == typeof item) return this.assert(actual.includes(item), "expected #{this} to contain #{exp}", "expected #{this} not to contain #{exp}", item, actual);
        if (null != actual && "string" != typeof actual) utils.flag(this, "object", Array.from(actual));
        return this.contain(item);
    });
    def("toContainEqual", function(expected) {
        const obj = utils.flag(this, "object");
        const index = Array.from(obj).findIndex((item)=>dist_equals(item, expected, customTesters));
        this.assert(-1 !== index, "expected #{this} to deep equally contain #{exp}", "expected #{this} to not deep equally contain #{exp}", expected);
    });
    def("toBeTruthy", function() {
        const obj = utils.flag(this, "object");
        this.assert(Boolean(obj), "expected #{this} to be truthy", "expected #{this} to not be truthy", true, obj);
    });
    def("toBeFalsy", function() {
        const obj = utils.flag(this, "object");
        this.assert(!obj, "expected #{this} to be falsy", "expected #{this} to not be falsy", false, obj);
    });
    def("toBeGreaterThan", function(expected) {
        const actual = this._obj;
        assertTypes(actual, "actual", [
            "number",
            "bigint"
        ]);
        assertTypes(expected, "expected", [
            "number",
            "bigint"
        ]);
        return this.assert(actual > expected, `expected ${actual} to be greater than ${expected}`, `expected ${actual} to be not greater than ${expected}`, expected, actual, false);
    });
    def("toBeGreaterThanOrEqual", function(expected) {
        const actual = this._obj;
        assertTypes(actual, "actual", [
            "number",
            "bigint"
        ]);
        assertTypes(expected, "expected", [
            "number",
            "bigint"
        ]);
        return this.assert(actual >= expected, `expected ${actual} to be greater than or equal to ${expected}`, `expected ${actual} to be not greater than or equal to ${expected}`, expected, actual, false);
    });
    def("toBeLessThan", function(expected) {
        const actual = this._obj;
        assertTypes(actual, "actual", [
            "number",
            "bigint"
        ]);
        assertTypes(expected, "expected", [
            "number",
            "bigint"
        ]);
        return this.assert(actual < expected, `expected ${actual} to be less than ${expected}`, `expected ${actual} to be not less than ${expected}`, expected, actual, false);
    });
    def("toBeLessThanOrEqual", function(expected) {
        const actual = this._obj;
        assertTypes(actual, "actual", [
            "number",
            "bigint"
        ]);
        assertTypes(expected, "expected", [
            "number",
            "bigint"
        ]);
        return this.assert(actual <= expected, `expected ${actual} to be less than or equal to ${expected}`, `expected ${actual} to be not less than or equal to ${expected}`, expected, actual, false);
    });
    def("toBeNaN", function() {
        const obj = utils.flag(this, "object");
        this.assert(Number.isNaN(obj), "expected #{this} to be NaN", "expected #{this} not to be NaN", NaN, obj);
    });
    def("toBeUndefined", function() {
        const obj = utils.flag(this, "object");
        this.assert(void 0 === obj, "expected #{this} to be undefined", "expected #{this} not to be undefined", void 0, obj);
    });
    def("toBeNull", function() {
        const obj = utils.flag(this, "object");
        this.assert(null === obj, "expected #{this} to be null", "expected #{this} not to be null", null, obj);
    });
    def("toBeDefined", function() {
        const obj = utils.flag(this, "object");
        this.assert(void 0 !== obj, "expected #{this} to be defined", "expected #{this} to be undefined", obj);
    });
    def("toBeTypeOf", function(expected) {
        const actual = typeof this._obj;
        const equal = expected === actual;
        return this.assert(equal, "expected #{this} to be type of #{exp}", "expected #{this} not to be type of #{exp}", expected, actual);
    });
    def("toBeInstanceOf", function(obj) {
        return this.instanceOf(obj);
    });
    def("toHaveLength", function(length) {
        return this.have.length(length);
    });
    def("toHaveProperty", function(...args) {
        if (Array.isArray(args[0])) args[0] = args[0].map((key)=>String(key).replace(/([.[\]])/g, "\\$1")).join(".");
        const actual = this._obj;
        const [propertyName, expected] = args;
        const getValue = ()=>{
            const hasOwn = Object.prototype.hasOwnProperty.call(actual, propertyName);
            if (hasOwn) return {
                value: actual[propertyName],
                exists: true
            };
            return utils.getPathInfo(actual, propertyName);
        };
        const { value, exists } = getValue();
        const pass = exists && (1 === args.length || dist_equals(expected, value, customTesters));
        const valueString = 1 === args.length ? "" : ` with value ${utils.objDisplay(expected)}`;
        return this.assert(pass, `expected #{this} to have property "${propertyName}"${valueString}`, `expected #{this} to not have property "${propertyName}"${valueString}`, expected, exists ? value : void 0);
    });
    def("toBeCloseTo", function(received, precision = 2) {
        const expected = this._obj;
        let pass = false;
        let expectedDiff = 0;
        let receivedDiff = 0;
        if (received === 1 / 0 && expected === 1 / 0) pass = true;
        else if (received === -1 / 0 && expected === -1 / 0) pass = true;
        else {
            expectedDiff = 10 ** -precision / 2;
            receivedDiff = Math.abs(expected - received);
            pass = receivedDiff < expectedDiff;
        }
        return this.assert(pass, `expected #{this} to be close to #{exp}, received difference is ${receivedDiff}, but expected ${expectedDiff}`, `expected #{this} to not be close to #{exp}, received difference is ${receivedDiff}, but expected ${expectedDiff}`, received, expected, false);
    });
    function assertIsMock(assertion) {
        if (!isMockFunction(assertion._obj)) throw new TypeError(`${utils.inspect(assertion._obj)} is not a spy or a call to a spy!`);
    }
    function getSpy(assertion) {
        assertIsMock(assertion);
        return assertion._obj;
    }
    def([
        "toHaveBeenCalledTimes",
        "toBeCalledTimes"
    ], function(number) {
        const spy = getSpy(this);
        const spyName = spy.getMockName();
        const callCount = spy.mock.calls.length;
        return this.assert(callCount === number, `expected "${spyName}" to be called #{exp} times, but got ${callCount} times`, `expected "${spyName}" to not be called #{exp} times`, number, callCount, false);
    });
    def("toHaveBeenCalledOnce", function() {
        const spy = getSpy(this);
        const spyName = spy.getMockName();
        const callCount = spy.mock.calls.length;
        return this.assert(1 === callCount, `expected "${spyName}" to be called once, but got ${callCount} times`, `expected "${spyName}" to not be called once`, 1, callCount, false);
    });
    def([
        "toHaveBeenCalled",
        "toBeCalled"
    ], function() {
        const spy = getSpy(this);
        const spyName = spy.getMockName();
        const callCount = spy.mock.calls.length;
        const called = callCount > 0;
        const isNot = utils.flag(this, "negate");
        let msg = utils.getMessage(this, [
            called,
            `expected "${spyName}" to be called at least once`,
            `expected "${spyName}" to not be called at all, but actually been called ${callCount} times`,
            true,
            called
        ]);
        if (called && isNot) msg = formatCalls(spy, msg);
        if (called && isNot || !called && !isNot) throw new AssertionError(msg);
    });
    function equalsArgumentArray(a, b) {
        return a.length === b.length && a.every((aItem, i)=>dist_equals(aItem, b[i], [
                ...customTesters,
                iterableEquality
            ]));
    }
    def([
        "toHaveBeenCalledWith",
        "toBeCalledWith"
    ], function(...args) {
        const spy = getSpy(this);
        const spyName = spy.getMockName();
        const pass = spy.mock.calls.some((callArg)=>equalsArgumentArray(callArg, args));
        const isNot = utils.flag(this, "negate");
        const msg = utils.getMessage(this, [
            pass,
            `expected "${spyName}" to be called with arguments: #{exp}`,
            `expected "${spyName}" to not be called with arguments: #{exp}`,
            args
        ]);
        if (pass && isNot || !pass && !isNot) throw new AssertionError(formatCalls(spy, msg, args));
    });
    def("toHaveBeenCalledExactlyOnceWith", function(...args) {
        const spy = getSpy(this);
        const spyName = spy.getMockName();
        const callCount = spy.mock.calls.length;
        const hasCallWithArgs = spy.mock.calls.some((callArg)=>equalsArgumentArray(callArg, args));
        const pass = hasCallWithArgs && 1 === callCount;
        const isNot = utils.flag(this, "negate");
        const msg = utils.getMessage(this, [
            pass,
            `expected "${spyName}" to be called once with arguments: #{exp}`,
            `expected "${spyName}" to not be called once with arguments: #{exp}`,
            args
        ]);
        if (pass && isNot || !pass && !isNot) throw new AssertionError(formatCalls(spy, msg, args));
    });
    def([
        "toHaveBeenNthCalledWith",
        "nthCalledWith"
    ], function(times, ...args) {
        const spy = getSpy(this);
        const spyName = spy.getMockName();
        const nthCall = spy.mock.calls[times - 1];
        const callCount = spy.mock.calls.length;
        const isCalled = times <= callCount;
        this.assert(nthCall && equalsArgumentArray(nthCall, args), `expected ${ordinalOf(times)} "${spyName}" call to have been called with #{exp}${isCalled ? "" : `, but called only ${callCount} times`}`, `expected ${ordinalOf(times)} "${spyName}" call to not have been called with #{exp}`, args, nthCall, isCalled);
    });
    def([
        "toHaveBeenLastCalledWith",
        "lastCalledWith"
    ], function(...args) {
        const spy = getSpy(this);
        const spyName = spy.getMockName();
        const lastCall = spy.mock.calls[spy.mock.calls.length - 1];
        this.assert(lastCall && equalsArgumentArray(lastCall, args), `expected last "${spyName}" call to have been called with #{exp}`, `expected last "${spyName}" call to not have been called with #{exp}`, args, lastCall);
    });
    function isSpyCalledBeforeAnotherSpy(beforeSpy, afterSpy, failIfNoFirstInvocation) {
        const beforeInvocationCallOrder = beforeSpy.mock.invocationCallOrder;
        const afterInvocationCallOrder = afterSpy.mock.invocationCallOrder;
        if (0 === beforeInvocationCallOrder.length) return !failIfNoFirstInvocation;
        if (0 === afterInvocationCallOrder.length) return false;
        return beforeInvocationCallOrder[0] < afterInvocationCallOrder[0];
    }
    def([
        "toHaveBeenCalledBefore"
    ], function(resultSpy, failIfNoFirstInvocation = true) {
        const expectSpy = getSpy(this);
        if (!isMockFunction(resultSpy)) throw new TypeError(`${utils.inspect(resultSpy)} is not a spy or a call to a spy`);
        this.assert(isSpyCalledBeforeAnotherSpy(expectSpy, resultSpy, failIfNoFirstInvocation), `expected "${expectSpy.getMockName()}" to have been called before "${resultSpy.getMockName()}"`, `expected "${expectSpy.getMockName()}" to not have been called before "${resultSpy.getMockName()}"`, resultSpy, expectSpy);
    });
    def([
        "toHaveBeenCalledAfter"
    ], function(resultSpy, failIfNoFirstInvocation = true) {
        const expectSpy = getSpy(this);
        if (!isMockFunction(resultSpy)) throw new TypeError(`${utils.inspect(resultSpy)} is not a spy or a call to a spy`);
        this.assert(isSpyCalledBeforeAnotherSpy(resultSpy, expectSpy, failIfNoFirstInvocation), `expected "${expectSpy.getMockName()}" to have been called after "${resultSpy.getMockName()}"`, `expected "${expectSpy.getMockName()}" to not have been called after "${resultSpy.getMockName()}"`, resultSpy, expectSpy);
    });
    def([
        "toThrow",
        "toThrowError"
    ], function(expected) {
        if ("string" == typeof expected || void 0 === expected || expected instanceof RegExp) return this.throws("" === expected ? /^$/ : expected);
        const obj = this._obj;
        const promise = utils.flag(this, "promise");
        const isNot = utils.flag(this, "negate");
        let thrown = null;
        if ("rejects" === promise) thrown = obj;
        else if ("resolves" === promise && "function" != typeof obj) if (isNot) return;
        else {
            const message = utils.flag(this, "message") || "expected promise to throw an error, but it didn't";
            const error = {
                showDiff: false
            };
            throw new AssertionError(message, error, utils.flag(this, "ssfi"));
        }
        else {
            let isThrow = false;
            try {
                obj();
            } catch (err) {
                isThrow = true;
                thrown = err;
            }
            if (!isThrow && !isNot) {
                const message = utils.flag(this, "message") || "expected function to throw an error, but it didn't";
                const error = {
                    showDiff: false
                };
                throw new AssertionError(message, error, utils.flag(this, "ssfi"));
            }
        }
        if ("function" == typeof expected) {
            const name = expected.name || expected.prototype.constructor.name;
            return this.assert(thrown && thrown instanceof expected, `expected error to be instance of ${name}`, `expected error not to be instance of ${name}`, expected, thrown);
        }
        if (expected instanceof Error) {
            const equal = dist_equals(thrown, expected, [
                ...customTesters,
                iterableEquality
            ]);
            return this.assert(equal, "expected a thrown error to be #{exp}", "expected a thrown error not to be #{exp}", expected, thrown);
        }
        if ("object" == typeof expected && "asymmetricMatch" in expected && "function" == typeof expected.asymmetricMatch) {
            const matcher = expected;
            return this.assert(thrown && matcher.asymmetricMatch(thrown), "expected error to match asymmetric matcher", "expected error not to match asymmetric matcher", matcher, thrown);
        }
        throw new Error(`"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "${typeof expected}"`);
    });
    [
        {
            name: "toHaveResolved",
            condition: (spy)=>spy.mock.settledResults.length > 0 && spy.mock.settledResults.some(({ type })=>"fulfilled" === type),
            action: "resolved"
        },
        {
            name: [
                "toHaveReturned",
                "toReturn"
            ],
            condition: (spy)=>spy.mock.calls.length > 0 && spy.mock.results.some(({ type })=>"throw" !== type),
            action: "called"
        }
    ].forEach(({ name, condition, action })=>{
        def(name, function() {
            const spy = getSpy(this);
            const spyName = spy.getMockName();
            const pass = condition(spy);
            this.assert(pass, `expected "${spyName}" to be successfully ${action} at least once`, `expected "${spyName}" to not be successfully ${action}`, pass, !pass, false);
        });
    });
    [
        {
            name: "toHaveResolvedTimes",
            condition: (spy, times)=>spy.mock.settledResults.reduce((s, { type })=>"fulfilled" === type ? ++s : s, 0) === times,
            action: "resolved"
        },
        {
            name: [
                "toHaveReturnedTimes",
                "toReturnTimes"
            ],
            condition: (spy, times)=>spy.mock.results.reduce((s, { type })=>"throw" === type ? s : ++s, 0) === times,
            action: "called"
        }
    ].forEach(({ name, condition, action })=>{
        def(name, function(times) {
            const spy = getSpy(this);
            const spyName = spy.getMockName();
            const pass = condition(spy, times);
            this.assert(pass, `expected "${spyName}" to be successfully ${action} ${times} times`, `expected "${spyName}" to not be successfully ${action} ${times} times`, `expected resolved times: ${times}`, `received resolved times: ${pass}`, false);
        });
    });
    [
        {
            name: "toHaveResolvedWith",
            condition: (spy, value)=>spy.mock.settledResults.some(({ type, value: result })=>"fulfilled" === type && dist_equals(value, result)),
            action: "resolve"
        },
        {
            name: [
                "toHaveReturnedWith",
                "toReturnWith"
            ],
            condition: (spy, value)=>spy.mock.results.some(({ type, value: result })=>"return" === type && dist_equals(value, result)),
            action: "return"
        }
    ].forEach(({ name, condition, action })=>{
        def(name, function(value) {
            const spy = getSpy(this);
            const pass = condition(spy, value);
            const isNot = utils.flag(this, "negate");
            if (pass && isNot || !pass && !isNot) {
                const spyName = spy.getMockName();
                const msg = utils.getMessage(this, [
                    pass,
                    `expected "${spyName}" to ${action} with: #{exp} at least once`,
                    `expected "${spyName}" to not ${action} with: #{exp}`,
                    value
                ]);
                const results = "return" === action ? spy.mock.results : spy.mock.settledResults;
                throw new AssertionError(formatReturns(spy, results, msg, value));
            }
        });
    });
    [
        {
            name: "toHaveLastResolvedWith",
            condition: (spy, value)=>{
                const result = spy.mock.settledResults[spy.mock.settledResults.length - 1];
                return result && "fulfilled" === result.type && dist_equals(result.value, value);
            },
            action: "resolve"
        },
        {
            name: [
                "toHaveLastReturnedWith",
                "lastReturnedWith"
            ],
            condition: (spy, value)=>{
                const result = spy.mock.results[spy.mock.results.length - 1];
                return result && "return" === result.type && dist_equals(result.value, value);
            },
            action: "return"
        }
    ].forEach(({ name, condition, action })=>{
        def(name, function(value) {
            const spy = getSpy(this);
            const results = "return" === action ? spy.mock.results : spy.mock.settledResults;
            const result = results[results.length - 1];
            const spyName = spy.getMockName();
            this.assert(condition(spy, value), `expected last "${spyName}" call to ${action} #{exp}`, `expected last "${spyName}" call to not ${action} #{exp}`, value, null == result ? void 0 : result.value);
        });
    });
    [
        {
            name: "toHaveNthResolvedWith",
            condition: (spy, index, value)=>{
                const result = spy.mock.settledResults[index - 1];
                return result && "fulfilled" === result.type && dist_equals(result.value, value);
            },
            action: "resolve"
        },
        {
            name: [
                "toHaveNthReturnedWith",
                "nthReturnedWith"
            ],
            condition: (spy, index, value)=>{
                const result = spy.mock.results[index - 1];
                return result && "return" === result.type && dist_equals(result.value, value);
            },
            action: "return"
        }
    ].forEach(({ name, condition, action })=>{
        def(name, function(nthCall, value) {
            const spy = getSpy(this);
            const spyName = spy.getMockName();
            const results = "return" === action ? spy.mock.results : spy.mock.settledResults;
            const result = results[nthCall - 1];
            const ordinalCall = `${ordinalOf(nthCall)} call`;
            this.assert(condition(spy, nthCall, value), `expected ${ordinalCall} "${spyName}" call to ${action} #{exp}`, `expected ${ordinalCall} "${spyName}" call to not ${action} #{exp}`, value, null == result ? void 0 : result.value);
        });
    });
    def("withContext", function(context) {
        for(const key in context)utils.flag(this, key, context[key]);
        return this;
    });
    utils.addProperty(chai.Assertion.prototype, "resolves", function __VITEST_RESOLVES__() {
        const error = new Error("resolves");
        utils.flag(this, "promise", "resolves");
        utils.flag(this, "error", error);
        const test = utils.flag(this, "vitest-test");
        const obj = utils.flag(this, "object");
        if (utils.flag(this, "poll")) throw new SyntaxError("expect.poll() is not supported in combination with .resolves");
        if ("function" != typeof (null == obj ? void 0 : obj.then)) throw new TypeError(`You must provide a Promise to expect() when using .resolves, not '${typeof obj}'.`);
        const proxy = new Proxy(this, {
            get: (target, key, receiver)=>{
                const result = Reflect.get(target, key, receiver);
                if ("function" != typeof result) return result instanceof chai.Assertion ? proxy : result;
                return (...args)=>{
                    utils.flag(this, "_name", key);
                    const promise = obj.then((value)=>{
                        utils.flag(this, "object", value);
                        return result.call(this, ...args);
                    }, (err)=>{
                        const _error = new AssertionError(`promise rejected "${utils.inspect(err)}" instead of resolving`, {
                            showDiff: false
                        });
                        _error.cause = err;
                        _error.stack = error.stack.replace(error.message, _error.message);
                        throw _error;
                    });
                    return recordAsyncExpect(test, promise, createAssertionMessage(utils, this, !!args.length), error);
                };
            }
        });
        return proxy;
    });
    utils.addProperty(chai.Assertion.prototype, "rejects", function __VITEST_REJECTS__() {
        const error = new Error("rejects");
        utils.flag(this, "promise", "rejects");
        utils.flag(this, "error", error);
        const test = utils.flag(this, "vitest-test");
        const obj = utils.flag(this, "object");
        const wrapper = "function" == typeof obj ? obj() : obj;
        if (utils.flag(this, "poll")) throw new SyntaxError("expect.poll() is not supported in combination with .rejects");
        if ("function" != typeof (null == wrapper ? void 0 : wrapper.then)) throw new TypeError(`You must provide a Promise to expect() when using .rejects, not '${typeof wrapper}'.`);
        const proxy = new Proxy(this, {
            get: (target, key, receiver)=>{
                const result = Reflect.get(target, key, receiver);
                if ("function" != typeof result) return result instanceof chai.Assertion ? proxy : result;
                return (...args)=>{
                    utils.flag(this, "_name", key);
                    const promise = wrapper.then((value)=>{
                        const _error = new AssertionError(`promise resolved "${utils.inspect(value)}" instead of rejecting`, {
                            showDiff: true,
                            expected: new Error("rejected promise"),
                            actual: value
                        });
                        _error.stack = error.stack.replace(error.message, _error.message);
                        throw _error;
                    }, (err)=>{
                        utils.flag(this, "object", err);
                        return result.call(this, ...args);
                    });
                    return recordAsyncExpect(test, promise, createAssertionMessage(utils, this, !!args.length), error);
                };
            }
        });
        return proxy;
    });
};
function ordinalOf(i) {
    const j = i % 10;
    const k = i % 100;
    if (1 === j && 11 !== k) return `${i}st`;
    if (2 === j && 12 !== k) return `${i}nd`;
    if (3 === j && 13 !== k) return `${i}rd`;
    return `${i}th`;
}
function formatCalls(spy, msg, showActualCall) {
    if (spy.mock.calls.length) msg += node_u.gray(`\n\nReceived: \n\n${spy.mock.calls.map((callArg, i)=>{
        let methodCall = node_u.bold(`  ${ordinalOf(i + 1)} ${spy.getMockName()} call:\n\n`);
        if (showActualCall) methodCall += diff_diff(showActualCall, callArg, {
            omitAnnotationLines: true
        });
        else methodCall += stringify(callArg).split("\n").map((line)=>`    ${line}`).join("\n");
        methodCall += "\n";
        return methodCall;
    }).join("\n")}`);
    msg += node_u.gray(`\n\nNumber of calls: ${node_u.bold(spy.mock.calls.length)}\n`);
    return msg;
}
function formatReturns(spy, results, msg, showActualReturn) {
    if (results.length) msg += node_u.gray(`\n\nReceived: \n\n${results.map((callReturn, i)=>{
        let methodCall = node_u.bold(`  ${ordinalOf(i + 1)} ${spy.getMockName()} call return:\n\n`);
        if (showActualReturn) methodCall += diff_diff(showActualReturn, callReturn.value, {
            omitAnnotationLines: true
        });
        else methodCall += stringify(callReturn).split("\n").map((line)=>`    ${line}`).join("\n");
        methodCall += "\n";
        return methodCall;
    }).join("\n")}`);
    msg += node_u.gray(`\n\nNumber of calls: ${node_u.bold(spy.mock.calls.length)}\n`);
    return msg;
}
function getMatcherState(assertion, expect) {
    const obj = assertion._obj;
    const isNot = utils_exports.flag(assertion, "negate");
    const promise = utils_exports.flag(assertion, "promise") || "";
    const jestUtils = {
        ...getMatcherUtils(),
        diff: diff_diff,
        stringify: stringify,
        iterableEquality: iterableEquality,
        subsetEquality: subsetEquality
    };
    const matcherState = {
        ...getState(expect),
        customTesters: getCustomEqualityTesters(),
        isNot,
        utils: jestUtils,
        promise,
        equals: dist_equals,
        suppressedErrors: [],
        soft: utils_exports.flag(assertion, "soft"),
        poll: utils_exports.flag(assertion, "poll")
    };
    return {
        state: matcherState,
        isNot,
        obj
    };
}
class JestExtendError extends Error {
    constructor(message, actual, expected){
        super(message);
        this.actual = actual;
        this.expected = expected;
    }
}
function JestExtendPlugin(c, expect, matchers) {
    return (_, utils)=>{
        Object.entries(matchers).forEach(([expectAssertionName, expectAssertion])=>{
            function expectWrapper(...args) {
                const { state, isNot, obj } = getMatcherState(this, expect);
                const result = expectAssertion.call(state, obj, ...args);
                if (result && "object" == typeof result && "function" == typeof result.then) {
                    const thenable = result;
                    return thenable.then(({ pass, message, actual, expected })=>{
                        if (pass && isNot || !pass && !isNot) throw new JestExtendError(message(), actual, expected);
                    });
                }
                const { pass, message, actual, expected } = result;
                if (pass && isNot || !pass && !isNot) throw new JestExtendError(message(), actual, expected);
            }
            const softWrapper = wrapAssertion(utils, expectAssertionName, expectWrapper);
            utils.addMethod(globalThis[JEST_MATCHERS_OBJECT].matchers, expectAssertionName, softWrapper);
            utils.addMethod(c.Assertion.prototype, expectAssertionName, softWrapper);
            class CustomMatcher extends dist_AsymmetricMatcher {
                constructor(inverse = false, ...sample){
                    super(sample, inverse);
                }
                asymmetricMatch(other) {
                    const { pass } = expectAssertion.call(this.getMatcherContext(expect), other, ...this.sample);
                    return this.inverse ? !pass : pass;
                }
                toString() {
                    return `${this.inverse ? "not." : ""}${expectAssertionName}`;
                }
                getExpectedType() {
                    return "any";
                }
                toAsymmetricMatcher() {
                    return `${this.toString()}<${this.sample.map((item)=>stringify(item)).join(", ")}>`;
                }
            }
            const customMatcher = (...sample)=>new CustomMatcher(false, ...sample);
            Object.defineProperty(expect, expectAssertionName, {
                configurable: true,
                enumerable: true,
                value: customMatcher,
                writable: true
            });
            Object.defineProperty(expect.not, expectAssertionName, {
                configurable: true,
                enumerable: true,
                value: (...sample)=>new CustomMatcher(true, ...sample),
                writable: true
            });
            Object.defineProperty(globalThis[ASYMMETRIC_MATCHERS_OBJECT], expectAssertionName, {
                configurable: true,
                enumerable: true,
                value: customMatcher,
                writable: true
            });
        });
    };
}
const JestExtend = (chai, utils)=>{
    utils.addMethod(chai.expect, "extend", (expect, expects)=>{
        use(JestExtendPlugin(chai, expect, expects));
    });
};
const comma = ','.charCodeAt(0);
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const intToChar = new Uint8Array(64);
const charToInt = new Uint8Array(128);
for(let i = 0; i < chars.length; i++){
    const c = chars.charCodeAt(i);
    intToChar[i] = c;
    charToInt[c] = i;
}
function decodeInteger(reader, relative) {
    let value = 0;
    let shift = 0;
    let integer = 0;
    do {
        const c = reader.next();
        integer = charToInt[c];
        value |= (31 & integer) << shift;
        shift += 5;
    }while (32 & integer);
    const shouldNegate = 1 & value;
    value >>>= 1;
    if (shouldNegate) value = -2147483648 | -value;
    return relative + value;
}
function hasMoreVlq(reader, max) {
    if (reader.pos >= max) return false;
    return reader.peek() !== comma;
}
class StringReader {
    constructor(buffer){
        this.pos = 0;
        this.buffer = buffer;
    }
    next() {
        return this.buffer.charCodeAt(this.pos++);
    }
    peek() {
        return this.buffer.charCodeAt(this.pos);
    }
    indexOf(char) {
        const { buffer, pos } = this;
        const idx = buffer.indexOf(char, pos);
        return -1 === idx ? buffer.length : idx;
    }
}
function decode(mappings) {
    const { length } = mappings;
    const reader = new StringReader(mappings);
    const decoded = [];
    let genColumn = 0;
    let sourcesIndex = 0;
    let sourceLine = 0;
    let sourceColumn = 0;
    let namesIndex = 0;
    do {
        const semi = reader.indexOf(';');
        const line = [];
        let sorted = true;
        let lastCol = 0;
        genColumn = 0;
        while(reader.pos < semi){
            let seg;
            genColumn = decodeInteger(reader, genColumn);
            if (genColumn < lastCol) sorted = false;
            lastCol = genColumn;
            if (hasMoreVlq(reader, semi)) {
                sourcesIndex = decodeInteger(reader, sourcesIndex);
                sourceLine = decodeInteger(reader, sourceLine);
                sourceColumn = decodeInteger(reader, sourceColumn);
                if (hasMoreVlq(reader, semi)) {
                    namesIndex = decodeInteger(reader, namesIndex);
                    seg = [
                        genColumn,
                        sourcesIndex,
                        sourceLine,
                        sourceColumn,
                        namesIndex
                    ];
                } else seg = [
                    genColumn,
                    sourcesIndex,
                    sourceLine,
                    sourceColumn
                ];
            } else seg = [
                genColumn
            ];
            line.push(seg);
            reader.pos++;
        }
        if (!sorted) sort(line);
        decoded.push(line);
        reader.pos = semi + 1;
    }while (reader.pos <= length);
    return decoded;
}
function sort(line) {
    line.sort(sortComparator$1);
}
function sortComparator$1(a, b) {
    return a[0] - b[0];
}
const schemeRegex = /^[\w+.-]+:\/\//;
const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
var dist_UrlType;
(function(UrlType) {
    UrlType[UrlType["Empty"] = 1] = "Empty";
    UrlType[UrlType["Hash"] = 2] = "Hash";
    UrlType[UrlType["Query"] = 3] = "Query";
    UrlType[UrlType["RelativePath"] = 4] = "RelativePath";
    UrlType[UrlType["AbsolutePath"] = 5] = "AbsolutePath";
    UrlType[UrlType["SchemeRelative"] = 6] = "SchemeRelative";
    UrlType[UrlType["Absolute"] = 7] = "Absolute";
})(dist_UrlType || (dist_UrlType = {}));
function isAbsoluteUrl(input) {
    return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
    return input.startsWith('//');
}
function isAbsolutePath(input) {
    return input.startsWith('/');
}
function isFileUrl(input) {
    return input.startsWith('file:');
}
function isRelative(input) {
    return /^[.?#]/.test(input);
}
function parseAbsoluteUrl(input) {
    const match = urlRegex.exec(input);
    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');
}
function parseFileUrl(input) {
    const match = fileRegex.exec(input);
    const path = match[2];
    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');
}
function makeUrl(scheme, user, host, port, path, query, hash) {
    return {
        scheme,
        user,
        host,
        port,
        path,
        query,
        hash,
        type: dist_UrlType.Absolute
    };
}
function parseUrl(input) {
    if (isSchemeRelativeUrl(input)) {
        const url = parseAbsoluteUrl('http:' + input);
        url.scheme = '';
        url.type = dist_UrlType.SchemeRelative;
        return url;
    }
    if (isAbsolutePath(input)) {
        const url = parseAbsoluteUrl('http://foo.com' + input);
        url.scheme = '';
        url.host = '';
        url.type = dist_UrlType.AbsolutePath;
        return url;
    }
    if (isFileUrl(input)) return parseFileUrl(input);
    if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);
    const url = parseAbsoluteUrl('http://foo.com/' + input);
    url.scheme = '';
    url.host = '';
    url.type = input ? input.startsWith('?') ? dist_UrlType.Query : input.startsWith('#') ? dist_UrlType.Hash : dist_UrlType.RelativePath : dist_UrlType.Empty;
    return url;
}
function stripPathFilename(path) {
    if (path.endsWith('/..')) return path;
    const index = path.lastIndexOf('/');
    return path.slice(0, index + 1);
}
function mergePaths(url, base) {
    normalizePath(base, base.type);
    if ('/' === url.path) url.path = base.path;
    else url.path = stripPathFilename(base.path) + url.path;
}
function normalizePath(url, type) {
    const rel = type <= dist_UrlType.RelativePath;
    const pieces = url.path.split('/');
    let pointer = 1;
    let positive = 0;
    let addTrailingSlash = false;
    for(let i = 1; i < pieces.length; i++){
        const piece = pieces[i];
        if (!piece) {
            addTrailingSlash = true;
            continue;
        }
        addTrailingSlash = false;
        if ('.' !== piece) {
            if ('..' === piece) {
                if (positive) {
                    addTrailingSlash = true;
                    positive--;
                    pointer--;
                } else if (rel) pieces[pointer++] = piece;
                continue;
            }
            pieces[pointer++] = piece;
            positive++;
        }
    }
    let path = '';
    for(let i = 1; i < pointer; i++)path += '/' + pieces[i];
    if (!path || addTrailingSlash && !path.endsWith('/..')) path += '/';
    url.path = path;
}
function resolve$1(input, base) {
    if (!input && !base) return '';
    const url = parseUrl(input);
    let inputType = url.type;
    if (base && inputType !== dist_UrlType.Absolute) {
        const baseUrl = parseUrl(base);
        const baseType = baseUrl.type;
        switch(inputType){
            case dist_UrlType.Empty:
                url.hash = baseUrl.hash;
            case dist_UrlType.Hash:
                url.query = baseUrl.query;
            case dist_UrlType.Query:
            case dist_UrlType.RelativePath:
                mergePaths(url, baseUrl);
            case dist_UrlType.AbsolutePath:
                url.user = baseUrl.user;
                url.host = baseUrl.host;
                url.port = baseUrl.port;
            case dist_UrlType.SchemeRelative:
                url.scheme = baseUrl.scheme;
        }
        if (baseType > inputType) inputType = baseType;
    }
    normalizePath(url, inputType);
    const queryHash = url.query + url.hash;
    switch(inputType){
        case dist_UrlType.Hash:
        case dist_UrlType.Query:
            return queryHash;
        case dist_UrlType.RelativePath:
            {
                const path = url.path.slice(1);
                if (!path) return queryHash || '.';
                if (isRelative(base || input) && !isRelative(path)) return './' + path + queryHash;
                return path + queryHash;
            }
        case dist_UrlType.AbsolutePath:
            return url.path + queryHash;
        default:
            return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;
    }
}
function dist_resolve(input, base) {
    if (base && !base.endsWith('/')) base += '/';
    return resolve$1(input, base);
}
function stripFilename(path) {
    if (!path) return '';
    const index = path.lastIndexOf('/');
    return path.slice(0, index + 1);
}
const COLUMN = 0;
const SOURCES_INDEX = 1;
const SOURCE_LINE = 2;
const SOURCE_COLUMN = 3;
const NAMES_INDEX = 4;
function maybeSort(mappings, owned) {
    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
    if (unsortedIndex === mappings.length) return mappings;
    if (!owned) mappings = mappings.slice();
    for(let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1))mappings[i] = sortSegments(mappings[i], owned);
    return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
    for(let i = start; i < mappings.length; i++)if (!isSorted(mappings[i])) return i;
    return mappings.length;
}
function isSorted(line) {
    for(let j = 1; j < line.length; j++)if (line[j][COLUMN] < line[j - 1][COLUMN]) return false;
    return true;
}
function sortSegments(line, owned) {
    if (!owned) line = line.slice();
    return line.sort(sortComparator);
}
function sortComparator(a, b) {
    return a[COLUMN] - b[COLUMN];
}
let dist_found = false;
function binarySearch(haystack, needle, low, high) {
    while(low <= high){
        const mid = low + (high - low >> 1);
        const cmp = haystack[mid][COLUMN] - needle;
        if (0 === cmp) {
            dist_found = true;
            return mid;
        }
        if (cmp < 0) low = mid + 1;
        else high = mid - 1;
    }
    dist_found = false;
    return low - 1;
}
function upperBound(haystack, needle, index) {
    for(let i = index + 1; i < haystack.length && haystack[i][COLUMN] === needle; index = i++);
    return index;
}
function lowerBound(haystack, needle, index) {
    for(let i = index - 1; i >= 0 && haystack[i][COLUMN] === needle; index = i--);
    return index;
}
function memoizedState() {
    return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
    };
}
function memoizedBinarySearch(haystack, needle, state, key) {
    const { lastKey, lastNeedle, lastIndex } = state;
    let low = 0;
    let high = haystack.length - 1;
    if (key === lastKey) {
        if (needle === lastNeedle) {
            dist_found = -1 !== lastIndex && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
        }
        if (needle >= lastNeedle) low = -1 === lastIndex ? 0 : lastIndex;
        else high = lastIndex;
    }
    state.lastKey = key;
    state.lastNeedle = needle;
    return state.lastIndex = binarySearch(haystack, needle, low, high);
}
const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';
const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';
const LEAST_UPPER_BOUND = -1;
const GREATEST_LOWER_BOUND = 1;
class TraceMap {
    constructor(map, mapUrl){
        const isString = 'string' == typeof map;
        if (!isString && map._decodedMemo) return map;
        const parsed = isString ? JSON.parse(map) : map;
        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
        this.version = version;
        this.file = file;
        this.names = names || [];
        this.sourceRoot = sourceRoot;
        this.sources = sources;
        this.sourcesContent = sourcesContent;
        this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
        const from = dist_resolve(sourceRoot || '', stripFilename(mapUrl));
        this.resolvedSources = sources.map((s)=>dist_resolve(s || '', from));
        const { mappings } = parsed;
        if ('string' == typeof mappings) {
            this._encoded = mappings;
            this._decoded = void 0;
        } else {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
        }
        this._decodedMemo = memoizedState();
        this._bySources = void 0;
        this._bySourceMemos = void 0;
    }
}
function cast(map) {
    return map;
}
function decodedMappings(map) {
    var _a;
    return (_a = cast(map))._decoded || (_a._decoded = decode(cast(map)._encoded));
}
function originalPositionFor(map, needle) {
    let { line, column, bias } = needle;
    line--;
    if (line < 0) throw new Error(LINE_GTR_ZERO);
    if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
    const decoded = decodedMappings(map);
    if (line >= decoded.length) return OMapping(null, null, null, null);
    const segments = decoded[line];
    const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
    if (-1 === index) return OMapping(null, null, null, null);
    const segment = segments[index];
    if (1 === segment.length) return OMapping(null, null, null, null);
    const { names, resolvedSources } = map;
    return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], 5 === segment.length ? names[segment[NAMES_INDEX]] : null);
}
function OMapping(source, line, column, name) {
    return {
        source,
        line,
        column,
        name
    };
}
function traceSegmentInternal(segments, memo, line, column, bias) {
    let index = memoizedBinarySearch(segments, column, memo, line);
    if (dist_found) index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
    else if (bias === LEAST_UPPER_BOUND) index++;
    if (-1 === index || index === segments.length) return -1;
    return index;
}
function dist_notNullish(v) {
    return null != v;
}
function dist_isPrimitive(value) {
    return null === value || "function" != typeof value && "object" != typeof value;
}
function dist_isObject(item) {
    return null != item && "object" == typeof item && !Array.isArray(item);
}
function dist_getCallLastIndex(code) {
    let charIndex = -1;
    let inString = null;
    let startedBracers = 0;
    let endedBracers = 0;
    let beforeChar = null;
    while(charIndex <= code.length){
        beforeChar = code[charIndex];
        charIndex++;
        const char = code[charIndex];
        const isCharString = "\"" === char || "'" === char || "`" === char;
        if (isCharString && "\\" !== beforeChar) {
            if (inString === char) inString = null;
            else if (!inString) inString = char;
        }
        if (!inString) {
            if ("(" === char) startedBracers++;
            if (")" === char) endedBracers++;
        }
        if (startedBracers && endedBracers && startedBracers === endedBracers) return charIndex;
    }
    return null;
}
const CHROME_IE_STACK_REGEXP = /^\s*at .*(?:\S:\d+|\(native\))/m;
const SAFARI_NATIVE_CODE_REGEXP = /^(?:eval@)?(?:\[native code\])?$/;
const stackIgnorePatterns = [
    "node:internal",
    /\/packages\/\w+\/dist\//,
    /\/@vitest\/\w+\/dist\//,
    "/vitest/dist/",
    "/vitest/src/",
    "/vite-node/dist/",
    "/vite-node/src/",
    "/node_modules/chai/",
    "/node_modules/tinypool/",
    "/node_modules/tinyspy/",
    "/deps/chunk-",
    "/deps/@vitest",
    "/deps/loupe",
    "/deps/chai",
    /node:\w+/,
    /__vitest_test__/,
    /__vitest_browser__/,
    /\/deps\/vitest_/
];
function extractLocation(urlLike) {
    if (!urlLike.includes(":")) return [
        urlLike
    ];
    const regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
    const parts = regExp.exec(urlLike.replace(/^\(|\)$/g, ""));
    if (!parts) return [
        urlLike
    ];
    let url = parts[1];
    if (url.startsWith("async ")) url = url.slice(6);
    if (url.startsWith("http:") || url.startsWith("https:")) {
        const urlObj = new URL(url);
        urlObj.searchParams.delete("import");
        urlObj.searchParams.delete("browserv");
        url = urlObj.pathname + urlObj.hash + urlObj.search;
    }
    if (url.startsWith("/@fs/")) {
        const isWindows = /^\/@fs\/[a-zA-Z]:\//.test(url);
        url = url.slice(isWindows ? 5 : 4);
    }
    return [
        url,
        parts[2] || void 0,
        parts[3] || void 0
    ];
}
function parseSingleFFOrSafariStack(raw) {
    let line = raw.trim();
    if (SAFARI_NATIVE_CODE_REGEXP.test(line)) return null;
    if (line.includes(" > eval")) line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1");
    if (!line.includes("@") && !line.includes(":")) return null;
    const functionNameRegex = /((.*".+"[^@]*)?[^@]*)(@)/;
    const matches = line.match(functionNameRegex);
    const functionName = matches && matches[1] ? matches[1] : void 0;
    const [url, lineNumber, columnNumber] = extractLocation(line.replace(functionNameRegex, ""));
    if (!url || !lineNumber || !columnNumber) return null;
    return {
        file: url,
        method: functionName || "",
        line: Number.parseInt(lineNumber),
        column: Number.parseInt(columnNumber)
    };
}
function parseSingleV8Stack(raw) {
    let line = raw.trim();
    if (!CHROME_IE_STACK_REGEXP.test(line)) return null;
    if (line.includes("(eval ")) line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, "");
    let sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, "");
    const location = sanitizedLine.match(/ (\(.+\)$)/);
    sanitizedLine = location ? sanitizedLine.replace(location[0], "") : sanitizedLine;
    const [url, lineNumber, columnNumber] = extractLocation(location ? location[1] : sanitizedLine);
    let method = location && sanitizedLine || "";
    let file = url && [
        "eval",
        "<anonymous>"
    ].includes(url) ? void 0 : url;
    if (!file || !lineNumber || !columnNumber) return null;
    if (method.startsWith("async ")) method = method.slice(6);
    if (file.startsWith("file://")) file = file.slice(7);
    file = file.startsWith("node:") || file.startsWith("internal:") ? file : pathe_M_eThtNZ_resolve(file);
    if (method) method = method.replace(/__vite_ssr_import_\d+__\./g, "");
    return {
        method,
        file,
        line: Number.parseInt(lineNumber),
        column: Number.parseInt(columnNumber)
    };
}
function parseStacktrace(stack, options = {}) {
    const { ignoreStackEntries = stackIgnorePatterns } = options;
    const stacks = CHROME_IE_STACK_REGEXP.test(stack) ? parseV8Stacktrace(stack) : parseFFOrSafariStackTrace(stack);
    return stacks.map((stack)=>{
        var _options$getSourceMap;
        if (options.getUrlId) stack.file = options.getUrlId(stack.file);
        const map = null == (_options$getSourceMap = options.getSourceMap) ? void 0 : _options$getSourceMap.call(options, stack.file);
        if (!map || "object" != typeof map || !map.version) return shouldFilter(ignoreStackEntries, stack.file) ? null : stack;
        const traceMap = new TraceMap(map);
        const { line, column, source, name } = originalPositionFor(traceMap, stack);
        let file = stack.file;
        if (source) {
            const fileUrl = stack.file.startsWith("file://") ? stack.file : `file://${stack.file}`;
            const sourceRootUrl = map.sourceRoot ? new URL(map.sourceRoot, fileUrl) : fileUrl;
            file = new URL(source, sourceRootUrl).pathname;
            if (file.match(/\/\w:\//)) file = file.slice(1);
        }
        if (shouldFilter(ignoreStackEntries, file)) return null;
        if (null != line && null != column) return {
            line,
            column,
            file,
            method: name || stack.method
        };
        return stack;
    }).filter((s)=>null != s);
}
function shouldFilter(ignoreStackEntries, file) {
    return ignoreStackEntries.some((p)=>file.match(p));
}
function parseFFOrSafariStackTrace(stack) {
    return stack.split("\n").map((line)=>parseSingleFFOrSafariStack(line)).filter(dist_notNullish);
}
function parseV8Stacktrace(stack) {
    return stack.split("\n").map((line)=>parseSingleV8Stack(line)).filter(dist_notNullish);
}
function parseErrorStacktrace(e, options = {}) {
    if (!e || dist_isPrimitive(e)) return [];
    if (e.stacks) return e.stacks;
    const stackStr = e.stack || "";
    let stackFrames = "string" == typeof stackStr ? parseStacktrace(stackStr, options) : [];
    if (!stackFrames.length) {
        const e_ = e;
        if (null != e_.fileName && null != e_.lineNumber && null != e_.columnNumber) stackFrames = parseStacktrace(`${e_.fileName}:${e_.lineNumber}:${e_.columnNumber}`, options);
        if (null != e_.sourceURL && null != e_.line && null != e_._column) stackFrames = parseStacktrace(`${e_.sourceURL}:${e_.line}:${e_.column}`, options);
    }
    if (options.frameFilter) stackFrames = stackFrames.filter((f)=>false !== options.frameFilter(e, f));
    e.stacks = stackFrames;
    return stackFrames;
}
try {
    const { getPromiseDetails, kPending, kRejected } = process.binding('util');
    Array.isArray(getPromiseDetails(Promise.resolve()));
} catch (notNode) {}
const { AsymmetricMatcher: AsymmetricMatcher$1, DOMCollection: DOMCollection$1, DOMElement: DOMElement$1, Immutable: Immutable$1, ReactElement: ReactElement$1, ReactTestComponent: ReactTestComponent$1 } = dist_plugins;
function dist_getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}
var jsTokens_1;
var hasRequiredJsTokens;
function requireJsTokens() {
    if (hasRequiredJsTokens) return jsTokens_1;
    hasRequiredJsTokens = 1;
    var Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;
    RegularExpressionLiteral = /\/(?![*\/])(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\\]).|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu;
    Punctuator = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y;
    Identifier = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu;
    StringLiteral = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?/y;
    NumericLiteral = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y;
    Template = /[`}](?:[^`\\$]|\\[^]|\$(?!\{))*(`|\$\{)?/y;
    WhiteSpace = /[\t\v\f\ufeff\p{Zs}]+/yu;
    LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y;
    MultiLineComment = /\/\*(?:[^*]|\*(?!\/))*(\*\/)?/y;
    SingleLineComment = /\/\/.*/y;
    JSXPunctuator = /[<>.:={}]|\/(?![\/*])/y;
    JSXIdentifier = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu;
    JSXString = /(['"])(?:(?!\1)[^])*(\1)?/y;
    JSXText = /[^<>{}]+/y;
    TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
    TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
    KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
    KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;
    Newline = RegExp(LineTerminatorSequence.source);
    jsTokens_1 = function*(input, { jsx = false } = {}) {
        var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;
        ({ length } = input);
        lastIndex = 0;
        lastSignificantToken = "";
        stack = [
            {
                tag: "JS"
            }
        ];
        braces = [];
        parenNesting = 0;
        postfixIncDec = false;
        while(lastIndex < length){
            mode = stack[stack.length - 1];
            switch(mode.tag){
                case "JS":
                case "JSNonExpressionParen":
                case "InterpolationInTemplate":
                case "InterpolationInJSX":
                    if ("/" === input[lastIndex] && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
                        RegularExpressionLiteral.lastIndex = lastIndex;
                        if (match = RegularExpressionLiteral.exec(input)) {
                            lastIndex = RegularExpressionLiteral.lastIndex;
                            lastSignificantToken = match[0];
                            postfixIncDec = true;
                            yield {
                                type: "RegularExpressionLiteral",
                                value: match[0],
                                closed: void 0 !== match[1] && "\\" !== match[1]
                            };
                            continue;
                        }
                    }
                    Punctuator.lastIndex = lastIndex;
                    if (match = Punctuator.exec(input)) {
                        punctuator = match[0];
                        nextLastIndex = Punctuator.lastIndex;
                        nextLastSignificantToken = punctuator;
                        switch(punctuator){
                            case "(":
                                if ("?NonExpressionParenKeyword" === lastSignificantToken) stack.push({
                                    tag: "JSNonExpressionParen",
                                    nesting: parenNesting
                                });
                                parenNesting++;
                                postfixIncDec = false;
                                break;
                            case ")":
                                parenNesting--;
                                postfixIncDec = true;
                                if ("JSNonExpressionParen" === mode.tag && parenNesting === mode.nesting) {
                                    stack.pop();
                                    nextLastSignificantToken = "?NonExpressionParenEnd";
                                    postfixIncDec = false;
                                }
                                break;
                            case "{":
                                Punctuator.lastIndex = 0;
                                isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));
                                braces.push(isExpression);
                                postfixIncDec = false;
                                break;
                            case "}":
                                switch(mode.tag){
                                    case "InterpolationInTemplate":
                                        if (braces.length === mode.nesting) {
                                            Template.lastIndex = lastIndex;
                                            match = Template.exec(input);
                                            lastIndex = Template.lastIndex;
                                            lastSignificantToken = match[0];
                                            if ("${" === match[1]) {
                                                lastSignificantToken = "?InterpolationInTemplate";
                                                postfixIncDec = false;
                                                yield {
                                                    type: "TemplateMiddle",
                                                    value: match[0]
                                                };
                                            } else {
                                                stack.pop();
                                                postfixIncDec = true;
                                                yield {
                                                    type: "TemplateTail",
                                                    value: match[0],
                                                    closed: "`" === match[1]
                                                };
                                            }
                                            continue;
                                        }
                                        break;
                                    case "InterpolationInJSX":
                                        if (braces.length === mode.nesting) {
                                            stack.pop();
                                            lastIndex += 1;
                                            lastSignificantToken = "}";
                                            yield {
                                                type: "JSXPunctuator",
                                                value: "}"
                                            };
                                            continue;
                                        }
                                }
                                postfixIncDec = braces.pop();
                                nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
                                break;
                            case "]":
                                postfixIncDec = true;
                                break;
                            case "++":
                            case "--":
                                nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
                                break;
                            case "<":
                                if (jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
                                    stack.push({
                                        tag: "JSXTag"
                                    });
                                    lastIndex += 1;
                                    lastSignificantToken = "<";
                                    yield {
                                        type: "JSXPunctuator",
                                        value: punctuator
                                    };
                                    continue;
                                }
                                postfixIncDec = false;
                                break;
                            default:
                                postfixIncDec = false;
                        }
                        lastIndex = nextLastIndex;
                        lastSignificantToken = nextLastSignificantToken;
                        yield {
                            type: "Punctuator",
                            value: punctuator
                        };
                        continue;
                    }
                    Identifier.lastIndex = lastIndex;
                    if (match = Identifier.exec(input)) {
                        lastIndex = Identifier.lastIndex;
                        nextLastSignificantToken = match[0];
                        switch(match[0]){
                            case "for":
                            case "if":
                            case "while":
                            case "with":
                                if ("." !== lastSignificantToken && "?." !== lastSignificantToken) nextLastSignificantToken = "?NonExpressionParenKeyword";
                        }
                        lastSignificantToken = nextLastSignificantToken;
                        postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);
                        yield {
                            type: "#" === match[1] ? "PrivateIdentifier" : "IdentifierName",
                            value: match[0]
                        };
                        continue;
                    }
                    StringLiteral.lastIndex = lastIndex;
                    if (match = StringLiteral.exec(input)) {
                        lastIndex = StringLiteral.lastIndex;
                        lastSignificantToken = match[0];
                        postfixIncDec = true;
                        yield {
                            type: "StringLiteral",
                            value: match[0],
                            closed: void 0 !== match[2]
                        };
                        continue;
                    }
                    NumericLiteral.lastIndex = lastIndex;
                    if (match = NumericLiteral.exec(input)) {
                        lastIndex = NumericLiteral.lastIndex;
                        lastSignificantToken = match[0];
                        postfixIncDec = true;
                        yield {
                            type: "NumericLiteral",
                            value: match[0]
                        };
                        continue;
                    }
                    Template.lastIndex = lastIndex;
                    if (match = Template.exec(input)) {
                        lastIndex = Template.lastIndex;
                        lastSignificantToken = match[0];
                        if ("${" === match[1]) {
                            lastSignificantToken = "?InterpolationInTemplate";
                            stack.push({
                                tag: "InterpolationInTemplate",
                                nesting: braces.length
                            });
                            postfixIncDec = false;
                            yield {
                                type: "TemplateHead",
                                value: match[0]
                            };
                        } else {
                            postfixIncDec = true;
                            yield {
                                type: "NoSubstitutionTemplate",
                                value: match[0],
                                closed: "`" === match[1]
                            };
                        }
                        continue;
                    }
                    break;
                case "JSXTag":
                case "JSXTagEnd":
                    JSXPunctuator.lastIndex = lastIndex;
                    if (match = JSXPunctuator.exec(input)) {
                        lastIndex = JSXPunctuator.lastIndex;
                        nextLastSignificantToken = match[0];
                        switch(match[0]){
                            case "<":
                                stack.push({
                                    tag: "JSXTag"
                                });
                                break;
                            case ">":
                                stack.pop();
                                if ("/" === lastSignificantToken || "JSXTagEnd" === mode.tag) {
                                    nextLastSignificantToken = "?JSX";
                                    postfixIncDec = true;
                                } else stack.push({
                                    tag: "JSXChildren"
                                });
                                break;
                            case "{":
                                stack.push({
                                    tag: "InterpolationInJSX",
                                    nesting: braces.length
                                });
                                nextLastSignificantToken = "?InterpolationInJSX";
                                postfixIncDec = false;
                                break;
                            case "/":
                                if ("<" === lastSignificantToken) {
                                    stack.pop();
                                    if ("JSXChildren" === stack[stack.length - 1].tag) stack.pop();
                                    stack.push({
                                        tag: "JSXTagEnd"
                                    });
                                }
                        }
                        lastSignificantToken = nextLastSignificantToken;
                        yield {
                            type: "JSXPunctuator",
                            value: match[0]
                        };
                        continue;
                    }
                    JSXIdentifier.lastIndex = lastIndex;
                    if (match = JSXIdentifier.exec(input)) {
                        lastIndex = JSXIdentifier.lastIndex;
                        lastSignificantToken = match[0];
                        yield {
                            type: "JSXIdentifier",
                            value: match[0]
                        };
                        continue;
                    }
                    JSXString.lastIndex = lastIndex;
                    if (match = JSXString.exec(input)) {
                        lastIndex = JSXString.lastIndex;
                        lastSignificantToken = match[0];
                        yield {
                            type: "JSXString",
                            value: match[0],
                            closed: void 0 !== match[2]
                        };
                        continue;
                    }
                    break;
                case "JSXChildren":
                    JSXText.lastIndex = lastIndex;
                    if (match = JSXText.exec(input)) {
                        lastIndex = JSXText.lastIndex;
                        lastSignificantToken = match[0];
                        yield {
                            type: "JSXText",
                            value: match[0]
                        };
                        continue;
                    }
                    switch(input[lastIndex]){
                        case "<":
                            stack.push({
                                tag: "JSXTag"
                            });
                            lastIndex++;
                            lastSignificantToken = "<";
                            yield {
                                type: "JSXPunctuator",
                                value: "<"
                            };
                            continue;
                        case "{":
                            stack.push({
                                tag: "InterpolationInJSX",
                                nesting: braces.length
                            });
                            lastIndex++;
                            lastSignificantToken = "?InterpolationInJSX";
                            postfixIncDec = false;
                            yield {
                                type: "JSXPunctuator",
                                value: "{"
                            };
                            continue;
                    }
            }
            WhiteSpace.lastIndex = lastIndex;
            if (match = WhiteSpace.exec(input)) {
                lastIndex = WhiteSpace.lastIndex;
                yield {
                    type: "WhiteSpace",
                    value: match[0]
                };
                continue;
            }
            LineTerminatorSequence.lastIndex = lastIndex;
            if (match = LineTerminatorSequence.exec(input)) {
                lastIndex = LineTerminatorSequence.lastIndex;
                postfixIncDec = false;
                if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) lastSignificantToken = "?NoLineTerminatorHere";
                yield {
                    type: "LineTerminatorSequence",
                    value: match[0]
                };
                continue;
            }
            MultiLineComment.lastIndex = lastIndex;
            if (match = MultiLineComment.exec(input)) {
                lastIndex = MultiLineComment.lastIndex;
                if (Newline.test(match[0])) {
                    postfixIncDec = false;
                    if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) lastSignificantToken = "?NoLineTerminatorHere";
                }
                yield {
                    type: "MultiLineComment",
                    value: match[0],
                    closed: void 0 !== match[1]
                };
                continue;
            }
            SingleLineComment.lastIndex = lastIndex;
            if (match = SingleLineComment.exec(input)) {
                lastIndex = SingleLineComment.lastIndex;
                postfixIncDec = false;
                yield {
                    type: "SingleLineComment",
                    value: match[0]
                };
                continue;
            }
            firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));
            lastIndex += firstCodePoint.length;
            lastSignificantToken = firstCodePoint;
            postfixIncDec = false;
            yield {
                type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
                value: firstCodePoint
            };
        }
    };
    return jsTokens_1;
}
requireJsTokens();
var reservedWords = {
    keyword: [
        "break",
        "case",
        "catch",
        "continue",
        "debugger",
        "default",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "return",
        "switch",
        "throw",
        "try",
        "var",
        "const",
        "while",
        "with",
        "new",
        "this",
        "super",
        "class",
        "extends",
        "export",
        "import",
        "null",
        "true",
        "false",
        "in",
        "instanceof",
        "typeof",
        "void",
        "delete"
    ],
    strict: [
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        "yield"
    ]
};
new Set(reservedWords.keyword);
new Set(reservedWords.strict);
var snapshot_dist_f = {
    reset: [
        0,
        0
    ],
    bold: [
        1,
        22,
        "\x1B[22m\x1B[1m"
    ],
    dim: [
        2,
        22,
        "\x1B[22m\x1B[2m"
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    inverse: [
        7,
        27
    ],
    hidden: [
        8,
        28
    ],
    strikethrough: [
        9,
        29
    ],
    black: [
        30,
        39
    ],
    red: [
        31,
        39
    ],
    green: [
        32,
        39
    ],
    yellow: [
        33,
        39
    ],
    blue: [
        34,
        39
    ],
    magenta: [
        35,
        39
    ],
    cyan: [
        36,
        39
    ],
    white: [
        37,
        39
    ],
    gray: [
        90,
        39
    ],
    bgBlack: [
        40,
        49
    ],
    bgRed: [
        41,
        49
    ],
    bgGreen: [
        42,
        49
    ],
    bgYellow: [
        43,
        49
    ],
    bgBlue: [
        44,
        49
    ],
    bgMagenta: [
        45,
        49
    ],
    bgCyan: [
        46,
        49
    ],
    bgWhite: [
        47,
        49
    ],
    blackBright: [
        90,
        39
    ],
    redBright: [
        91,
        39
    ],
    greenBright: [
        92,
        39
    ],
    yellowBright: [
        93,
        39
    ],
    blueBright: [
        94,
        39
    ],
    magentaBright: [
        95,
        39
    ],
    cyanBright: [
        96,
        39
    ],
    whiteBright: [
        97,
        39
    ],
    bgBlackBright: [
        100,
        49
    ],
    bgRedBright: [
        101,
        49
    ],
    bgGreenBright: [
        102,
        49
    ],
    bgYellowBright: [
        103,
        49
    ],
    bgBlueBright: [
        104,
        49
    ],
    bgMagentaBright: [
        105,
        49
    ],
    bgCyanBright: [
        106,
        49
    ],
    bgWhiteBright: [
        107,
        49
    ]
}, snapshot_dist_h = Object.entries(snapshot_dist_f);
function dist_a(n) {
    return String(n);
}
dist_a.open = "";
dist_a.close = "";
function dist_C(n = false) {
    let e = "undefined" != typeof process ? process : void 0, i = (null == e ? void 0 : e.env) || {}, g = (null == e ? void 0 : e.argv) || [];
    return !("NO_COLOR" in i || g.includes("--no-color")) && ("FORCE_COLOR" in i || g.includes("--color") || (null == e ? void 0 : e.platform) === "win32" || n && "dumb" !== i.TERM || "CI" in i) || "undefined" != typeof window && !!window.chrome;
}
function dist_p(n = false) {
    let e = dist_C(n), i = (r, t, c, o)=>{
        let l = "", s = 0;
        do l += r.substring(s, o) + c, s = o + t.length, o = r.indexOf(t, s);
        while (~o);
        return l + r.substring(s);
    }, g = (r, t, c = r)=>{
        let o = (l)=>{
            let s = String(l), b = s.indexOf(t, r.length);
            return ~b ? r + i(s, t, c, b) + t : r + s + t;
        };
        return o.open = r, o.close = t, o;
    }, u = {
        isColorSupported: e
    }, d = (r)=>`\x1B[${r}m`;
    for (let [r, t] of snapshot_dist_h)u[r] = e ? g(d(t[0]), d(t[1]), t[2]) : dist_a;
    return u;
}
dist_p();
const lineSplitRE = /\r?\n/;
function positionToOffset(source, lineNumber, columnNumber) {
    const lines = source.split(lineSplitRE);
    const nl = /\r\n/.test(source) ? 2 : 1;
    let start = 0;
    if (lineNumber > lines.length) return source.length;
    for(let i = 0; i < lineNumber - 1; i++)start += lines[i].length + nl;
    return start + columnNumber;
}
function offsetToLineNumber(source, offset) {
    if (offset > source.length) throw new Error(`offset is longer than source length! offset ${offset} > length ${source.length}`);
    const lines = source.split(lineSplitRE);
    const nl = /\r\n/.test(source) ? 2 : 1;
    let counted = 0;
    let line = 0;
    for(; line < lines.length; line++){
        const lineLength = lines[line].length + nl;
        if (counted + lineLength >= offset) break;
        counted += lineLength;
    }
    return line + 1;
}
async function saveInlineSnapshots(environment, snapshots) {
    const MagicString = (await import("./0~907.js").then((mod)=>({
            Bundle: mod.Bundle,
            SourceMap: mod.SourceMap,
            default: mod.MagicString
        }))).default;
    const files = new Set(snapshots.map((i)=>i.file));
    await Promise.all(Array.from(files).map(async (file)=>{
        const snaps = snapshots.filter((i)=>i.file === file);
        const code = await environment.readSnapshotFile(file);
        const s = new MagicString(code);
        for (const snap of snaps){
            const index = positionToOffset(code, snap.line, snap.column);
            replaceInlineSnap(code, s, index, snap.snapshot);
        }
        const transformed = s.toString();
        if (transformed !== code) await environment.saveSnapshotFile(file, transformed);
    }));
}
const startObjectRegex = /(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\s*\(\s*(?:\/\*[\s\S]*\*\/\s*|\/\/.*(?:[\n\r\u2028\u2029]\s*|[\t\v\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]))*\{/;
function replaceObjectSnap(code, s, index, newSnap) {
    let _code = code.slice(index);
    const startMatch = startObjectRegex.exec(_code);
    if (!startMatch) return false;
    _code = _code.slice(startMatch.index);
    let callEnd = dist_getCallLastIndex(_code);
    if (null === callEnd) return false;
    callEnd += index + startMatch.index;
    const shapeStart = index + startMatch.index + startMatch[0].length;
    const shapeEnd = getObjectShapeEndIndex(code, shapeStart);
    const snap = `, ${prepareSnapString(newSnap, code, index)}`;
    if (shapeEnd === callEnd) s.appendLeft(callEnd, snap);
    else s.overwrite(shapeEnd, callEnd, snap);
    return true;
}
function getObjectShapeEndIndex(code, index) {
    let startBraces = 1;
    let endBraces = 0;
    while(startBraces !== endBraces && index < code.length){
        const s = code[index++];
        if ("{" === s) startBraces++;
        else if ("}" === s) endBraces++;
    }
    return index;
}
function prepareSnapString(snap, source, index) {
    const lineNumber = offsetToLineNumber(source, index);
    const line = source.split(lineSplitRE)[lineNumber - 1];
    const indent = line.match(/^\s*/)[0] || "";
    const indentNext = indent.includes("	") ? `${indent}\t` : `${indent}  `;
    const lines = snap.trim().replace(/\\/g, "\\\\").split(/\n/g);
    const isOneline = lines.length <= 1;
    const quote = "`";
    if (isOneline) return `${quote}${lines.join("\n").replace(/`/g, "\\`").replace(/\$\{/g, "\\${")}${quote}`;
    return `${quote}\n${lines.map((i)=>i ? indentNext + i : "").join("\n").replace(/`/g, "\\`").replace(/\$\{/g, "\\${")}\n${indent}${quote}`;
}
const toMatchInlineName = "toMatchInlineSnapshot";
const toThrowErrorMatchingInlineName = "toThrowErrorMatchingInlineSnapshot";
function getCodeStartingAtIndex(code, index) {
    const indexInline = index - toMatchInlineName.length;
    if (code.slice(indexInline, index) === toMatchInlineName) return {
        code: code.slice(indexInline),
        index: indexInline
    };
    const indexThrowInline = index - toThrowErrorMatchingInlineName.length;
    if (code.slice(index - indexThrowInline, index) === toThrowErrorMatchingInlineName) return {
        code: code.slice(index - indexThrowInline),
        index: index - indexThrowInline
    };
    return {
        code: code.slice(index),
        index
    };
}
const startRegex = /(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\s*\(\s*(?:\/\*[\s\S]*\*\/\s*|\/\/.*(?:[\n\r\u2028\u2029]\s*|[\t\v\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]))*[\w$]*(['"`)])/;
function replaceInlineSnap(code, s, currentIndex, newSnap) {
    const { code: codeStartingAtIndex, index } = getCodeStartingAtIndex(code, currentIndex);
    const startMatch = startRegex.exec(codeStartingAtIndex);
    const firstKeywordMatch = /toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot/.exec(codeStartingAtIndex);
    if (!startMatch || startMatch.index !== (null == firstKeywordMatch ? void 0 : firstKeywordMatch.index)) return replaceObjectSnap(code, s, index, newSnap);
    const quote = startMatch[1];
    const startIndex = index + startMatch.index + startMatch[0].length;
    const snapString = prepareSnapString(newSnap, code, index);
    if (")" === quote) {
        s.appendRight(startIndex - 1, snapString);
        return true;
    }
    const quoteEndRE = new RegExp(`(?:^|[^\\\\])${quote}`);
    const endMatch = quoteEndRE.exec(code.slice(startIndex));
    if (!endMatch) return false;
    const endIndex = startIndex + endMatch.index + endMatch[0].length;
    s.overwrite(startIndex - 1, endIndex, snapString);
    return true;
}
const INDENTATION_REGEX = /^([^\S\n]*)\S/m;
function stripSnapshotIndentation(inlineSnapshot) {
    const match = inlineSnapshot.match(INDENTATION_REGEX);
    if (!match || !match[1]) return inlineSnapshot;
    const indentation = match[1];
    const lines = inlineSnapshot.split(/\n/g);
    if (lines.length <= 2) return inlineSnapshot;
    if ("" !== lines[0].trim() || "" !== lines[lines.length - 1].trim()) return inlineSnapshot;
    for(let i = 1; i < lines.length - 1; i++)if ("" !== lines[i]) {
        if (0 !== lines[i].indexOf(indentation)) return inlineSnapshot;
        lines[i] = lines[i].substring(indentation.length);
    }
    lines[lines.length - 1] = "";
    inlineSnapshot = lines.join("\n");
    return inlineSnapshot;
}
async function saveRawSnapshots(environment, snapshots) {
    await Promise.all(snapshots.map(async (snap)=>{
        if (!snap.readonly) await environment.saveSnapshotFile(snap.file, snap.snapshot);
    }));
}
var naturalCompare$1 = {
    exports: {}
};
var hasRequiredNaturalCompare;
function requireNaturalCompare() {
    if (hasRequiredNaturalCompare) return naturalCompare$1.exports;
    hasRequiredNaturalCompare = 1;
    /*
	 * @version    1.4.0
	 * @date       2015-10-26
	 * @stability  3 - Stable
	 * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
	 * @license    MIT License
	 */ var naturalCompare = function(a, b) {
        var i, codeA, codeB = 1, posA = 0, posB = 0, alphabet = String.alphabet;
        function getCode(str, pos, code) {
            if (code) {
                for(i = pos; code = getCode(str, i), code < 76 && code > 65;)++i;
                return +str.slice(pos - 1, i);
            }
            code = alphabet && alphabet.indexOf(str.charAt(pos));
            return code > -1 ? code + 76 : (code = str.charCodeAt(pos) || 0, code < 45 || code > 127) ? code : code < 46 ? 65 : code < 48 ? code - 1 : code < 58 ? code + 18 : code < 65 ? code - 11 : code < 91 ? code + 11 : code < 97 ? code - 37 : code < 123 ? code + 5 : code - 63;
        }
        if ((a += "") != (b += "")) for(; codeB;){
            codeA = getCode(a, posA++);
            codeB = getCode(b, posB++);
            if (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {
                codeA = getCode(a, posA, posA);
                codeB = getCode(b, posB, posA = i);
                posB = i;
            }
            if (codeA != codeB) return codeA < codeB ? -1 : 1;
        }
        return 0;
    };
    try {
        naturalCompare$1.exports = naturalCompare;
    } catch (e) {
        String.naturalCompare = naturalCompare;
    }
    return naturalCompare$1.exports;
}
var naturalCompareExports = requireNaturalCompare();
var dist_naturalCompare = /*@__PURE__*/ dist_getDefaultExportFromCjs(naturalCompareExports);
const dist_serialize$1 = (val, config, indentation, depth, refs, printer)=>{
    const name = val.getMockName();
    const nameString = "vi.fn()" === name ? "" : ` ${name}`;
    let callsString = "";
    if (0 !== val.mock.calls.length) {
        const indentationNext = indentation + config.indent;
        callsString = ` {${config.spacingOuter}${indentationNext}"calls": ${printer(val.mock.calls, config, indentationNext, depth, refs)}${config.min ? ", " : ","}${config.spacingOuter}${indentationNext}"results": ${printer(val.mock.results, config, indentationNext, depth, refs)}${config.min ? "" : ","}${config.spacingOuter}${indentation}}`;
    }
    return `[MockFunction${nameString}]${callsString}`;
};
const snapshot_dist_test = (val)=>val && !!val._isMockFunction;
const snapshot_dist_plugin = {
    serialize: dist_serialize$1,
    test: snapshot_dist_test
};
const { DOMCollection: dist_DOMCollection, DOMElement: dist_DOMElement, Immutable: dist_Immutable, ReactElement: dist_ReactElement, ReactTestComponent: dist_ReactTestComponent, AsymmetricMatcher: snapshot_dist_AsymmetricMatcher } = dist_plugins;
let dist_PLUGINS = [
    dist_ReactTestComponent,
    dist_ReactElement,
    dist_DOMElement,
    dist_DOMCollection,
    dist_Immutable,
    snapshot_dist_AsymmetricMatcher,
    snapshot_dist_plugin
];
function addSerializer(plugin) {
    dist_PLUGINS = [
        plugin
    ].concat(dist_PLUGINS);
}
function getSerializers() {
    return dist_PLUGINS;
}
function testNameToKey(testName, count) {
    return `${testName} ${count}`;
}
function keyToTestName(key) {
    if (!/ \d+$/.test(key)) throw new Error("Snapshot keys must end with a number.");
    return key.replace(/ \d+$/, "");
}
function getSnapshotData(content, options) {
    const update = options.updateSnapshot;
    const data = Object.create(null);
    let snapshotContents = "";
    let dirty = false;
    if (null != content) try {
        snapshotContents = content;
        const populate = new Function("exports", snapshotContents);
        populate(data);
    } catch  {}
    const isInvalid = snapshotContents;
    if (("all" === update || "new" === update) && isInvalid) dirty = true;
    return {
        data,
        dirty
    };
}
function addExtraLineBreaks(string) {
    return string.includes("\n") ? `\n${string}\n` : string;
}
function removeExtraLineBreaks(string) {
    return string.length > 2 && string.startsWith("\n") && string.endsWith("\n") ? string.slice(1, -1) : string;
}
const dist_escapeRegex = true;
const dist_printFunctionName = false;
function dist_serialize(val, indent = 2, formatOverrides = {}) {
    return normalizeNewlines(format(val, {
        escapeRegex: dist_escapeRegex,
        indent,
        plugins: getSerializers(),
        printFunctionName: dist_printFunctionName,
        ...formatOverrides
    }));
}
function escapeBacktickString(str) {
    return str.replace(/`|\\|\$\{/g, "\\$&");
}
function printBacktickString(str) {
    return `\`${escapeBacktickString(str)}\``;
}
function normalizeNewlines(string) {
    return string.replace(/\r\n|\r/g, "\n");
}
async function saveSnapshotFile(environment, snapshotData, snapshotPath) {
    const snapshots = Object.keys(snapshotData).sort(dist_naturalCompare).map((key)=>`exports[${printBacktickString(key)}] = ${printBacktickString(normalizeNewlines(snapshotData[key]))};`);
    const content = `${environment.getHeader()}\n\n${snapshots.join("\n\n")}\n`;
    const oldContent = await environment.readSnapshotFile(snapshotPath);
    const skipWriting = null != oldContent && oldContent === content;
    if (skipWriting) return;
    await environment.saveSnapshotFile(snapshotPath, content);
}
function deepMergeArray(target = [], source = []) {
    const mergedOutput = Array.from(target);
    source.forEach((sourceElement, index)=>{
        const targetElement = mergedOutput[index];
        if (Array.isArray(target[index])) mergedOutput[index] = deepMergeArray(target[index], sourceElement);
        else if (dist_isObject(targetElement)) mergedOutput[index] = deepMergeSnapshot(target[index], sourceElement);
        else mergedOutput[index] = sourceElement;
    });
    return mergedOutput;
}
function deepMergeSnapshot(target, source) {
    if (dist_isObject(target) && dist_isObject(source)) {
        const mergedOutput = {
            ...target
        };
        Object.keys(source).forEach((key)=>{
            if (dist_isObject(source[key]) && !source[key].$$typeof) if (key in target) mergedOutput[key] = deepMergeSnapshot(target[key], source[key]);
            else Object.assign(mergedOutput, {
                [key]: source[key]
            });
            else if (Array.isArray(source[key])) mergedOutput[key] = deepMergeArray(target[key], source[key]);
            else Object.assign(mergedOutput, {
                [key]: source[key]
            });
        });
        return mergedOutput;
    }
    if (Array.isArray(target) && Array.isArray(source)) return deepMergeArray(target, source);
    return target;
}
class DefaultMap extends Map {
    constructor(defaultFn, entries){
        super(entries);
        this.defaultFn = defaultFn;
    }
    get(key) {
        if (!this.has(key)) this.set(key, this.defaultFn(key));
        return super.get(key);
    }
}
class CounterMap extends DefaultMap {
    constructor(){
        super(()=>0);
    }
    _total;
    valueOf() {
        return this._total = this.total();
    }
    increment(key) {
        if (void 0 !== this._total) this._total++;
        this.set(key, this.get(key) + 1);
    }
    total() {
        if (void 0 !== this._total) return this._total;
        let total = 0;
        for (const x of this.values())total += x;
        return total;
    }
}
function isSameStackPosition(x, y) {
    return x.file === y.file && x.column === y.column && x.line === y.line;
}
class SnapshotState {
    _counters = new CounterMap();
    _dirty;
    _updateSnapshot;
    _snapshotData;
    _initialData;
    _inlineSnapshots;
    _inlineSnapshotStacks;
    _testIdToKeys = new DefaultMap(()=>[]);
    _rawSnapshots;
    _uncheckedKeys;
    _snapshotFormat;
    _environment;
    _fileExists;
    expand;
    _added = new CounterMap();
    _matched = new CounterMap();
    _unmatched = new CounterMap();
    _updated = new CounterMap();
    get added() {
        return this._added;
    }
    set added(value) {
        this._added._total = value;
    }
    get matched() {
        return this._matched;
    }
    set matched(value) {
        this._matched._total = value;
    }
    get unmatched() {
        return this._unmatched;
    }
    set unmatched(value) {
        this._unmatched._total = value;
    }
    get updated() {
        return this._updated;
    }
    set updated(value) {
        this._updated._total = value;
    }
    constructor(testFilePath, snapshotPath, snapshotContent, options){
        this.testFilePath = testFilePath;
        this.snapshotPath = snapshotPath;
        const { data, dirty } = getSnapshotData(snapshotContent, options);
        this._fileExists = null != snapshotContent;
        this._initialData = {
            ...data
        };
        this._snapshotData = {
            ...data
        };
        this._dirty = dirty;
        this._inlineSnapshots = [];
        this._inlineSnapshotStacks = [];
        this._rawSnapshots = [];
        this._uncheckedKeys = new Set(Object.keys(this._snapshotData));
        this.expand = options.expand || false;
        this._updateSnapshot = options.updateSnapshot;
        this._snapshotFormat = {
            printBasicPrototype: false,
            escapeString: false,
            ...options.snapshotFormat
        };
        this._environment = options.snapshotEnvironment;
    }
    static async create(testFilePath, options) {
        const snapshotPath = await options.snapshotEnvironment.resolvePath(testFilePath);
        const content = await options.snapshotEnvironment.readSnapshotFile(snapshotPath);
        return new SnapshotState(testFilePath, snapshotPath, content, options);
    }
    get environment() {
        return this._environment;
    }
    markSnapshotsAsCheckedForTest(testName) {
        this._uncheckedKeys.forEach((uncheckedKey)=>{
            if (/ \d+$| > /.test(uncheckedKey.slice(testName.length))) this._uncheckedKeys.delete(uncheckedKey);
        });
    }
    clearTest(testId) {
        this._inlineSnapshots = this._inlineSnapshots.filter((s)=>s.testId !== testId);
        this._inlineSnapshotStacks = this._inlineSnapshotStacks.filter((s)=>s.testId !== testId);
        for (const key of this._testIdToKeys.get(testId)){
            const name = keyToTestName(key);
            const count = this._counters.get(name);
            if (count > 0) {
                if (key in this._snapshotData || key in this._initialData) this._snapshotData[key] = this._initialData[key];
                this._counters.set(name, count - 1);
            }
        }
        this._testIdToKeys.delete(testId);
        this.added.delete(testId);
        this.updated.delete(testId);
        this.matched.delete(testId);
        this.unmatched.delete(testId);
    }
    _inferInlineSnapshotStack(stacks) {
        const promiseIndex = stacks.findIndex((i)=>i.method.match(/__VITEST_(RESOLVES|REJECTS)__/));
        if (-1 !== promiseIndex) return stacks[promiseIndex + 3];
        const stackIndex = stacks.findIndex((i)=>i.method.includes("__INLINE_SNAPSHOT__"));
        return -1 !== stackIndex ? stacks[stackIndex + 2] : null;
    }
    _addSnapshot(key, receivedSerialized, options) {
        this._dirty = true;
        if (options.stack) this._inlineSnapshots.push({
            snapshot: receivedSerialized,
            testId: options.testId,
            ...options.stack
        });
        else if (options.rawSnapshot) this._rawSnapshots.push({
            ...options.rawSnapshot,
            snapshot: receivedSerialized
        });
        else this._snapshotData[key] = receivedSerialized;
    }
    async save() {
        const hasExternalSnapshots = Object.keys(this._snapshotData).length;
        const hasInlineSnapshots = this._inlineSnapshots.length;
        const hasRawSnapshots = this._rawSnapshots.length;
        const isEmpty = !hasExternalSnapshots && !hasInlineSnapshots && !hasRawSnapshots;
        const status = {
            deleted: false,
            saved: false
        };
        if ((this._dirty || this._uncheckedKeys.size) && !isEmpty) {
            if (hasExternalSnapshots) {
                await saveSnapshotFile(this._environment, this._snapshotData, this.snapshotPath);
                this._fileExists = true;
            }
            if (hasInlineSnapshots) await saveInlineSnapshots(this._environment, this._inlineSnapshots);
            if (hasRawSnapshots) await saveRawSnapshots(this._environment, this._rawSnapshots);
            status.saved = true;
        } else if (!hasExternalSnapshots && this._fileExists) {
            if ("all" === this._updateSnapshot) {
                await this._environment.removeSnapshotFile(this.snapshotPath);
                this._fileExists = false;
            }
            status.deleted = true;
        }
        return status;
    }
    getUncheckedCount() {
        return this._uncheckedKeys.size || 0;
    }
    getUncheckedKeys() {
        return Array.from(this._uncheckedKeys);
    }
    removeUncheckedKeys() {
        if ("all" === this._updateSnapshot && this._uncheckedKeys.size) {
            this._dirty = true;
            this._uncheckedKeys.forEach((key)=>delete this._snapshotData[key]);
            this._uncheckedKeys.clear();
        }
    }
    match({ testId, testName, received, key, inlineSnapshot, isInline, error, rawSnapshot }) {
        this._counters.increment(testName);
        const count = this._counters.get(testName);
        if (!key) key = testNameToKey(testName, count);
        this._testIdToKeys.get(testId).push(key);
        if (!(isInline && void 0 !== this._snapshotData[key])) this._uncheckedKeys.delete(key);
        let receivedSerialized = rawSnapshot && "string" == typeof received ? received : dist_serialize(received, void 0, this._snapshotFormat);
        if (!rawSnapshot) receivedSerialized = addExtraLineBreaks(receivedSerialized);
        if (rawSnapshot) {
            if (rawSnapshot.content && rawSnapshot.content.match(/\r\n/) && !receivedSerialized.match(/\r\n/)) rawSnapshot.content = normalizeNewlines(rawSnapshot.content);
        }
        const expected = isInline ? inlineSnapshot : rawSnapshot ? rawSnapshot.content : this._snapshotData[key];
        const expectedTrimmed = rawSnapshot ? expected : null == expected ? void 0 : expected.trim();
        const pass = expectedTrimmed === (rawSnapshot ? receivedSerialized : receivedSerialized.trim());
        const hasSnapshot = void 0 !== expected;
        const snapshotIsPersisted = isInline || this._fileExists || rawSnapshot && null != rawSnapshot.content;
        if (pass && !isInline && !rawSnapshot) this._snapshotData[key] = receivedSerialized;
        let stack;
        if (isInline) {
            var _this$environment$pro, _this$environment;
            const stacks = parseErrorStacktrace(error || new Error("snapshot"), {
                ignoreStackEntries: []
            });
            const _stack = this._inferInlineSnapshotStack(stacks);
            if (!_stack) throw new Error(`@vitest/snapshot: Couldn't infer stack frame for inline snapshot.\n${JSON.stringify(stacks)}`);
            stack = (null == (_this$environment$pro = (_this$environment = this.environment).processStackTrace) ? void 0 : _this$environment$pro.call(_this$environment, _stack)) || _stack;
            stack.column--;
            const snapshotsWithSameStack = this._inlineSnapshotStacks.filter((s)=>isSameStackPosition(s, stack));
            if (snapshotsWithSameStack.length > 0) {
                this._inlineSnapshots = this._inlineSnapshots.filter((s)=>!isSameStackPosition(s, stack));
                const differentSnapshot = snapshotsWithSameStack.find((s)=>s.snapshot !== receivedSerialized);
                if (differentSnapshot) throw Object.assign(new Error("toMatchInlineSnapshot with different snapshots cannot be called at the same location"), {
                    actual: receivedSerialized,
                    expected: differentSnapshot.snapshot
                });
            }
            this._inlineSnapshotStacks.push({
                ...stack,
                testId,
                snapshot: receivedSerialized
            });
        }
        if ((!hasSnapshot || "all" !== this._updateSnapshot) && (hasSnapshot && snapshotIsPersisted || "new" !== this._updateSnapshot && "all" !== this._updateSnapshot)) if (pass) {
            this.matched.increment(testId);
            return {
                actual: "",
                count,
                expected: "",
                key,
                pass: true
            };
        } else {
            this.unmatched.increment(testId);
            return {
                actual: rawSnapshot ? receivedSerialized : removeExtraLineBreaks(receivedSerialized),
                count,
                expected: void 0 !== expectedTrimmed ? rawSnapshot ? expectedTrimmed : removeExtraLineBreaks(expectedTrimmed) : void 0,
                key,
                pass: false
            };
        }
        if ("all" === this._updateSnapshot) if (pass) this.matched.increment(testId);
        else {
            if (hasSnapshot) this.updated.increment(testId);
            else this.added.increment(testId);
            this._addSnapshot(key, receivedSerialized, {
                stack,
                testId,
                rawSnapshot
            });
        }
        else {
            this._addSnapshot(key, receivedSerialized, {
                stack,
                testId,
                rawSnapshot
            });
            this.added.increment(testId);
        }
        return {
            actual: "",
            count,
            expected: "",
            key,
            pass: true
        };
    }
    async pack() {
        const snapshot = {
            filepath: this.testFilePath,
            added: 0,
            fileDeleted: false,
            matched: 0,
            unchecked: 0,
            uncheckedKeys: [],
            unmatched: 0,
            updated: 0
        };
        const uncheckedCount = this.getUncheckedCount();
        const uncheckedKeys = this.getUncheckedKeys();
        if (uncheckedCount) this.removeUncheckedKeys();
        const status = await this.save();
        snapshot.fileDeleted = status.deleted;
        snapshot.added = this.added.total();
        snapshot.matched = this.matched.total();
        snapshot.unmatched = this.unmatched.total();
        snapshot.updated = this.updated.total();
        snapshot.unchecked = status.deleted ? 0 : uncheckedCount;
        snapshot.uncheckedKeys = Array.from(uncheckedKeys);
        return snapshot;
    }
}
function createMismatchError(message, expand, actual, expected) {
    const error = new Error(message);
    Object.defineProperty(error, "actual", {
        value: actual,
        enumerable: true,
        configurable: true,
        writable: true
    });
    Object.defineProperty(error, "expected", {
        value: expected,
        enumerable: true,
        configurable: true,
        writable: true
    });
    Object.defineProperty(error, "diffOptions", {
        value: {
            expand
        }
    });
    return error;
}
class SnapshotClient {
    snapshotStateMap = new Map();
    constructor(options = {}){
        this.options = options;
    }
    async setup(filepath, options) {
        if (this.snapshotStateMap.has(filepath)) return;
        this.snapshotStateMap.set(filepath, await SnapshotState.create(filepath, options));
    }
    async finish(filepath) {
        const state = this.getSnapshotState(filepath);
        const result = await state.pack();
        this.snapshotStateMap.delete(filepath);
        return result;
    }
    skipTest(filepath, testName) {
        const state = this.getSnapshotState(filepath);
        state.markSnapshotsAsCheckedForTest(testName);
    }
    clearTest(filepath, testId) {
        const state = this.getSnapshotState(filepath);
        state.clearTest(testId);
    }
    getSnapshotState(filepath) {
        const state = this.snapshotStateMap.get(filepath);
        if (!state) throw new Error(`The snapshot state for '${filepath}' is not found. Did you call 'SnapshotClient.setup()'?`);
        return state;
    }
    assert(options) {
        const { filepath, name, testId = name, message, isInline = false, properties, inlineSnapshot, error, errorMessage, rawSnapshot } = options;
        let { received } = options;
        if (!filepath) throw new Error("Snapshot cannot be used outside of test");
        const snapshotState = this.getSnapshotState(filepath);
        if ("object" == typeof properties) {
            if ("object" != typeof received || !received) throw new Error("Received value must be an object when the matcher has properties");
            try {
                var _this$options$isEqual, _this$options;
                const pass = (null == (_this$options$isEqual = (_this$options = this.options).isEqual) ? void 0 : _this$options$isEqual.call(_this$options, received, properties)) ?? false;
                if (pass) received = deepMergeSnapshot(received, properties);
                else throw createMismatchError("Snapshot properties mismatched", snapshotState.expand, received, properties);
            } catch (err) {
                err.message = errorMessage || "Snapshot mismatched";
                throw err;
            }
        }
        const testName = [
            name,
            ...message ? [
                message
            ] : []
        ].join(" > ");
        const { actual, expected, key, pass } = snapshotState.match({
            testId,
            testName,
            received,
            isInline,
            error,
            inlineSnapshot,
            rawSnapshot
        });
        if (!pass) throw createMismatchError(`Snapshot \`${key || "unknown"}\` mismatched`, snapshotState.expand, rawSnapshot ? actual : null == actual ? void 0 : actual.trim(), rawSnapshot ? expected : null == expected ? void 0 : expected.trim());
    }
    async assertRaw(options) {
        if (!options.rawSnapshot) throw new Error("Raw snapshot is required");
        const { filepath, rawSnapshot } = options;
        if (null == rawSnapshot.content) {
            if (!filepath) throw new Error("Snapshot cannot be used outside of test");
            const snapshotState = this.getSnapshotState(filepath);
            options.filepath || (options.filepath = filepath);
            rawSnapshot.file = await snapshotState.environment.resolveRawPath(filepath, rawSnapshot.file);
            rawSnapshot.content = await snapshotState.environment.readSnapshotFile(rawSnapshot.file) ?? void 0;
        }
        return this.assert(options);
    }
    clear() {
        this.snapshotStateMap.clear();
    }
}
let _client;
function getSnapshotClient() {
    if (!_client) _client = new SnapshotClient({
        isEqual: (received, expected)=>dist_equals(received, expected, [
                iterableEquality,
                subsetEquality
            ])
    });
    return _client;
}
function snapshot_recordAsyncExpect(_test, promise, assertion, error) {
    const test = _test;
    if (test && promise instanceof Promise) {
        promise = promise.finally(()=>{
            if (!test.promises) return;
            const index = test.promises.indexOf(promise);
            if (-1 !== index) test.promises.splice(index, 1);
        });
        if (!test.promises) test.promises = [];
        test.promises.push(promise);
        let resolved = false;
        test.onFinished ??= [];
        test.onFinished.push(()=>{
            if (!resolved) {
                const processor = globalThis.__vitest_worker__?.onFilterStackTrace || ((s)=>s || '');
                const stack = processor(error.stack);
                console.warn([
                    `Promise returned by \`${assertion}\` was not awaited. `,
                    'Rstest currently auto-awaits hanging assertions at the end of the test.',
                    'Please remember to await the assertion.\n',
                    stack
                ].join(''));
            }
        });
        return {
            then (onFulfilled, onRejected) {
                resolved = true;
                return promise.then(onFulfilled, onRejected);
            },
            catch (onRejected) {
                return promise.catch(onRejected);
            },
            finally (onFinally) {
                return promise.finally(onFinally);
            },
            [Symbol.toStringTag]: 'Promise'
        };
    }
    return promise;
}
function snapshot_createAssertionMessage(util, assertion, hasArgs) {
    const not = util.flag(assertion, 'negate') ? 'not.' : '';
    const name = `${util.flag(assertion, '_name')}(${hasArgs ? 'expected' : ''})`;
    const promiseName = util.flag(assertion, 'promise');
    const promise = promiseName ? `.${promiseName}` : '';
    return `expect(actual)${promise}.${not}${name}`;
}
function getError(expected, promise) {
    if ('function' != typeof expected) {
        if (!promise) throw new Error(`expected must be a function, received ${typeof expected}`);
        return expected;
    }
    try {
        expected();
    } catch (e) {
        return e;
    }
    throw new Error("snapshot function didn't throw");
}
function getTestMeta(test) {
    return {
        filepath: test.testPath,
        name: getTaskNameWithPrefix(test),
        testId: test.testId
    };
}
const SnapshotPlugin = (workerState)=>(chai, utils)=>{
        function getTest(obj) {
            const test = utils.flag(obj, 'vitest-test');
            return test;
        }
        function getTestOrThrow(assertionName, obj) {
            const test = getTest(obj);
            if (!test) throw new Error(`'${assertionName}' cannot be used without test context`);
            return test;
        }
        for (const key of [
            'matchSnapshot',
            'toMatchSnapshot'
        ])utils.addMethod(chai.Assertion.prototype, key, function(properties, message) {
            utils.flag(this, '_name', key);
            const isNot = utils.flag(this, 'negate');
            if (isNot) throw new Error(`${key} cannot be used with "not"`);
            const expected = utils.flag(this, 'object');
            const test = getTestOrThrow(key, this);
            if ('string' == typeof properties && void 0 === message) {
                message = properties;
                properties = void 0;
            }
            const errorMessage = utils.flag(this, 'message');
            getSnapshotClient().assert({
                received: expected,
                message,
                isInline: false,
                properties,
                errorMessage,
                ...getTestMeta(test)
            });
        });
        utils.addMethod(chai.Assertion.prototype, 'toMatchFileSnapshot', function(file, message) {
            utils.flag(this, '_name', 'toMatchFileSnapshot');
            const isNot = utils.flag(this, 'negate');
            if (isNot) throw new Error('toMatchFileSnapshot cannot be used with "not"');
            const error = new Error('resolves');
            const expected = utils.flag(this, 'object');
            const test = getTestOrThrow('toMatchFileSnapshot', this);
            const errorMessage = utils.flag(this, 'message');
            const promise = getSnapshotClient().assertRaw({
                received: expected,
                message,
                isInline: false,
                rawSnapshot: {
                    file
                },
                errorMessage,
                ...getTestMeta(test)
            });
            return snapshot_recordAsyncExpect(test, promise, snapshot_createAssertionMessage(utils, this, true), error);
        });
        utils.addMethod(chai.Assertion.prototype, 'toMatchInlineSnapshot', function __INLINE_SNAPSHOT__(properties, inlineSnapshot, message) {
            utils.flag(this, '_name', 'toMatchInlineSnapshot');
            const isNot = utils.flag(this, 'negate');
            if (isNot) throw new Error('toMatchInlineSnapshot cannot be used with "not"');
            const test = getTest(this);
            if (test) {
                const isInsideEach = test.each || test.inTestEach;
                if (isInsideEach) throw new Error('InlineSnapshot cannot be used inside of test.each or describe.each');
            }
            const expected = utils.flag(this, 'object');
            const error = utils.flag(this, 'error');
            if ('string' == typeof properties) {
                message = inlineSnapshot;
                inlineSnapshot = properties;
                properties = void 0;
            }
            if (inlineSnapshot) inlineSnapshot = stripSnapshotIndentation(inlineSnapshot);
            const errorMessage = utils.flag(this, 'message');
            getSnapshotClient().assert({
                received: expected,
                message,
                isInline: true,
                properties,
                inlineSnapshot,
                error,
                errorMessage,
                ...test ? getTestMeta(test) : {
                    filepath: workerState.testPath,
                    name: 'toMatchInlineSnapshot',
                    testId: String(workerState.taskId)
                }
            });
        });
        utils.addMethod(chai.Assertion.prototype, 'toThrowErrorMatchingSnapshot', function(message) {
            utils.flag(this, '_name', 'toThrowErrorMatchingSnapshot');
            const isNot = utils.flag(this, 'negate');
            if (isNot) throw new Error('toThrowErrorMatchingSnapshot cannot be used with "not"');
            const expected = utils.flag(this, 'object');
            const test = getTestOrThrow('toThrowErrorMatchingSnapshot', this);
            const promise = utils.flag(this, 'promise');
            const errorMessage = utils.flag(this, 'message');
            getSnapshotClient().assert({
                received: getError(expected, promise),
                message,
                errorMessage,
                ...getTestMeta(test)
            });
        });
        utils.addMethod(chai.Assertion.prototype, 'toThrowErrorMatchingInlineSnapshot', function __INLINE_SNAPSHOT__(inlineSnapshot, message) {
            const isNot = utils.flag(this, 'negate');
            if (isNot) throw new Error('toThrowErrorMatchingInlineSnapshot cannot be used with "not"');
            const test = getTest(this);
            if (test) {
                const isInsideEach = test.each || test.inTestEach;
                if (isInsideEach) throw new Error('InlineSnapshot cannot be used inside of test.each or describe.each');
            }
            const expected = utils.flag(this, 'object');
            const error = utils.flag(this, 'error');
            const promise = utils.flag(this, 'promise');
            const errorMessage = utils.flag(this, 'message');
            if (inlineSnapshot) inlineSnapshot = stripSnapshotIndentation(inlineSnapshot);
            getSnapshotClient().assert({
                received: getError(expected, promise),
                message,
                inlineSnapshot,
                isInline: true,
                error,
                errorMessage,
                ...test ? getTestMeta(test) : {
                    name: 'toThrowErrorMatchingInlineSnapshot',
                    filepath: workerState.testPath,
                    testId: String(workerState.taskId)
                }
            });
        });
        utils.addMethod(chai.expect, 'addSnapshotSerializer', addSerializer);
    };
const unsupported = [
    'matchSnapshot',
    'toMatchSnapshot',
    'toMatchInlineSnapshot',
    'toThrowErrorMatchingSnapshot',
    'toThrowErrorMatchingInlineSnapshot',
    'throws',
    'Throw',
    'throw',
    'toThrow',
    'toThrowError'
];
function createExpectPoll(expect) {
    return function poll(fn, options = {}) {
        const { interval = 50, timeout = 1000, message } = options;
        const assertion = expect(null, message).withContext({
            poll: true
        });
        fn = fn.bind(assertion);
        const test = utils_exports.flag(assertion, 'vitest-test');
        if (!test) throw new Error('expect.poll() must be called inside a test');
        const proxy = new Proxy(assertion, {
            get (target, key, receiver) {
                const assertionFunction = Reflect.get(target, key, receiver);
                if ('function' != typeof assertionFunction) return assertionFunction instanceof Assertion ? proxy : assertionFunction;
                if ('assert' === key) return assertionFunction;
                if ('string' == typeof key && unsupported.includes(key)) throw new SyntaxError(`expect.poll() is not supported in combination with .${key}(). Use rstest.waitFor() if your assertion condition is unstable.`);
                return function(...args) {
                    const STACK_TRACE_ERROR = new Error('STACK_TRACE_ERROR');
                    const promise = ()=>new Promise((resolve, reject)=>{
                            let intervalId;
                            let timeoutId;
                            let lastError;
                            const check = async ()=>{
                                try {
                                    utils_exports.flag(assertion, '_name', key);
                                    const obj = await fn();
                                    utils_exports.flag(assertion, 'object', obj);
                                    resolve(await assertionFunction.call(assertion, ...args));
                                    clearTimeout(intervalId);
                                    clearTimeout(timeoutId);
                                } catch (err) {
                                    lastError = err;
                                    if (!utils_exports.flag(assertion, '_isLastPollAttempt')) intervalId = getRealTimers().setTimeout(check, interval);
                                }
                            };
                            timeoutId = getRealTimers().setTimeout(()=>{
                                clearTimeout(intervalId);
                                utils_exports.flag(assertion, '_isLastPollAttempt', true);
                                const rejectWithCause = (cause)=>{
                                    reject(copyStackTrace(new Error(`Matcher did not succeed in ${timeout}ms`, {
                                        cause
                                    }), STACK_TRACE_ERROR));
                                };
                                check().then(()=>rejectWithCause(lastError)).catch((e)=>rejectWithCause(e));
                            }, timeout);
                            check();
                        });
                    let awaited = false;
                    test.onFinished ??= [];
                    test.onFinished.push(()=>{
                        if (!awaited) {
                            const negated = utils_exports.flag(assertion, 'negate') ? 'not.' : '';
                            const name = utils_exports.flag(assertion, '_poll.element') ? 'element(locator)' : 'poll(assertion)';
                            const assertionString = `expect.${name}.${negated}${String(key)}()`;
                            const error = new Error(`${assertionString} was not awaited. This assertion is asynchronous and must be awaited; otherwise, it is not executed to avoid unhandled rejections:\n\nawait ${assertionString}\n`);
                            throw copyStackTrace(error, STACK_TRACE_ERROR);
                        }
                    });
                    let resultPromise;
                    return {
                        then (onFulfilled, onRejected) {
                            awaited = true;
                            resultPromise ||= promise();
                            return resultPromise.then(onFulfilled, onRejected);
                        },
                        catch (onRejected) {
                            resultPromise ||= promise();
                            return resultPromise.catch(onRejected);
                        },
                        finally (onFinally) {
                            resultPromise ||= promise();
                            return resultPromise.finally(onFinally);
                        },
                        [Symbol.toStringTag]: 'Promise'
                    };
                };
            }
        });
        return proxy;
    };
}
function copyStackTrace(target, source) {
    if (void 0 !== source.stack) target.stack = source.stack.replace(source.message, target.message);
    return target;
}
function setupChaiConfig(config) {
    Object.assign(chai_config, config);
}
function createExpect({ getCurrentTest, workerState }) {
    use(JestExtend);
    use(JestChaiExpect);
    use(SnapshotPlugin(workerState));
    use(JestAsymmetricMatchers);
    const expect = (value, message)=>{
        const { assertionCalls } = getState(expect);
        setState({
            assertionCalls: assertionCalls + 1
        }, expect);
        const assert = chai_expect(value, message);
        const _test = getCurrentTest();
        if (_test) return assert.withTest(_test);
        return assert;
    };
    Object.assign(expect, chai_expect);
    Object.assign(expect, globalThis[ASYMMETRIC_MATCHERS_OBJECT]);
    expect.getState = ()=>getState(expect);
    expect.setState = (state)=>setState(state, expect);
    const globalState = getState(globalThis[GLOBAL_EXPECT]) || {};
    setState({
        ...globalState,
        assertionCalls: 0,
        isExpectingAssertions: false,
        isExpectingAssertionsError: null,
        expectedAssertionsNumber: null,
        expectedAssertionsNumberErrorGen: null,
        get testPath () {
            return workerState.testPath;
        }
    }, expect);
    expect.extend = (matchers)=>chai_expect.extend(expect, matchers);
    expect.addEqualityTesters = (customTesters)=>addCustomEqualityTesters(customTesters);
    expect.soft = (...args)=>expect(...args).withContext({
            soft: true
        });
    expect.poll = createExpectPoll(expect);
    expect.unreachable = (message)=>{
        chai_assert.fail(`expected ${message ? `"${message}" ` : ''}not to be reached`);
    };
    function assertions(expected) {
        const errorGen = ()=>new Error(`expected number of assertions to be ${expected}, but got ${expect.getState().assertionCalls}`);
        if (Error.captureStackTrace) Error.captureStackTrace(errorGen(), assertions);
        expect.setState({
            expectedAssertionsNumber: expected,
            expectedAssertionsNumberErrorGen: errorGen
        });
    }
    function hasAssertions() {
        const error = new Error('expected any number of assertion, but got none');
        if (Error.captureStackTrace) Error.captureStackTrace(error, hasAssertions);
        expect.setState({
            isExpectingAssertions: true,
            isExpectingAssertionsError: error
        });
    }
    utils_exports.addMethod(expect, 'assertions', assertions);
    utils_exports.addMethod(expect, 'hasAssertions', hasAssertions);
    expect.extend(customMatchers);
    return expect;
}
const normalizeFixtures = (fixtures = {}, extendFixtures = {})=>{
    const result = {};
    for(const key in fixtures){
        const fixtureOptionKeys = [
            'auto'
        ];
        const value = fixtures[key];
        if (Array.isArray(value)) {
            if (1 === value.length && 'function' == typeof value[0]) {
                result[key] = {
                    isFn: true,
                    value: value[0]
                };
                continue;
            }
            if (helper_isObject(value[1]) && Object.keys(value[1]).some((key)=>fixtureOptionKeys.includes(key))) {
                result[key] = {
                    isFn: 'function' == typeof value[0],
                    value: value[0],
                    options: value[1]
                };
                continue;
            }
        }
        result[key] = {
            isFn: 'function' == typeof value,
            value
        };
    }
    const formattedResult = Object.fromEntries(Object.entries(result).map(([key, value])=>{
        if (value.isFn) {
            const usedProps = getFixtureUsedProps(value.value);
            value.deps = usedProps.filter((p)=>p in result || p in extendFixtures);
        }
        return [
            key,
            value
        ];
    }));
    return {
        ...extendFixtures,
        ...formattedResult
    };
};
const handleFixtures = async (test, context)=>{
    const cleanups = [];
    if (!test.fixtures) return {
        cleanups
    };
    const doneMap = new Set();
    const pendingMap = new Set();
    const usedKeys = test.originalFn ? getFixtureUsedProps(test.originalFn) : [];
    const useFixture = async (name, NormalizedFixture)=>{
        if (doneMap.has(name)) return;
        if (pendingMap.has(name)) throw new Error(`Circular fixture dependency: ${name}`);
        const { isFn, deps, value: fixtureValue } = NormalizedFixture;
        if (!isFn) {
            context[name] = fixtureValue;
            doneMap.add(name);
            return;
        }
        pendingMap.add(name);
        if (deps?.length) for (const dep of deps)await useFixture(dep, test.fixtures[dep]);
        await new Promise((fixtureResolve)=>{
            let useDone;
            const block = fixtureValue(context, async (value)=>{
                context[name] = value;
                fixtureResolve();
                return new Promise((useFnResolve)=>{
                    useDone = useFnResolve;
                });
            });
            cleanups.unshift(()=>{
                useDone?.();
                return block;
            });
        });
        doneMap.add(name);
        pendingMap.delete(name);
    };
    for (const [name, params] of Object.entries(test.fixtures)){
        const shouldAdd = params.options?.auto || usedKeys.includes(name);
        if (shouldAdd) await useFixture(name, params);
    }
    return {
        cleanups
    };
};
function splitByComma(s) {
    const result = [];
    const stack = [];
    let start = 0;
    for(let i = 0; i < s.length; i++)if ('{' === s[i] || '[' === s[i]) stack.push('{' === s[i] ? '}' : ']');
    else if (s[i] === stack[stack.length - 1]) stack.pop();
    else if (!stack.length && ',' === s[i]) {
        const token = s.substring(start, i).trim();
        if (token) result.push(token);
        start = i + 1;
    }
    const lastToken = s.substring(start).trim();
    if (lastToken) result.push(lastToken);
    return result;
}
function filterOutComments(s) {
    const result = [];
    let commentState = 'none';
    for(let i = 0; i < s.length; ++i)if ('singleline' === commentState) {
        if ('\n' === s[i]) commentState = 'none';
    } else if ('multiline' === commentState) {
        if ('*' === s[i - 1] && '/' === s[i]) commentState = 'none';
    } else if ('none' === commentState) if ('/' === s[i] && '/' === s[i + 1]) commentState = 'singleline';
    else if ('/' === s[i] && '*' === s[i + 1]) {
        commentState = 'multiline';
        i += 2;
    } else result.push(s[i]);
    return result.join('');
}
function getFixtureUsedProps(fn) {
    const text = filterOutComments(fn.toString());
    const match = text.match(/(?:async)?(?:\s+function)?[^(]*\(([^)]*)/);
    if (!match) return [];
    const trimmedParams = match[1].trim();
    if (!trimmedParams) return [];
    const [firstParam] = splitByComma(trimmedParams);
    if (firstParam?.[0] !== '{' || '}' !== firstParam[firstParam.length - 1]) {
        if (firstParam?.startsWith('_')) return [];
        throw new Error(`First argument must use the object destructuring pattern: ${firstParam}`);
    }
    const props = splitByComma(firstParam.substring(1, firstParam.length - 1)).map((prop)=>{
        const colon = prop.indexOf(':');
        return -1 === colon ? prop.trim() : prop.substring(0, colon).trim();
    });
    const restProperty = props.find((prop)=>prop.startsWith('...'));
    if (restProperty) throw new Error(`Rest property "${restProperty}" is not supported. List all used fixtures explicitly, separated by comma.`);
    return props;
}
const getTestStatus = (results, defaultStatus)=>{
    if (0 === results.length) return defaultStatus;
    return results.some((result)=>'fail' === result.status) ? 'fail' : results.every((result)=>'todo' === result.status) ? 'todo' : results.every((result)=>'skip' === result.status) ? 'skip' : 'pass';
};
function hasOnlyTest(test) {
    return test.some((t)=>'only' === t.runMode || 'suite' === t.type && hasOnlyTest(t.tests));
}
const shouldTestSkip = (test, runOnly, testNamePattern)=>{
    if (runOnly && 'only' !== test.runMode) return true;
    if (testNamePattern && !getTaskNameWithPrefix(test, '').match(testNamePattern)) return true;
    return false;
};
const traverseUpdateTestRunMode = (testSuite, parentRunMode, runOnly, testNamePattern)=>{
    if (0 === testSuite.tests.length) return;
    if (runOnly && 'only' !== testSuite.runMode && !hasOnlyTest(testSuite.tests)) testSuite.runMode = 'skip';
    else if ([
        'skip',
        'todo'
    ].includes(parentRunMode)) testSuite.runMode = parentRunMode;
    const tests = testSuite.tests.map((test)=>{
        const runSubOnly = runOnly && 'only' !== testSuite.runMode ? runOnly : hasOnlyTest(testSuite.tests);
        if ('case' === test.type) {
            if ([
                'skip',
                'todo'
            ].includes(testSuite.runMode)) test.runMode = testSuite.runMode;
            if (shouldTestSkip(test, runSubOnly, testNamePattern)) test.runMode = 'skip';
            return test;
        }
        traverseUpdateTestRunMode(test, testSuite.runMode, runSubOnly, testNamePattern);
        return test;
    });
    if ('run' !== testSuite.runMode) return;
    const hasRunTest = tests.some((test)=>'run' === test.runMode || 'only' === test.runMode);
    if (hasRunTest) {
        testSuite.runMode = 'run';
        return;
    }
    const allTodoTest = tests.every((test)=>'todo' === test.runMode);
    testSuite.runMode = allTodoTest ? 'todo' : 'skip';
};
const updateTestModes = (tests, testNamePattern)=>{
    const hasOnly = hasOnlyTest(tests);
    for (const test of tests)if ('suite' === test.type) traverseUpdateTestRunMode(test, 'run', hasOnly, testNamePattern);
    else if (shouldTestSkip(test, hasOnly, testNamePattern)) test.runMode = 'skip';
};
const updateTestParents = (tests, parentNames = [])=>{
    for (const test of tests){
        test.parentNames = parentNames;
        if ('suite' === test.type) {
            const names = test.name === ROOT_SUITE_NAME ? parentNames : parentNames.concat(test.name);
            updateTestParents(test.tests, names);
        }
    }
};
const traverseUpdateTest = (tests, testNamePattern)=>{
    updateTestParents(tests);
    updateTestModes(tests, testNamePattern);
};
const markAllTestAsSkipped = (test)=>{
    for (const t of test){
        t.runMode = 'skip';
        if ('suite' === t.type) markAllTestAsSkipped(t.tests);
    }
};
function registerTestSuiteListener(suite, key, fn) {
    const listenersKey = `${key}Listeners`;
    suite[listenersKey] ??= [];
    suite[listenersKey].push(fn);
}
function makeError(message, stackTraceError) {
    const error = new Error(message);
    if (stackTraceError?.stack) error.stack = stackTraceError.stack.replace(error.message, stackTraceError.message);
    return error;
}
function wrapTimeout({ name, fn, timeout, getAssertionCalls, stackTraceError }) {
    if (!timeout) return fn;
    return async (...args)=>{
        let timeoutId;
        const timeoutPromise = new Promise((_, reject)=>{
            timeoutId = getRealTimers().setTimeout(()=>{
                const assertionCalls = getAssertionCalls?.() || 0;
                const assertionInfo = assertionCalls > 0 ? ` (completed ${assertionCalls} expect assertion${1 === assertionCalls ? '' : 's'})` : ' (no expect assertions completed)';
                const message = `${name} timed out in ${timeout}ms${getAssertionCalls ? assertionInfo : ''}`;
                reject(makeError(message, stackTraceError));
            }, timeout);
        });
        try {
            const result = await Promise.race([
                fn(...args),
                timeoutPromise
            ]);
            timeoutId && clearTimeout(timeoutId);
            return result;
        } catch (error) {
            timeoutId && clearTimeout(timeoutId);
            throw error;
        }
    };
}
function limitConcurrency(concurrency = 1 / 0) {
    let running = 0;
    const queue = [];
    const runNext = ()=>{
        if (queue.length > 0 && running < concurrency) {
            running++;
            const next = queue.shift();
            next();
        }
    };
    return (func, ...args)=>new Promise((resolve, reject)=>{
            const task = ()=>{
                Promise.resolve(func(...args)).then(resolve).catch(reject).finally(()=>{
                    running--;
                    runNext();
                });
            };
            if (running < concurrency) {
                running++;
                task();
            } else queue.push(task);
        });
}
const RealDate = Date;
class TestRunner {
    _test;
    workerState;
    async runTests({ tests, testPath, state, hooks, api, snapshotClient }) {
        this.workerState = state;
        const { runtimeConfig: { passWithNoTests, retry, maxConcurrency, bail }, project } = state;
        const results = [];
        const errors = [];
        let defaultStatus = 'pass';
        const runTestsCase = async (test, parentHooks)=>{
            if ('skip' === test.runMode) {
                snapshotClient.skipTest(testPath, getTaskNameWithPrefix(test));
                const result = {
                    testId: test.testId,
                    status: 'skip',
                    parentNames: test.parentNames,
                    name: test.name,
                    testPath,
                    project
                };
                return result;
            }
            if ('todo' === test.runMode) {
                const result = {
                    testId: test.testId,
                    status: 'todo',
                    parentNames: test.parentNames,
                    name: test.name,
                    testPath,
                    project
                };
                return result;
            }
            let result;
            this.beforeEach(test, state, api);
            const cleanups = [];
            const fixtureCleanups = await this.beforeRunTest(test, snapshotClient.getSnapshotState(testPath));
            cleanups.push(...fixtureCleanups);
            try {
                for (const fn of parentHooks.beforeEachListeners){
                    const cleanupFn = await fn(test.context);
                    cleanupFn && cleanups.push(cleanupFn);
                }
            } catch (error) {
                result = {
                    testId: test.testId,
                    status: 'fail',
                    parentNames: test.parentNames,
                    name: test.name,
                    errors: formatTestError(error, test),
                    testPath,
                    project
                };
            }
            if (result?.status !== 'fail') if (test.fails) try {
                await test.fn?.(test.context);
                this.afterRunTest(test);
                result = {
                    testId: test.testId,
                    status: 'fail',
                    parentNames: test.parentNames,
                    name: test.name,
                    testPath,
                    project,
                    errors: [
                        {
                            message: 'Expect test to fail'
                        }
                    ]
                };
            } catch (_err) {
                result = {
                    testId: test.testId,
                    project,
                    status: 'pass',
                    parentNames: test.parentNames,
                    name: test.name,
                    testPath
                };
            }
            else try {
                if (test.fn) {
                    const fn = wrapTimeout({
                        name: 'test',
                        fn: test.fn,
                        timeout: test.timeout,
                        stackTraceError: test.stackTraceError,
                        getAssertionCalls: ()=>{
                            const expect = test.context._useLocalExpect ? test.context.expect : globalThis[GLOBAL_EXPECT];
                            const { assertionCalls } = getState(expect);
                            return assertionCalls;
                        }
                    });
                    await fn(test.context);
                }
                this.afterRunTest(test);
                result = {
                    testId: test.testId,
                    project,
                    parentNames: test.parentNames,
                    name: test.name,
                    status: 'pass',
                    testPath
                };
            } catch (error) {
                result = {
                    testId: test.testId,
                    project,
                    status: 'fail',
                    parentNames: test.parentNames,
                    name: test.name,
                    errors: formatTestError(error, test),
                    testPath
                };
            }
            const afterEachFns = [
                ...parentHooks.afterEachListeners || []
            ].reverse().concat(cleanups).concat(test.onFinished);
            test.context.task.result = result;
            try {
                for (const fn of afterEachFns)await fn(test.context);
            } catch (error) {
                result.status = 'fail';
                result.errors ??= [];
                result.errors.push(...formatTestError(error));
            }
            if ('fail' === result.status) for (const fn of [
                ...test.onFailed
            ].reverse())try {
                await fn(test.context);
            } catch (error) {
                result.errors ??= [];
                result.errors.push(...formatTestError(error));
            }
            this.resetCurrentTest();
            return result;
        };
        const limitMaxConcurrency = limitConcurrency(maxConcurrency);
        const runTests = async (allTest, parentHooks)=>{
            const tests = [
                ...allTest
            ];
            const results = [];
            while(tests.length){
                const suite = tests.shift();
                if (suite.concurrent) {
                    const cases = [
                        suite
                    ];
                    while(tests[0]?.concurrent)cases.push(tests.shift());
                    const result = await Promise.all(cases.map((test)=>{
                        if ('suite' === test.type) return runTest(test, parentHooks);
                        return limitMaxConcurrency(()=>runTest(test, parentHooks));
                    }));
                    results.push(...result);
                    continue;
                }
                const result = await runTest(suite, parentHooks);
                results.push(result);
            }
            return results;
        };
        const runTest = async (test, parentHooks)=>{
            let result = {
                testId: test.testId,
                status: 'skip',
                parentNames: test.parentNames,
                name: test.name,
                testPath,
                project,
                duration: 0,
                errors: []
            };
            if (bail && await hooks.getCountOfFailedTests() >= bail) {
                defaultStatus = 'skip';
                return result;
            }
            if ('suite' === test.type) {
                const start = RealDate.now();
                hooks.onTestSuiteStart?.({
                    parentNames: test.parentNames,
                    name: test.name,
                    testPath,
                    project: test.project,
                    testId: test.testId,
                    type: 'suite',
                    location: test.location
                });
                if (0 === test.tests.length) {
                    if ([
                        'todo',
                        'skip'
                    ].includes(test.runMode)) {
                        defaultStatus = 'skip';
                        hooks.onTestSuiteResult?.(result);
                        return result;
                    }
                    if (passWithNoTests) {
                        result.status = 'pass';
                        hooks.onTestSuiteResult?.(result);
                        return result;
                    }
                    const noTestError = {
                        message: `No test found in suite: ${test.name}`,
                        name: 'No tests'
                    };
                    result.errors?.push(noTestError);
                }
                const cleanups = [];
                let hasBeforeAllError = false;
                if ([
                    'run',
                    'only'
                ].includes(test.runMode) && test.beforeAllListeners) try {
                    for (const fn of test.beforeAllListeners){
                        const cleanupFn = await fn({
                            filepath: testPath
                        });
                        cleanupFn && cleanups.push(cleanupFn);
                    }
                } catch (error) {
                    hasBeforeAllError = true;
                    result.errors?.push(...formatTestError(error));
                }
                if (hasBeforeAllError) markAllTestAsSkipped(test.tests);
                const results = await runTests(test.tests, {
                    beforeEachListeners: parentHooks.beforeEachListeners.concat(test.beforeEachListeners || []),
                    afterEachListeners: parentHooks.afterEachListeners.concat(test.afterEachListeners || [])
                });
                const afterAllFns = [
                    ...test.afterAllListeners || []
                ].reverse().concat(cleanups);
                if ([
                    'run',
                    'only'
                ].includes(test.runMode) && afterAllFns.length) try {
                    for (const fn of afterAllFns)await fn({
                        filepath: testPath
                    });
                } catch (error) {
                    result.errors?.push(...formatTestError(error));
                }
                result.duration = RealDate.now() - start;
                result.status = result.errors?.length ? 'fail' : getTestStatus(results, defaultStatus);
                hooks.onTestSuiteResult?.(result);
                errors.push(...result.errors || []);
            } else {
                const start = RealDate.now();
                let retryCount = 0;
                hooks.onTestCaseStart?.({
                    testId: test.testId,
                    startTime: start,
                    testPath: test.testPath,
                    name: test.name,
                    timeout: test.timeout,
                    parentNames: test.parentNames,
                    project: test.project,
                    type: 'case',
                    location: test.location
                });
                do {
                    const currentResult = await runTestsCase(test, parentHooks);
                    result = {
                        ...currentResult,
                        errors: 'fail' === currentResult.status && result && result.errors ? result.errors.concat(...currentResult.errors || []) : currentResult.errors
                    };
                    retryCount++;
                }while (retryCount <= retry && 'fail' === result.status);
                result.duration = RealDate.now() - start;
                result.retryCount = retryCount - 1;
                result.heap = state.runtimeConfig.logHeapUsage ? process.memoryUsage().heapUsed : void 0;
                hooks.onTestCaseResult?.(result);
                results.push(result);
            }
            return result;
        };
        const start = RealDate.now();
        if (0 === tests.length) {
            if (passWithNoTests) return {
                testId: '0',
                project,
                testPath,
                name: '',
                status: 'pass',
                results
            };
            return {
                testId: '0',
                project,
                testPath,
                name: '',
                status: 'fail',
                results,
                heap: state.runtimeConfig.logHeapUsage ? process.memoryUsage().heapUsed : void 0,
                errors: [
                    {
                        message: `No test suites found in file: ${testPath}`,
                        name: 'No tests'
                    }
                ]
            };
        }
        await runTests(tests, {
            beforeEachListeners: [],
            afterEachListeners: []
        });
        const snapshotResult = await snapshotClient.finish(testPath);
        return {
            testId: '0',
            project,
            testPath,
            name: '',
            heap: state.runtimeConfig.logHeapUsage ? process.memoryUsage().heapUsed : void 0,
            status: errors.length ? 'fail' : getTestStatus(results, defaultStatus),
            results,
            snapshotResult,
            errors,
            duration: RealDate.now() - start
        };
    }
    resetCurrentTest() {
        this._test = void 0;
    }
    setCurrentTest(test) {
        this._test = test;
    }
    getCurrentTest() {
        return this._test;
    }
    beforeEach(test, state, api) {
        const { runtimeConfig: { clearMocks, resetMocks, restoreMocks, unstubEnvs, unstubGlobals } } = state;
        this.setCurrentTest(test);
        if (restoreMocks) api.rstest.restoreAllMocks();
        else if (resetMocks) api.rstest.resetAllMocks();
        else if (clearMocks) api.rstest.clearAllMocks();
        if (unstubEnvs) api.rstest.unstubAllEnvs();
        if (unstubGlobals) api.rstest.unstubAllGlobals();
    }
    createTestContext(test) {
        const context = ()=>{
            throw new Error('done() callback is deprecated, use promise instead');
        };
        let _expect;
        const current = this._test;
        context.task = {
            name: test.name
        };
        Object.defineProperty(context, 'expect', {
            get: ()=>{
                if (!_expect) _expect = createExpect({
                    workerState: this.workerState,
                    getCurrentTest: ()=>current
                });
                return _expect;
            }
        });
        Object.defineProperty(context, '_useLocalExpect', {
            get () {
                return null != _expect;
            }
        });
        Object.defineProperty(context, 'onTestFinished', {
            get: ()=>(fn, timeout)=>{
                    this.onTestFinished(current, fn, timeout);
                }
        });
        Object.defineProperty(context, 'onTestFailed', {
            get: ()=>(fn, timeout)=>{
                    this.onTestFailed(current, fn, timeout);
                }
        });
        return context;
    }
    onTestFinished(test, fn, timeout) {
        if (!test) throw new Error('onTestFinished() can only be called inside a test');
        test.onFinished.push(wrapTimeout({
            name: 'onTestFinished hook',
            fn,
            timeout: timeout || this.workerState.runtimeConfig.hookTimeout,
            stackTraceError: new Error('STACK_TRACE_ERROR')
        }));
    }
    onTestFailed(test, fn, timeout) {
        if (!test) throw new Error('onTestFailed() can only be called inside a test');
        test.onFailed.push(wrapTimeout({
            name: 'onTestFailed hook',
            fn,
            timeout: timeout || this.workerState.runtimeConfig.hookTimeout,
            stackTraceError: new Error('STACK_TRACE_ERROR')
        }));
    }
    async beforeRunTest(test, snapshotState) {
        setState({
            assertionCalls: 0,
            isExpectingAssertions: false,
            isExpectingAssertionsError: null,
            expectedAssertionsNumber: null,
            expectedAssertionsNumberErrorGen: null,
            testPath: test.testPath,
            snapshotState,
            currentTestName: getTaskNameWithPrefix(test)
        }, globalThis[GLOBAL_EXPECT]);
        const context = this.createTestContext(test);
        const { cleanups } = await handleFixtures(test, context);
        Object.defineProperty(test, 'context', {
            value: context,
            enumerable: false
        });
        return cleanups;
    }
    afterRunTest(test) {
        const expect = test.context._useLocalExpect ? test.context.expect : globalThis[GLOBAL_EXPECT];
        const { assertionCalls, expectedAssertionsNumber, expectedAssertionsNumberErrorGen, isExpectingAssertions, isExpectingAssertionsError } = getState(expect);
        if (test.result?.state === 'fail') throw test.result.errors;
        if (null !== expectedAssertionsNumber && assertionCalls !== expectedAssertionsNumber) throw expectedAssertionsNumberErrorGen();
        if (true === isExpectingAssertions && 0 === assertionCalls) throw isExpectingAssertionsError;
    }
}
const external_node_path_ = __webpack_require__("node:path");
class RunnerRuntime {
    tests = [];
    _currentTest = [];
    testPath;
    status = 'collect';
    collectStatus = 'lazy';
    currentCollectList = [];
    runtimeConfig;
    project;
    testId = 1;
    constructor({ testPath, runtimeConfig, project }){
        this.project = project;
        this.testPath = testPath;
        this.runtimeConfig = runtimeConfig;
    }
    updateStatus(status) {
        this.status = status;
    }
    checkStatus(name, type) {
        if ('running' === this.status) {
            const error = new TestRegisterError(`${'case' === type ? 'Test' : 'Describe'} '${name}' cannot run`);
            throw error;
        }
    }
    afterAll(fn, timeout = this.runtimeConfig.hookTimeout) {
        const currentSuite = this.getCurrentSuite();
        registerTestSuiteListener(currentSuite, 'afterAll', wrapTimeout({
            name: 'afterAll hook',
            fn,
            timeout,
            stackTraceError: new Error('STACK_TRACE_ERROR')
        }));
    }
    beforeAll(fn, timeout = this.runtimeConfig.hookTimeout) {
        const currentSuite = this.getCurrentSuite();
        registerTestSuiteListener(currentSuite, 'beforeAll', wrapTimeout({
            name: 'beforeAll hook',
            fn,
            timeout,
            stackTraceError: new Error('STACK_TRACE_ERROR')
        }));
    }
    afterEach(fn, timeout = this.runtimeConfig.hookTimeout) {
        const currentSuite = this.getCurrentSuite();
        registerTestSuiteListener(currentSuite, 'afterEach', wrapTimeout({
            name: 'afterEach hook',
            fn,
            timeout,
            stackTraceError: new Error('STACK_TRACE_ERROR')
        }));
    }
    beforeEach(fn, timeout = this.runtimeConfig.hookTimeout) {
        const currentSuite = this.getCurrentSuite();
        registerTestSuiteListener(currentSuite, 'beforeEach', wrapTimeout({
            name: 'beforeEach hook',
            fn,
            timeout,
            stackTraceError: new Error('STACK_TRACE_ERROR')
        }));
    }
    getDefaultRootSuite() {
        return {
            project: this.project,
            runMode: 'run',
            testPath: this.testPath,
            name: ROOT_SUITE_NAME,
            tests: [],
            type: 'suite'
        };
    }
    describe({ name, fn, runMode = 'run', each = false, concurrent, sequential, location }) {
        this.checkStatus(name, 'suite');
        const currentSuite = {
            project: this.project,
            name,
            runMode,
            tests: [],
            type: 'suite',
            each,
            testPath: this.testPath,
            concurrent,
            sequential,
            location
        };
        if (!fn) {
            this.addTest(currentSuite);
            this.resetCurrentTest();
            return;
        }
        this.collectStatus = 'lazy';
        this.currentCollectList.push(async ()=>{
            this.addTest(currentSuite);
            const result = fn();
            if (result instanceof Promise) await result;
            await this.collectCurrentTest();
            this.resetCurrentTest();
        });
    }
    resetCurrentTest() {
        this._currentTest.pop();
    }
    addTest(testInfo) {
        const test = {
            ...testInfo,
            testId: `${this.testId++}`
        };
        if (0 === this._currentTest.length) this.tests.push(test);
        else {
            const current = this._currentTest[this._currentTest.length - 1];
            if (current.each || current.inTestEach) test.inTestEach = true;
            if (current.concurrent && true !== test.sequential) test.concurrent = true;
            if (current.sequential && true !== test.concurrent) test.sequential = true;
            if ('case' === current.type) throw new Error('Calling the test function inside another test function is not allowed. Please put it inside "describe" so it can be properly collected.');
            current.tests.push(test);
        }
        this._currentTest.push(test);
    }
    async collectCurrentTest() {
        const currentCollectList = this.currentCollectList;
        this.currentCollectList = [];
        while(currentCollectList.length > 0){
            this.collectStatus = 'running';
            const fn = currentCollectList.shift();
            await fn();
        }
    }
    async getTests() {
        while(this.currentCollectList.length > 0)await this.collectCurrentTest();
        return this.tests;
    }
    addTestCase(test) {
        if ('lazy' === this.collectStatus) this.currentCollectList.push(()=>{
            this.addTest({
                ...test,
                testPath: this.testPath,
                context: void 0
            });
            this.resetCurrentTest();
        });
        else {
            this.addTest({
                ...test,
                testPath: this.testPath,
                context: void 0
            });
            this.resetCurrentTest();
        }
    }
    ensureRootSuite() {
        if (0 === this._currentTest.length) this.addTest(this.getDefaultRootSuite());
    }
    it({ name, fn, originalFn = fn, fixtures, timeout = this.runtimeConfig.testTimeout, runMode = 'run', fails = false, each = false, concurrent, sequential, location }) {
        this.checkStatus(name, 'case');
        this.addTestCase({
            project: this.project,
            name,
            originalFn,
            fn,
            stackTraceError: new Error('STACK_TRACE_ERROR'),
            runMode,
            type: 'case',
            timeout,
            fixtures,
            concurrent,
            sequential,
            each,
            fails,
            onFinished: [],
            onFailed: [],
            location
        });
    }
    describeEach({ cases, ...options }) {
        return (name, fn)=>{
            for(let i = 0; i < cases.length; i++){
                const param = cases[i];
                const params = castArray(param);
                this.describe({
                    name: formatName(name, param, i),
                    fn: ()=>fn?.(...params),
                    ...options,
                    each: true
                });
            }
        };
    }
    describeFor({ cases, ...options }) {
        return (name, fn)=>{
            for(let i = 0; i < cases.length; i++){
                const param = cases[i];
                this.describe({
                    name: formatName(name, param, i),
                    fn: ()=>fn?.(param),
                    ...options,
                    each: true
                });
            }
        };
    }
    each({ cases, ...options }) {
        return (name, fn, timeout = this.runtimeConfig.testTimeout)=>{
            for(let i = 0; i < cases.length; i++){
                const param = cases[i];
                const params = castArray(param);
                this.it({
                    name: formatName(name, param, i),
                    originalFn: fn,
                    fn: ()=>fn?.(...params),
                    timeout,
                    ...options,
                    each: true
                });
            }
        };
    }
    for({ cases, ...options }) {
        return (name, fn, timeout = this.runtimeConfig.testTimeout)=>{
            for(let i = 0; i < cases.length; i++){
                const param = cases[i];
                this.it({
                    name: formatName(name, param, i),
                    originalFn: fn,
                    fn: (context)=>fn?.(param, context),
                    timeout,
                    ...options,
                    each: true
                });
            }
        };
    }
    getCurrentSuite() {
        this.ensureRootSuite();
        for(let i = this._currentTest.length - 1; i >= 0; i--){
            const test = this._currentTest[i];
            if ('suite' === test.type) return test;
        }
        throw new Error('Expect to find a suite, but got undefined');
    }
}
const createRuntimeAPI = ({ testPath, runtimeConfig, project })=>{
    const runtimeInstance = new RunnerRuntime({
        project,
        testPath,
        runtimeConfig
    });
    const getLocation = ()=>{
        if (!runtimeConfig.includeTaskLocation) return;
        const stack = new Error().stack;
        if (stack) {
            const frames = parse(stack);
            for (const frame of frames){
                let filename = frame.file ?? '';
                if (filename.startsWith('file://')) filename = fileURLToPath(filename);
                filename = filename.replaceAll(external_node_path_["default"].sep, '/');
                if (filename === testPath) {
                    const line = frame.lineNumber;
                    const column = frame.column;
                    if (null != line && null != column) return {
                        line,
                        column
                    };
                }
            }
        }
    };
    const createTestAPI = (options = {})=>{
        const testFn = (name, fn, timeout)=>runtimeInstance.it({
                name,
                fn,
                timeout,
                ...options,
                location: options.location ?? getLocation()
            });
        for (const { name, overrides } of [
            {
                name: 'fails',
                overrides: {
                    fails: true
                }
            },
            {
                name: 'concurrent',
                overrides: {
                    concurrent: true
                }
            },
            {
                name: 'sequential',
                overrides: {
                    sequential: true
                }
            },
            {
                name: 'skip',
                overrides: {
                    runMode: 'skip'
                }
            },
            {
                name: 'todo',
                overrides: {
                    runMode: 'todo'
                }
            },
            {
                name: 'only',
                overrides: {
                    runMode: 'only'
                }
            }
        ])Object.defineProperty(testFn, name, {
            get: ()=>createTestAPI({
                    ...options,
                    ...overrides
                }),
            enumerable: true
        });
        testFn.runIf = (condition)=>createTestAPI({
                ...options,
                location: getLocation(),
                runMode: condition ? options.runMode : 'skip'
            });
        testFn.skipIf = (condition)=>createTestAPI({
                ...options,
                location: getLocation(),
                runMode: condition ? 'skip' : options.runMode
            });
        testFn.each = (cases)=>runtimeInstance.each({
                cases,
                ...options,
                location: getLocation()
            });
        testFn.for = (cases)=>runtimeInstance.for({
                cases,
                ...options,
                location: getLocation()
            });
        return testFn;
    };
    const it = createTestAPI();
    it.extend = (fixtures)=>{
        const extend = (fixtures, extendFixtures)=>{
            const normalizedFixtures = normalizeFixtures(fixtures, extendFixtures);
            const api = createTestAPI({
                fixtures: normalizedFixtures
            });
            api.extend = (subFixtures)=>extend(subFixtures, normalizedFixtures);
            return api;
        };
        return extend(fixtures);
    };
    const createDescribeAPI = (options = {})=>{
        const describeFn = (name, fn)=>runtimeInstance.describe({
                name,
                fn,
                ...options,
                location: options.location ?? getLocation()
            });
        for (const { name, overrides } of [
            {
                name: 'only',
                overrides: {
                    runMode: 'only'
                }
            },
            {
                name: 'todo',
                overrides: {
                    runMode: 'todo'
                }
            },
            {
                name: 'skip',
                overrides: {
                    runMode: 'skip'
                }
            },
            {
                name: 'concurrent',
                overrides: {
                    concurrent: true
                }
            },
            {
                name: 'sequential',
                overrides: {
                    sequential: true
                }
            }
        ])Object.defineProperty(describeFn, name, {
            get: ()=>createDescribeAPI({
                    ...options,
                    ...overrides
                }),
            enumerable: true
        });
        describeFn.skipIf = (condition)=>createDescribeAPI({
                ...options,
                location: getLocation(),
                runMode: condition ? 'skip' : options.runMode
            });
        describeFn.runIf = (condition)=>createDescribeAPI({
                ...options,
                location: getLocation(),
                runMode: condition ? options.runMode : 'skip'
            });
        describeFn.each = (cases)=>runtimeInstance.describeEach({
                cases,
                ...options,
                location: getLocation()
            });
        describeFn.for = (cases)=>runtimeInstance.describeFor({
                cases,
                ...options,
                location: getLocation()
            });
        return describeFn;
    };
    const describe = createDescribeAPI();
    return {
        api: {
            describe,
            it,
            test: it,
            afterAll: runtimeInstance.afterAll.bind(runtimeInstance),
            beforeAll: runtimeInstance.beforeAll.bind(runtimeInstance),
            afterEach: runtimeInstance.afterEach.bind(runtimeInstance),
            beforeEach: runtimeInstance.beforeEach.bind(runtimeInstance)
        },
        instance: runtimeInstance
    };
};
function createRunner({ workerState }) {
    const { testPath, project, runtimeConfig: { testNamePattern } } = workerState;
    const runtime = createRuntimeAPI({
        project,
        testPath,
        runtimeConfig: workerState.runtimeConfig
    });
    const testRunner = new TestRunner();
    return {
        api: {
            ...runtime.api,
            onTestFinished: (fn, timeout)=>{
                testRunner.onTestFinished(testRunner.getCurrentTest(), fn, timeout);
            },
            onTestFailed: (fn, timeout)=>{
                testRunner.onTestFailed(testRunner.getCurrentTest(), fn, timeout);
            }
        },
        runner: {
            runTests: async (testPath, hooks, api)=>{
                const snapshotClient = getSnapshotClient();
                await snapshotClient.setup(testPath, workerState.snapshotOptions);
                const tests = await runtime.instance.getTests();
                traverseUpdateTest(tests, testNamePattern);
                hooks.onTestFileReady?.({
                    testPath,
                    tests: tests.map(function toTestInfo(test) {
                        return {
                            testId: test.testId,
                            name: test.name,
                            parentNames: test.parentNames,
                            testPath: test.testPath,
                            project: test.project,
                            type: test.type,
                            location: test.location,
                            tests: 'suite' === test.type ? test.tests.map(toTestInfo) : []
                        };
                    })
                });
                runtime.instance.updateStatus('running');
                const results = await testRunner.runTests({
                    tests,
                    testPath,
                    state: workerState,
                    hooks,
                    api,
                    snapshotClient
                });
                return results;
            },
            collectTests: async ()=>{
                const tests = await runtime.instance.getTests();
                traverseUpdateTest(tests, testNamePattern);
                return tests;
            },
            getCurrentTest: ()=>testRunner.getCurrentTest()
        }
    };
}
const fake_timers_src = __webpack_require__("../../node_modules/.pnpm/@sinonjs+fake-timers@15.0.0/node_modules/@sinonjs/fake-timers/src/fake-timers-src.js");
const fakeTimers_RealDate = Date;
class FakeTimers {
    _clock;
    _config;
    _fakingTime;
    _fakeTimers;
    constructor({ global: global1, config = {} }){
        this._config = config;
        this._fakingTime = false;
        this._fakeTimers = (0, fake_timers_src.withGlobal)(global1);
    }
    clearAllTimers() {
        if (this._fakingTime) this._clock.reset();
    }
    dispose() {
        this.useRealTimers();
    }
    runAllTimers() {
        if (this._checkFakeTimers()) this._clock.runAll();
    }
    async runAllTimersAsync() {
        if (this._checkFakeTimers()) await this._clock.runAllAsync();
    }
    runOnlyPendingTimers() {
        if (this._checkFakeTimers()) this._clock.runToLast();
    }
    async runOnlyPendingTimersAsync() {
        if (this._checkFakeTimers()) await this._clock.runToLastAsync();
    }
    advanceTimersToNextTimer(steps = 1) {
        if (this._checkFakeTimers()) for(let i = steps; i > 0; i--){
            this._clock.next();
            this._clock.tick(0);
            if (0 === this._clock.countTimers()) break;
        }
    }
    async advanceTimersToNextTimerAsync(steps = 1) {
        if (this._checkFakeTimers()) for(let i = steps; i > 0; i--){
            await this._clock.nextAsync();
            await this._clock.tickAsync(0);
            if (0 === this._clock.countTimers()) break;
        }
    }
    advanceTimersByTime(msToRun) {
        if (this._checkFakeTimers()) this._clock.tick(msToRun);
    }
    async advanceTimersByTimeAsync(msToRun) {
        if (this._checkFakeTimers()) await this._clock.tickAsync(msToRun);
    }
    advanceTimersToNextFrame() {
        if (this._checkFakeTimers()) this._clock.runToFrame();
    }
    runAllTicks() {
        if (this._checkFakeTimers()) this._clock.runMicrotasks();
    }
    useRealTimers() {
        if (this._fakingTime) {
            this._clock.uninstall();
            this._fakingTime = false;
        }
    }
    useFakeTimers(fakeTimersConfig = {}) {
        if (this._fakingTime) this._clock.uninstall();
        const toFake = Object.keys(this._fakeTimers.timers).filter((timer)=>'nextTick' !== timer && 'queueMicrotask' !== timer);
        const isChildProcess = 'undefined' != typeof process && !!process.send;
        if (this._config?.toFake?.includes('nextTick') && isChildProcess) throw new Error('process.nextTick cannot be mocked inside child_process');
        this._clock = this._fakeTimers.install({
            loopLimit: 10000,
            shouldClearNativeTimers: true,
            now: Date.now(),
            toFake: [
                ...toFake
            ],
            ignoreMissingTimers: true,
            ...fakeTimersConfig
        });
        this._fakingTime = true;
    }
    reset() {
        if (this._checkFakeTimers()) {
            const { now } = this._clock;
            this._clock.reset();
            this._clock.setSystemTime(now);
        }
    }
    setSystemTime(now) {
        if (this._checkFakeTimers()) this._clock.setSystemTime(now);
    }
    getRealSystemTime() {
        return fakeTimers_RealDate.now();
    }
    now() {
        if (this._fakingTime) return this._clock.now;
        return Date.now();
    }
    getTimerCount() {
        if (this._checkFakeTimers()) return this._clock.countTimers();
        return 0;
    }
    _checkFakeTimers() {
        if (!this._fakingTime) throw new Error('Timers are not mocked. Try calling "rstest.useFakeTimers()" first.');
        return this._fakingTime;
    }
    isFakeTimers() {
        return this._fakingTime;
    }
}
let spy_callOrder = 0;
const spy_mocks = new Set();
const wrapSpy = (obj, methodName, mockFn)=>{
    const spyImpl = M(obj, methodName, mockFn);
    const spyFn = spyImpl;
    let mockImplementationOnce = [];
    let implementation = mockFn;
    let mockName = mockFn?.name;
    const initMockState = ()=>({
            instances: [],
            contexts: [],
            invocationCallOrder: []
        });
    let mockState = initMockState();
    const spyState = T(spyImpl);
    spyFn.getMockName = ()=>mockName || methodName;
    spyFn.mockName = (name)=>{
        mockName = name;
        return spyFn;
    };
    spyFn.getMockImplementation = ()=>mockImplementationOnce.length ? mockImplementationOnce[mockImplementationOnce.length - 1] : implementation;
    function withImplementation(fn, cb) {
        const originalImplementation = implementation;
        const originalMockImplementationOnce = mockImplementationOnce;
        implementation = fn;
        mockImplementationOnce = [];
        spyState.willCall(willCall);
        const reset = ()=>{
            implementation = originalImplementation;
            mockImplementationOnce = originalMockImplementationOnce;
        };
        const result = cb();
        if (result instanceof Promise) return result.then(()=>{
            reset();
        });
        reset();
    }
    spyFn.withImplementation = withImplementation;
    spyFn.mockImplementation = (fn)=>{
        implementation = fn;
        return spyFn;
    };
    spyFn.mockImplementationOnce = (fn)=>{
        mockImplementationOnce.push(fn);
        return spyFn;
    };
    spyFn.mockReturnValue = (value)=>spyFn.mockImplementation(()=>value);
    spyFn.mockReturnValueOnce = (value)=>spyFn.mockImplementationOnce(()=>value);
    spyFn.mockResolvedValue = (value)=>spyFn.mockImplementation(()=>Promise.resolve(value));
    spyFn.mockResolvedValueOnce = (value)=>spyFn.mockImplementationOnce(()=>Promise.resolve(value));
    spyFn.mockRejectedValue = (value)=>spyFn.mockImplementation(()=>Promise.reject(value));
    spyFn.mockRejectedValueOnce = (value)=>spyFn.mockImplementationOnce(()=>Promise.reject(value));
    spyFn.mockReturnThis = ()=>spyFn.mockImplementation(function() {
            return this;
        });
    function willCall(...args) {
        let impl = implementation || spyState.getOriginal();
        mockState.instances.push(this);
        mockState.contexts.push(this);
        mockState.invocationCallOrder.push(++spy_callOrder);
        if (mockImplementationOnce.length) impl = mockImplementationOnce.shift();
        return impl?.apply(this, args);
    }
    spyState.willCall(willCall);
    Object.defineProperty(spyFn, 'mock', {
        get: ()=>({
                get calls () {
                    return spyState.calls;
                },
                get lastCall () {
                    return spyState.calls[spyState.callCount - 1];
                },
                get instances () {
                    return mockState.instances;
                },
                get contexts () {
                    return mockState.contexts;
                },
                get invocationCallOrder () {
                    return mockState.invocationCallOrder;
                },
                get results () {
                    return spyState.results.map(([resultType, value])=>{
                        const type = 'error' === resultType ? 'throw' : 'return';
                        return {
                            type: type,
                            value
                        };
                    });
                },
                get settledResults () {
                    return spyState.resolves.map(([resultType, value])=>{
                        const type = 'error' === resultType ? 'rejected' : 'fulfilled';
                        return {
                            type,
                            value
                        };
                    });
                }
            })
    });
    spyFn.mockClear = ()=>{
        mockState = initMockState();
        spyState.reset();
        return spyFn;
    };
    spyFn.mockReset = ()=>{
        spyFn.mockClear();
        implementation = mockFn;
        mockImplementationOnce = [];
        return spyFn;
    };
    spyFn.mockRestore = ()=>{
        spyFn.mockReset();
        spyState.restore();
        mockName = mockFn?.name;
    };
    spy_mocks.add(spyFn);
    return spyFn;
};
const spy_fn = (mockFn)=>{
    const defaultName = 'rstest.fn()';
    return wrapSpy({
        [defaultName]: mockFn
    }, defaultName, mockFn);
};
const spy_spyOn = (obj, methodName, accessType)=>{
    const accessTypeMap = {
        get: 'getter',
        set: 'setter'
    };
    const method = accessType ? {
        [accessTypeMap[accessType]]: methodName
    } : methodName;
    return wrapSpy(obj, method);
};
const spy_isMockFunction = (fn)=>'function' == typeof fn && '_isMockFunction' in fn && fn._isMockFunction;
const createRstestUtilities = (workerState)=>{
    const originalEnvValues = new Map();
    const originalGlobalValues = new Map();
    let _timers;
    let originalConfig;
    const timers = ()=>{
        if (!_timers) _timers = new FakeTimers({
            global: globalThis
        });
        return _timers;
    };
    const rstest = {
        fn: spy_fn,
        spyOn: spy_spyOn,
        isMockFunction: spy_isMockFunction,
        clearAllMocks: ()=>{
            for (const mock of spy_mocks)mock.mockClear();
            return rstest;
        },
        resetAllMocks: ()=>{
            for (const mock of spy_mocks)mock.mockReset();
            return rstest;
        },
        restoreAllMocks: ()=>{
            for (const mock of spy_mocks)mock.mockRestore();
            return rstest;
        },
        mock: ()=>{},
        mockRequire: ()=>{},
        doMock: ()=>{},
        doMockRequire: ()=>{},
        unmock: ()=>{},
        doUnmock: ()=>{},
        importMock: async ()=>({}),
        requireMock: ()=>({}),
        importActual: async ()=>({}),
        requireActual: ()=>({}),
        resetModules: ()=>({}),
        hoisted: ()=>({}),
        setConfig: (config)=>{
            if (!originalConfig) originalConfig = {
                ...workerState.runtimeConfig
            };
            Object.assign(workerState.runtimeConfig, config);
        },
        getConfig: ()=>{
            const { testTimeout, hookTimeout, clearMocks, resetMocks, restoreMocks, maxConcurrency, retry } = workerState.runtimeConfig;
            return {
                testTimeout,
                hookTimeout,
                clearMocks,
                resetMocks,
                restoreMocks,
                maxConcurrency,
                retry
            };
        },
        resetConfig: ()=>{
            if (originalConfig) Object.assign(workerState.runtimeConfig, originalConfig);
        },
        stubEnv: (name, value)=>{
            if (!originalEnvValues.has(name)) originalEnvValues.set(name, process.env[name]);
            if (void 0 === value) delete process.env[name];
            else process.env[name] = value;
            return rstest;
        },
        unstubAllEnvs: ()=>{
            for (const [name, value] of originalEnvValues)if (void 0 === value) delete process.env[name];
            else process.env[name] = value;
            originalEnvValues.clear();
            return rstest;
        },
        stubGlobal: (name, value)=>{
            if (!originalGlobalValues.has(name)) originalGlobalValues.set(name, Object.getOwnPropertyDescriptor(globalThis, name));
            Object.defineProperty(globalThis, name, {
                value,
                writable: true,
                configurable: true,
                enumerable: true
            });
            return rstest;
        },
        unstubAllGlobals: ()=>{
            originalGlobalValues.forEach((original, name)=>{
                if (original) Object.defineProperty(globalThis, name, original);
                else Reflect.deleteProperty(globalThis, name);
            });
            originalGlobalValues.clear();
            return rstest;
        },
        useFakeTimers: (opts)=>{
            timers().useFakeTimers(opts);
            return rstest;
        },
        useRealTimers: ()=>{
            timers().useRealTimers();
            return rstest;
        },
        setSystemTime: (now)=>{
            timers().setSystemTime(now);
            return rstest;
        },
        getRealSystemTime: ()=>_timers ? timers().getRealSystemTime() : Date.now(),
        isFakeTimers: ()=>_timers ? timers().isFakeTimers() : false,
        runAllTimers: ()=>{
            timers().runAllTimers();
            return rstest;
        },
        runAllTimersAsync: async ()=>{
            await timers().runAllTimersAsync();
            return rstest;
        },
        runAllTicks: ()=>{
            timers().runAllTicks();
            return rstest;
        },
        runOnlyPendingTimers: ()=>{
            timers().runOnlyPendingTimers();
            return rstest;
        },
        runOnlyPendingTimersAsync: async ()=>{
            await timers().runOnlyPendingTimersAsync();
            return rstest;
        },
        advanceTimersByTime: (ms)=>{
            timers().advanceTimersByTime(ms);
            return rstest;
        },
        advanceTimersByTimeAsync: async (ms)=>{
            await timers().advanceTimersByTimeAsync(ms);
            return rstest;
        },
        advanceTimersToNextTimer: (steps)=>{
            timers().advanceTimersToNextTimer(steps);
            return rstest;
        },
        advanceTimersToNextTimerAsync: async (steps)=>{
            await timers().advanceTimersToNextTimerAsync(steps);
            return rstest;
        },
        advanceTimersToNextFrame: ()=>{
            timers().advanceTimersToNextFrame();
            return rstest;
        },
        getTimerCount: ()=>timers().getTimerCount(),
        clearAllTimers: ()=>{
            timers().clearAllTimers();
            return rstest;
        }
    };
    return rstest;
};
const createRstestRuntime = (workerState)=>{
    const { runner, api: runnerAPI } = createRunner({
        workerState
    });
    if (workerState.runtimeConfig.chaiConfig) setupChaiConfig(workerState.runtimeConfig.chaiConfig);
    const expect = createExpect({
        workerState,
        getCurrentTest: ()=>runner.getCurrentTest()
    });
    Object.defineProperty(globalThis, GLOBAL_EXPECT, {
        value: expect,
        writable: true,
        configurable: true
    });
    const rstest = createRstestUtilities(workerState);
    const runtime = {
        runner,
        api: {
            ...runnerAPI,
            expect,
            assert: chai_assert,
            rstest,
            rs: rstest
        }
    };
    globalThis.RSTEST_API = runtime.api;
    return runtime;
};
export { createRstestRuntime };
