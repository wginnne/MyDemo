import 'module';
/*#__PURE__*/ import.meta.url;
import { __webpack_require__ } from "./rslib-runtime.js";
import { fileURLToPath } from "url";
import { createRequire } from "module";
import promises, { lstat, readdir, realpath, stat as promises_stat, writeFile } from "node:fs/promises";
import { createRequire as external_node_module_createRequire } from "./664.js";
import { normalize, isAbsolute, posix, join, parse } from "./278.js";
__webpack_require__.add({
    "../../node_modules/.pnpm/picomatch@4.0.3/node_modules/picomatch/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        const pico = __webpack_require__("../../node_modules/.pnpm/picomatch@4.0.3/node_modules/picomatch/lib/picomatch.js");
        const utils = __webpack_require__("../../node_modules/.pnpm/picomatch@4.0.3/node_modules/picomatch/lib/utils.js");
        function picomatch(glob, options, returnState = false) {
            if (options && (null === options.windows || void 0 === options.windows)) options = {
                ...options,
                windows: utils.isWindows()
            };
            return pico(glob, options, returnState);
        }
        Object.assign(picomatch, pico);
        module.exports = picomatch;
    },
    "../../node_modules/.pnpm/picomatch@4.0.3/node_modules/picomatch/lib/constants.js" (module) {
        const WIN_SLASH = '\\\\/';
        const WIN_NO_SLASH = `[^${WIN_SLASH}]`;
        const DOT_LITERAL = '\\.';
        const PLUS_LITERAL = '\\+';
        const QMARK_LITERAL = '\\?';
        const SLASH_LITERAL = '\\/';
        const ONE_CHAR = '(?=.)';
        const QMARK = '[^/]';
        const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
        const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
        const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
        const NO_DOT = `(?!${DOT_LITERAL})`;
        const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
        const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
        const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
        const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
        const STAR = `${QMARK}*?`;
        const SEP = '/';
        const POSIX_CHARS = {
            DOT_LITERAL,
            PLUS_LITERAL,
            QMARK_LITERAL,
            SLASH_LITERAL,
            ONE_CHAR,
            QMARK,
            END_ANCHOR,
            DOTS_SLASH,
            NO_DOT,
            NO_DOTS,
            NO_DOT_SLASH,
            NO_DOTS_SLASH,
            QMARK_NO_DOT,
            STAR,
            START_ANCHOR,
            SEP
        };
        const WINDOWS_CHARS = {
            ...POSIX_CHARS,
            SLASH_LITERAL: `[${WIN_SLASH}]`,
            QMARK: WIN_NO_SLASH,
            STAR: `${WIN_NO_SLASH}*?`,
            DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
            NO_DOT: `(?!${DOT_LITERAL})`,
            NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
            NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
            NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
            QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
            START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
            END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
            SEP: '\\'
        };
        const POSIX_REGEX_SOURCE = {
            alnum: 'a-zA-Z0-9',
            alpha: 'a-zA-Z',
            ascii: '\\x00-\\x7F',
            blank: ' \\t',
            cntrl: '\\x00-\\x1F\\x7F',
            digit: '0-9',
            graph: '\\x21-\\x7E',
            lower: 'a-z',
            print: '\\x20-\\x7E ',
            punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
            space: ' \\t\\r\\n\\v\\f',
            upper: 'A-Z',
            word: 'A-Za-z0-9_',
            xdigit: 'A-Fa-f0-9'
        };
        module.exports = {
            MAX_LENGTH: 65536,
            POSIX_REGEX_SOURCE,
            REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
            REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
            REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
            REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
            REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
            REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
            REPLACEMENTS: {
                __proto__: null,
                '***': '*',
                '**/**': '**',
                '**/**/**': '**'
            },
            CHAR_0: 48,
            CHAR_9: 57,
            CHAR_UPPERCASE_A: 65,
            CHAR_LOWERCASE_A: 97,
            CHAR_UPPERCASE_Z: 90,
            CHAR_LOWERCASE_Z: 122,
            CHAR_LEFT_PARENTHESES: 40,
            CHAR_RIGHT_PARENTHESES: 41,
            CHAR_ASTERISK: 42,
            CHAR_AMPERSAND: 38,
            CHAR_AT: 64,
            CHAR_BACKWARD_SLASH: 92,
            CHAR_CARRIAGE_RETURN: 13,
            CHAR_CIRCUMFLEX_ACCENT: 94,
            CHAR_COLON: 58,
            CHAR_COMMA: 44,
            CHAR_DOT: 46,
            CHAR_DOUBLE_QUOTE: 34,
            CHAR_EQUAL: 61,
            CHAR_EXCLAMATION_MARK: 33,
            CHAR_FORM_FEED: 12,
            CHAR_FORWARD_SLASH: 47,
            CHAR_GRAVE_ACCENT: 96,
            CHAR_HASH: 35,
            CHAR_HYPHEN_MINUS: 45,
            CHAR_LEFT_ANGLE_BRACKET: 60,
            CHAR_LEFT_CURLY_BRACE: 123,
            CHAR_LEFT_SQUARE_BRACKET: 91,
            CHAR_LINE_FEED: 10,
            CHAR_NO_BREAK_SPACE: 160,
            CHAR_PERCENT: 37,
            CHAR_PLUS: 43,
            CHAR_QUESTION_MARK: 63,
            CHAR_RIGHT_ANGLE_BRACKET: 62,
            CHAR_RIGHT_CURLY_BRACE: 125,
            CHAR_RIGHT_SQUARE_BRACKET: 93,
            CHAR_SEMICOLON: 59,
            CHAR_SINGLE_QUOTE: 39,
            CHAR_SPACE: 32,
            CHAR_TAB: 9,
            CHAR_UNDERSCORE: 95,
            CHAR_VERTICAL_LINE: 124,
            CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
            extglobChars (chars) {
                return {
                    '!': {
                        type: 'negate',
                        open: '(?:(?!(?:',
                        close: `))${chars.STAR})`
                    },
                    '?': {
                        type: 'qmark',
                        open: '(?:',
                        close: ')?'
                    },
                    '+': {
                        type: 'plus',
                        open: '(?:',
                        close: ')+'
                    },
                    '*': {
                        type: 'star',
                        open: '(?:',
                        close: ')*'
                    },
                    '@': {
                        type: 'at',
                        open: '(?:',
                        close: ')'
                    }
                };
            },
            globChars (win32) {
                return true === win32 ? WINDOWS_CHARS : POSIX_CHARS;
            }
        };
    },
    "../../node_modules/.pnpm/picomatch@4.0.3/node_modules/picomatch/lib/parse.js" (module, __unused_rspack_exports, __webpack_require__) {
        const constants = __webpack_require__("../../node_modules/.pnpm/picomatch@4.0.3/node_modules/picomatch/lib/constants.js");
        const utils = __webpack_require__("../../node_modules/.pnpm/picomatch@4.0.3/node_modules/picomatch/lib/utils.js");
        const { MAX_LENGTH, POSIX_REGEX_SOURCE, REGEX_NON_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_BACKREF, REPLACEMENTS } = constants;
        const expandRange = (args, options)=>{
            if ('function' == typeof options.expandRange) return options.expandRange(...args, options);
            args.sort();
            const value = `[${args.join('-')}]`;
            try {
                new RegExp(value);
            } catch (ex) {
                return args.map((v)=>utils.escapeRegex(v)).join('..');
            }
            return value;
        };
        const syntaxError = (type, char)=>`Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
        const parse = (input, options)=>{
            if ('string' != typeof input) throw new TypeError('Expected a string');
            input = REPLACEMENTS[input] || input;
            const opts = {
                ...options
            };
            const max = 'number' == typeof opts.maxLength ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
            let len = input.length;
            if (len > max) throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
            const bos = {
                type: 'bos',
                value: '',
                output: opts.prepend || ''
            };
            const tokens = [
                bos
            ];
            const capture = opts.capture ? '' : '?:';
            const PLATFORM_CHARS = constants.globChars(opts.windows);
            const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
            const { DOT_LITERAL, PLUS_LITERAL, SLASH_LITERAL, ONE_CHAR, DOTS_SLASH, NO_DOT, NO_DOT_SLASH, NO_DOTS_SLASH, QMARK, QMARK_NO_DOT, STAR, START_ANCHOR } = PLATFORM_CHARS;
            const globstar = (opts)=>`(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
            const nodot = opts.dot ? '' : NO_DOT;
            const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
            let star = true === opts.bash ? globstar(opts) : STAR;
            if (opts.capture) star = `(${star})`;
            if ('boolean' == typeof opts.noext) opts.noextglob = opts.noext;
            const state = {
                input,
                index: -1,
                start: 0,
                dot: true === opts.dot,
                consumed: '',
                output: '',
                prefix: '',
                backtrack: false,
                negated: false,
                brackets: 0,
                braces: 0,
                parens: 0,
                quotes: 0,
                globstar: false,
                tokens
            };
            input = utils.removePrefix(input, state);
            len = input.length;
            const extglobs = [];
            const braces = [];
            const stack = [];
            let prev = bos;
            let value;
            const eos = ()=>state.index === len - 1;
            const peek = state.peek = (n = 1)=>input[state.index + n];
            const advance = state.advance = ()=>input[++state.index] || '';
            const remaining = ()=>input.slice(state.index + 1);
            const consume = (value = '', num = 0)=>{
                state.consumed += value;
                state.index += num;
            };
            const append = (token)=>{
                state.output += null != token.output ? token.output : token.value;
                consume(token.value);
            };
            const negate = ()=>{
                let count = 1;
                while('!' === peek() && ('(' !== peek(2) || '?' === peek(3))){
                    advance();
                    state.start++;
                    count++;
                }
                if (count % 2 === 0) return false;
                state.negated = true;
                state.start++;
                return true;
            };
            const increment = (type)=>{
                state[type]++;
                stack.push(type);
            };
            const decrement = (type)=>{
                state[type]--;
                stack.pop();
            };
            const push = (tok)=>{
                if ('globstar' === prev.type) {
                    const isBrace = state.braces > 0 && ('comma' === tok.type || 'brace' === tok.type);
                    const isExtglob = true === tok.extglob || extglobs.length && ('pipe' === tok.type || 'paren' === tok.type);
                    if ('slash' !== tok.type && 'paren' !== tok.type && !isBrace && !isExtglob) {
                        state.output = state.output.slice(0, -prev.output.length);
                        prev.type = 'star';
                        prev.value = '*';
                        prev.output = star;
                        state.output += prev.output;
                    }
                }
                if (extglobs.length && 'paren' !== tok.type) extglobs[extglobs.length - 1].inner += tok.value;
                if (tok.value || tok.output) append(tok);
                if (prev && 'text' === prev.type && 'text' === tok.type) {
                    prev.output = (prev.output || prev.value) + tok.value;
                    prev.value += tok.value;
                    return;
                }
                tok.prev = prev;
                tokens.push(tok);
                prev = tok;
            };
            const extglobOpen = (type, value)=>{
                const token = {
                    ...EXTGLOB_CHARS[value],
                    conditions: 1,
                    inner: ''
                };
                token.prev = prev;
                token.parens = state.parens;
                token.output = state.output;
                const output = (opts.capture ? '(' : '') + token.open;
                increment('parens');
                push({
                    type,
                    value,
                    output: state.output ? '' : ONE_CHAR
                });
                push({
                    type: 'paren',
                    extglob: true,
                    value: advance(),
                    output
                });
                extglobs.push(token);
            };
            const extglobClose = (token)=>{
                let output = token.close + (opts.capture ? ')' : '');
                let rest;
                if ('negate' === token.type) {
                    let extglobStar = star;
                    if (token.inner && token.inner.length > 1 && token.inner.includes('/')) extglobStar = globstar(opts);
                    if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) output = token.close = `)$))${extglobStar}`;
                    if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
                        const expression = parse(rest, {
                            ...options,
                            fastpaths: false
                        }).output;
                        output = token.close = `)${expression})${extglobStar})`;
                    }
                    if ('bos' === token.prev.type) state.negatedExtglob = true;
                }
                push({
                    type: 'paren',
                    extglob: true,
                    value,
                    output
                });
                decrement('parens');
            };
            if (false !== opts.fastpaths && !/(^[*!]|[/()[\]{}"])/.test(input)) {
                let backslashes = false;
                let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index)=>{
                    if ('\\' === first) {
                        backslashes = true;
                        return m;
                    }
                    if ('?' === first) {
                        if (esc) return esc + first + (rest ? QMARK.repeat(rest.length) : '');
                        if (0 === index) return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
                        return QMARK.repeat(chars.length);
                    }
                    if ('.' === first) return DOT_LITERAL.repeat(chars.length);
                    if ('*' === first) {
                        if (esc) return esc + first + (rest ? star : '');
                        return star;
                    }
                    return esc ? m : `\\${m}`;
                });
                if (true === backslashes) output = true === opts.unescape ? output.replace(/\\/g, '') : output.replace(/\\+/g, (m)=>m.length % 2 === 0 ? '\\\\' : m ? '\\' : '');
                if (output === input && true === opts.contains) {
                    state.output = input;
                    return state;
                }
                state.output = utils.wrapOutput(output, state, options);
                return state;
            }
            while(!eos()){
                value = advance();
                if ('\u0000' === value) continue;
                if ('\\' === value) {
                    const next = peek();
                    if ('/' === next && true !== opts.bash) continue;
                    if ('.' === next || ';' === next) continue;
                    if (!next) {
                        value += '\\';
                        push({
                            type: 'text',
                            value
                        });
                        continue;
                    }
                    const match = /^\\+/.exec(remaining());
                    let slashes = 0;
                    if (match && match[0].length > 2) {
                        slashes = match[0].length;
                        state.index += slashes;
                        if (slashes % 2 !== 0) value += '\\';
                    }
                    if (true === opts.unescape) value = advance();
                    else value += advance();
                    if (0 === state.brackets) {
                        push({
                            type: 'text',
                            value
                        });
                        continue;
                    }
                }
                if (state.brackets > 0 && (']' !== value || '[' === prev.value || '[^' === prev.value)) {
                    if (false !== opts.posix && ':' === value) {
                        const inner = prev.value.slice(1);
                        if (inner.includes('[')) {
                            prev.posix = true;
                            if (inner.includes(':')) {
                                const idx = prev.value.lastIndexOf('[');
                                const pre = prev.value.slice(0, idx);
                                const rest = prev.value.slice(idx + 2);
                                const posix = POSIX_REGEX_SOURCE[rest];
                                if (posix) {
                                    prev.value = pre + posix;
                                    state.backtrack = true;
                                    advance();
                                    if (!bos.output && 1 === tokens.indexOf(prev)) bos.output = ONE_CHAR;
                                    continue;
                                }
                            }
                        }
                    }
                    if ('[' === value && ':' !== peek() || '-' === value && ']' === peek()) value = `\\${value}`;
                    if (']' === value && ('[' === prev.value || '[^' === prev.value)) value = `\\${value}`;
                    if (true === opts.posix && '!' === value && '[' === prev.value) value = '^';
                    prev.value += value;
                    append({
                        value
                    });
                    continue;
                }
                if (1 === state.quotes && '"' !== value) {
                    value = utils.escapeRegex(value);
                    prev.value += value;
                    append({
                        value
                    });
                    continue;
                }
                if ('"' === value) {
                    state.quotes = 1 === state.quotes ? 0 : 1;
                    if (true === opts.keepQuotes) push({
                        type: 'text',
                        value
                    });
                    continue;
                }
                if ('(' === value) {
                    increment('parens');
                    push({
                        type: 'paren',
                        value
                    });
                    continue;
                }
                if (')' === value) {
                    if (0 === state.parens && true === opts.strictBrackets) throw new SyntaxError(syntaxError('opening', '('));
                    const extglob = extglobs[extglobs.length - 1];
                    if (extglob && state.parens === extglob.parens + 1) {
                        extglobClose(extglobs.pop());
                        continue;
                    }
                    push({
                        type: 'paren',
                        value,
                        output: state.parens ? ')' : '\\)'
                    });
                    decrement('parens');
                    continue;
                }
                if ('[' === value) {
                    if (true !== opts.nobracket && remaining().includes(']')) increment('brackets');
                    else {
                        if (true !== opts.nobracket && true === opts.strictBrackets) throw new SyntaxError(syntaxError('closing', ']'));
                        value = `\\${value}`;
                    }
                    push({
                        type: 'bracket',
                        value
                    });
                    continue;
                }
                if (']' === value) {
                    if (true === opts.nobracket || prev && 'bracket' === prev.type && 1 === prev.value.length) {
                        push({
                            type: 'text',
                            value,
                            output: `\\${value}`
                        });
                        continue;
                    }
                    if (0 === state.brackets) {
                        if (true === opts.strictBrackets) throw new SyntaxError(syntaxError('opening', '['));
                        push({
                            type: 'text',
                            value,
                            output: `\\${value}`
                        });
                        continue;
                    }
                    decrement('brackets');
                    const prevValue = prev.value.slice(1);
                    if (true !== prev.posix && '^' === prevValue[0] && !prevValue.includes('/')) value = `/${value}`;
                    prev.value += value;
                    append({
                        value
                    });
                    if (false === opts.literalBrackets || utils.hasRegexChars(prevValue)) continue;
                    const escaped = utils.escapeRegex(prev.value);
                    state.output = state.output.slice(0, -prev.value.length);
                    if (true === opts.literalBrackets) {
                        state.output += escaped;
                        prev.value = escaped;
                        continue;
                    }
                    prev.value = `(${capture}${escaped}|${prev.value})`;
                    state.output += prev.value;
                    continue;
                }
                if ('{' === value && true !== opts.nobrace) {
                    increment('braces');
                    const open = {
                        type: 'brace',
                        value,
                        output: '(',
                        outputIndex: state.output.length,
                        tokensIndex: state.tokens.length
                    };
                    braces.push(open);
                    push(open);
                    continue;
                }
                if ('}' === value) {
                    const brace = braces[braces.length - 1];
                    if (true === opts.nobrace || !brace) {
                        push({
                            type: 'text',
                            value,
                            output: value
                        });
                        continue;
                    }
                    let output = ')';
                    if (true === brace.dots) {
                        const arr = tokens.slice();
                        const range = [];
                        for(let i = arr.length - 1; i >= 0; i--){
                            tokens.pop();
                            if ('brace' === arr[i].type) break;
                            if ('dots' !== arr[i].type) range.unshift(arr[i].value);
                        }
                        output = expandRange(range, opts);
                        state.backtrack = true;
                    }
                    if (true !== brace.comma && true !== brace.dots) {
                        const out = state.output.slice(0, brace.outputIndex);
                        const toks = state.tokens.slice(brace.tokensIndex);
                        brace.value = brace.output = '\\{';
                        value = output = '\\}';
                        state.output = out;
                        for (const t of toks)state.output += t.output || t.value;
                    }
                    push({
                        type: 'brace',
                        value,
                        output
                    });
                    decrement('braces');
                    braces.pop();
                    continue;
                }
                if ('|' === value) {
                    if (extglobs.length > 0) extglobs[extglobs.length - 1].conditions++;
                    push({
                        type: 'text',
                        value
                    });
                    continue;
                }
                if (',' === value) {
                    let output = value;
                    const brace = braces[braces.length - 1];
                    if (brace && 'braces' === stack[stack.length - 1]) {
                        brace.comma = true;
                        output = '|';
                    }
                    push({
                        type: 'comma',
                        value,
                        output
                    });
                    continue;
                }
                if ('/' === value) {
                    if ('dot' === prev.type && state.index === state.start + 1) {
                        state.start = state.index + 1;
                        state.consumed = '';
                        state.output = '';
                        tokens.pop();
                        prev = bos;
                        continue;
                    }
                    push({
                        type: 'slash',
                        value,
                        output: SLASH_LITERAL
                    });
                    continue;
                }
                if ('.' === value) {
                    if (state.braces > 0 && 'dot' === prev.type) {
                        if ('.' === prev.value) prev.output = DOT_LITERAL;
                        const brace = braces[braces.length - 1];
                        prev.type = 'dots';
                        prev.output += value;
                        prev.value += value;
                        brace.dots = true;
                        continue;
                    }
                    if (state.braces + state.parens === 0 && 'bos' !== prev.type && 'slash' !== prev.type) {
                        push({
                            type: 'text',
                            value,
                            output: DOT_LITERAL
                        });
                        continue;
                    }
                    push({
                        type: 'dot',
                        value,
                        output: DOT_LITERAL
                    });
                    continue;
                }
                if ('?' === value) {
                    const isGroup = prev && '(' === prev.value;
                    if (!isGroup && true !== opts.noextglob && '(' === peek() && '?' !== peek(2)) {
                        extglobOpen('qmark', value);
                        continue;
                    }
                    if (prev && 'paren' === prev.type) {
                        const next = peek();
                        let output = value;
                        if ('(' === prev.value && !/[!=<:]/.test(next) || '<' === next && !/<([!=]|\w+>)/.test(remaining())) output = `\\${value}`;
                        push({
                            type: 'text',
                            value,
                            output
                        });
                        continue;
                    }
                    if (true !== opts.dot && ('slash' === prev.type || 'bos' === prev.type)) {
                        push({
                            type: 'qmark',
                            value,
                            output: QMARK_NO_DOT
                        });
                        continue;
                    }
                    push({
                        type: 'qmark',
                        value,
                        output: QMARK
                    });
                    continue;
                }
                if ('!' === value) {
                    if (true !== opts.noextglob && '(' === peek()) {
                        if ('?' !== peek(2) || !/[!=<:]/.test(peek(3))) {
                            extglobOpen('negate', value);
                            continue;
                        }
                    }
                    if (true !== opts.nonegate && 0 === state.index) {
                        negate();
                        continue;
                    }
                }
                if ('+' === value) {
                    if (true !== opts.noextglob && '(' === peek() && '?' !== peek(2)) {
                        extglobOpen('plus', value);
                        continue;
                    }
                    if (prev && '(' === prev.value || false === opts.regex) {
                        push({
                            type: 'plus',
                            value,
                            output: PLUS_LITERAL
                        });
                        continue;
                    }
                    if (prev && ('bracket' === prev.type || 'paren' === prev.type || 'brace' === prev.type) || state.parens > 0) {
                        push({
                            type: 'plus',
                            value
                        });
                        continue;
                    }
                    push({
                        type: 'plus',
                        value: PLUS_LITERAL
                    });
                    continue;
                }
                if ('@' === value) {
                    if (true !== opts.noextglob && '(' === peek() && '?' !== peek(2)) {
                        push({
                            type: 'at',
                            extglob: true,
                            value,
                            output: ''
                        });
                        continue;
                    }
                    push({
                        type: 'text',
                        value
                    });
                    continue;
                }
                if ('*' !== value) {
                    if ('$' === value || '^' === value) value = `\\${value}`;
                    const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
                    if (match) {
                        value += match[0];
                        state.index += match[0].length;
                    }
                    push({
                        type: 'text',
                        value
                    });
                    continue;
                }
                if (prev && ('globstar' === prev.type || true === prev.star)) {
                    prev.type = 'star';
                    prev.star = true;
                    prev.value += value;
                    prev.output = star;
                    state.backtrack = true;
                    state.globstar = true;
                    consume(value);
                    continue;
                }
                let rest = remaining();
                if (true !== opts.noextglob && /^\([^?]/.test(rest)) {
                    extglobOpen('star', value);
                    continue;
                }
                if ('star' === prev.type) {
                    if (true === opts.noglobstar) {
                        consume(value);
                        continue;
                    }
                    const prior = prev.prev;
                    const before = prior.prev;
                    const isStart = 'slash' === prior.type || 'bos' === prior.type;
                    const afterStar = before && ('star' === before.type || 'globstar' === before.type);
                    if (true === opts.bash && (!isStart || rest[0] && '/' !== rest[0])) {
                        push({
                            type: 'star',
                            value,
                            output: ''
                        });
                        continue;
                    }
                    const isBrace = state.braces > 0 && ('comma' === prior.type || 'brace' === prior.type);
                    const isExtglob = extglobs.length && ('pipe' === prior.type || 'paren' === prior.type);
                    if (!isStart && 'paren' !== prior.type && !isBrace && !isExtglob) {
                        push({
                            type: 'star',
                            value,
                            output: ''
                        });
                        continue;
                    }
                    while('/**' === rest.slice(0, 3)){
                        const after = input[state.index + 4];
                        if (after && '/' !== after) break;
                        rest = rest.slice(3);
                        consume('/**', 3);
                    }
                    if ('bos' === prior.type && eos()) {
                        prev.type = 'globstar';
                        prev.value += value;
                        prev.output = globstar(opts);
                        state.output = prev.output;
                        state.globstar = true;
                        consume(value);
                        continue;
                    }
                    if ('slash' === prior.type && 'bos' !== prior.prev.type && !afterStar && eos()) {
                        state.output = state.output.slice(0, -(prior.output + prev.output).length);
                        prior.output = `(?:${prior.output}`;
                        prev.type = 'globstar';
                        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
                        prev.value += value;
                        state.globstar = true;
                        state.output += prior.output + prev.output;
                        consume(value);
                        continue;
                    }
                    if ('slash' === prior.type && 'bos' !== prior.prev.type && '/' === rest[0]) {
                        const end = void 0 !== rest[1] ? '|$' : '';
                        state.output = state.output.slice(0, -(prior.output + prev.output).length);
                        prior.output = `(?:${prior.output}`;
                        prev.type = 'globstar';
                        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
                        prev.value += value;
                        state.output += prior.output + prev.output;
                        state.globstar = true;
                        consume(value + advance());
                        push({
                            type: 'slash',
                            value: '/',
                            output: ''
                        });
                        continue;
                    }
                    if ('bos' === prior.type && '/' === rest[0]) {
                        prev.type = 'globstar';
                        prev.value += value;
                        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
                        state.output = prev.output;
                        state.globstar = true;
                        consume(value + advance());
                        push({
                            type: 'slash',
                            value: '/',
                            output: ''
                        });
                        continue;
                    }
                    state.output = state.output.slice(0, -prev.output.length);
                    prev.type = 'globstar';
                    prev.output = globstar(opts);
                    prev.value += value;
                    state.output += prev.output;
                    state.globstar = true;
                    consume(value);
                    continue;
                }
                const token = {
                    type: 'star',
                    value,
                    output: star
                };
                if (true === opts.bash) {
                    token.output = '.*?';
                    if ('bos' === prev.type || 'slash' === prev.type) token.output = nodot + token.output;
                    push(token);
                    continue;
                }
                if (prev && ('bracket' === prev.type || 'paren' === prev.type) && true === opts.regex) {
                    token.output = value;
                    push(token);
                    continue;
                }
                if (state.index === state.start || 'slash' === prev.type || 'dot' === prev.type) {
                    if ('dot' === prev.type) {
                        state.output += NO_DOT_SLASH;
                        prev.output += NO_DOT_SLASH;
                    } else if (true === opts.dot) {
                        state.output += NO_DOTS_SLASH;
                        prev.output += NO_DOTS_SLASH;
                    } else {
                        state.output += nodot;
                        prev.output += nodot;
                    }
                    if ('*' !== peek()) {
                        state.output += ONE_CHAR;
                        prev.output += ONE_CHAR;
                    }
                }
                push(token);
            }
            while(state.brackets > 0){
                if (true === opts.strictBrackets) throw new SyntaxError(syntaxError('closing', ']'));
                state.output = utils.escapeLast(state.output, '[');
                decrement('brackets');
            }
            while(state.parens > 0){
                if (true === opts.strictBrackets) throw new SyntaxError(syntaxError('closing', ')'));
                state.output = utils.escapeLast(state.output, '(');
                decrement('parens');
            }
            while(state.braces > 0){
                if (true === opts.strictBrackets) throw new SyntaxError(syntaxError('closing', '}'));
                state.output = utils.escapeLast(state.output, '{');
                decrement('braces');
            }
            if (true !== opts.strictSlashes && ('star' === prev.type || 'bracket' === prev.type)) push({
                type: 'maybe_slash',
                value: '',
                output: `${SLASH_LITERAL}?`
            });
            if (true === state.backtrack) {
                state.output = '';
                for (const token of state.tokens){
                    state.output += null != token.output ? token.output : token.value;
                    if (token.suffix) state.output += token.suffix;
                }
            }
            return state;
        };
        parse.fastpaths = (input, options)=>{
            const opts = {
                ...options
            };
            const max = 'number' == typeof opts.maxLength ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
            const len = input.length;
            if (len > max) throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
            input = REPLACEMENTS[input] || input;
            const { DOT_LITERAL, SLASH_LITERAL, ONE_CHAR, DOTS_SLASH, NO_DOT, NO_DOTS, NO_DOTS_SLASH, STAR, START_ANCHOR } = constants.globChars(opts.windows);
            const nodot = opts.dot ? NO_DOTS : NO_DOT;
            const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
            const capture = opts.capture ? '' : '?:';
            const state = {
                negated: false,
                prefix: ''
            };
            let star = true === opts.bash ? '.*?' : STAR;
            if (opts.capture) star = `(${star})`;
            const globstar = (opts)=>{
                if (true === opts.noglobstar) return star;
                return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
            };
            const create = (str)=>{
                switch(str){
                    case '*':
                        return `${nodot}${ONE_CHAR}${star}`;
                    case '.*':
                        return `${DOT_LITERAL}${ONE_CHAR}${star}`;
                    case '*.*':
                        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
                    case '*/*':
                        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
                    case '**':
                        return nodot + globstar(opts);
                    case '**/*':
                        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
                    case '**/*.*':
                        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
                    case '**/.*':
                        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
                    default:
                        {
                            const match = /^(.*?)\.(\w+)$/.exec(str);
                            if (!match) return;
                            const source = create(match[1]);
                            if (!source) return;
                            return source + DOT_LITERAL + match[2];
                        }
                }
            };
            const output = utils.removePrefix(input, state);
            let source = create(output);
            if (source && true !== opts.strictSlashes) source += `${SLASH_LITERAL}?`;
            return source;
        };
        module.exports = parse;
    },
    "../../node_modules/.pnpm/picomatch@4.0.3/node_modules/picomatch/lib/picomatch.js" (module, __unused_rspack_exports, __webpack_require__) {
        const scan = __webpack_require__("../../node_modules/.pnpm/picomatch@4.0.3/node_modules/picomatch/lib/scan.js");
        const parse = __webpack_require__("../../node_modules/.pnpm/picomatch@4.0.3/node_modules/picomatch/lib/parse.js");
        const utils = __webpack_require__("../../node_modules/.pnpm/picomatch@4.0.3/node_modules/picomatch/lib/utils.js");
        const constants = __webpack_require__("../../node_modules/.pnpm/picomatch@4.0.3/node_modules/picomatch/lib/constants.js");
        const isObject = (val)=>val && 'object' == typeof val && !Array.isArray(val);
        const picomatch = (glob, options, returnState = false)=>{
            if (Array.isArray(glob)) {
                const fns = glob.map((input)=>picomatch(input, options, returnState));
                const arrayMatcher = (str)=>{
                    for (const isMatch of fns){
                        const state = isMatch(str);
                        if (state) return state;
                    }
                    return false;
                };
                return arrayMatcher;
            }
            const isState = isObject(glob) && glob.tokens && glob.input;
            if ('' === glob || 'string' != typeof glob && !isState) throw new TypeError('Expected pattern to be a non-empty string');
            const opts = options || {};
            const posix = opts.windows;
            const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
            const state = regex.state;
            delete regex.state;
            let isIgnored = ()=>false;
            if (opts.ignore) {
                const ignoreOpts = {
                    ...options,
                    ignore: null,
                    onMatch: null,
                    onResult: null
                };
                isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
            }
            const matcher = (input, returnObject = false)=>{
                const { isMatch, match, output } = picomatch.test(input, regex, options, {
                    glob,
                    posix
                });
                const result = {
                    glob,
                    state,
                    regex,
                    posix,
                    input,
                    output,
                    match,
                    isMatch
                };
                if ('function' == typeof opts.onResult) opts.onResult(result);
                if (false === isMatch) {
                    result.isMatch = false;
                    return returnObject ? result : false;
                }
                if (isIgnored(input)) {
                    if ('function' == typeof opts.onIgnore) opts.onIgnore(result);
                    result.isMatch = false;
                    return returnObject ? result : false;
                }
                if ('function' == typeof opts.onMatch) opts.onMatch(result);
                return returnObject ? result : true;
            };
            if (returnState) matcher.state = state;
            return matcher;
        };
        picomatch.test = (input, regex, options, { glob, posix } = {})=>{
            if ('string' != typeof input) throw new TypeError('Expected input to be a string');
            if ('' === input) return {
                isMatch: false,
                output: ''
            };
            const opts = options || {};
            const format = opts.format || (posix ? utils.toPosixSlashes : null);
            let match = input === glob;
            let output = match && format ? format(input) : input;
            if (false === match) {
                output = format ? format(input) : input;
                match = output === glob;
            }
            if (false === match || true === opts.capture) match = true === opts.matchBase || true === opts.basename ? picomatch.matchBase(input, regex, options, posix) : regex.exec(output);
            return {
                isMatch: Boolean(match),
                match,
                output
            };
        };
        picomatch.matchBase = (input, glob, options)=>{
            const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
            return regex.test(utils.basename(input));
        };
        picomatch.isMatch = (str, patterns, options)=>picomatch(patterns, options)(str);
        picomatch.parse = (pattern, options)=>{
            if (Array.isArray(pattern)) return pattern.map((p)=>picomatch.parse(p, options));
            return parse(pattern, {
                ...options,
                fastpaths: false
            });
        };
        picomatch.scan = (input, options)=>scan(input, options);
        picomatch.compileRe = (state, options, returnOutput = false, returnState = false)=>{
            if (true === returnOutput) return state.output;
            const opts = options || {};
            const prepend = opts.contains ? '' : '^';
            const append = opts.contains ? '' : '$';
            let source = `${prepend}(?:${state.output})${append}`;
            if (state && true === state.negated) source = `^(?!${source}).*$`;
            const regex = picomatch.toRegex(source, options);
            if (true === returnState) regex.state = state;
            return regex;
        };
        picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false)=>{
            if (!input || 'string' != typeof input) throw new TypeError('Expected a non-empty string');
            let parsed = {
                negated: false,
                fastpaths: true
            };
            if (false !== options.fastpaths && ('.' === input[0] || '*' === input[0])) parsed.output = parse.fastpaths(input, options);
            if (!parsed.output) parsed = parse(input, options);
            return picomatch.compileRe(parsed, options, returnOutput, returnState);
        };
        picomatch.toRegex = (source, options)=>{
            try {
                const opts = options || {};
                return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
            } catch (err) {
                if (options && true === options.debug) throw err;
                return /$^/;
            }
        };
        picomatch.constants = constants;
        module.exports = picomatch;
    },
    "../../node_modules/.pnpm/picomatch@4.0.3/node_modules/picomatch/lib/scan.js" (module, __unused_rspack_exports, __webpack_require__) {
        const utils = __webpack_require__("../../node_modules/.pnpm/picomatch@4.0.3/node_modules/picomatch/lib/utils.js");
        const { CHAR_ASTERISK, CHAR_AT, CHAR_BACKWARD_SLASH, CHAR_COMMA, CHAR_DOT, CHAR_EXCLAMATION_MARK, CHAR_FORWARD_SLASH, CHAR_LEFT_CURLY_BRACE, CHAR_LEFT_PARENTHESES, CHAR_LEFT_SQUARE_BRACKET, CHAR_PLUS, CHAR_QUESTION_MARK, CHAR_RIGHT_CURLY_BRACE, CHAR_RIGHT_PARENTHESES, CHAR_RIGHT_SQUARE_BRACKET } = __webpack_require__("../../node_modules/.pnpm/picomatch@4.0.3/node_modules/picomatch/lib/constants.js");
        const isPathSeparator = (code)=>code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
        const depth = (token)=>{
            if (true !== token.isPrefix) token.depth = token.isGlobstar ? 1 / 0 : 1;
        };
        const scan = (input, options)=>{
            const opts = options || {};
            const length = input.length - 1;
            const scanToEnd = true === opts.parts || true === opts.scanToEnd;
            const slashes = [];
            const tokens = [];
            const parts = [];
            let str = input;
            let index = -1;
            let start = 0;
            let lastIndex = 0;
            let isBrace = false;
            let isBracket = false;
            let isGlob = false;
            let isExtglob = false;
            let isGlobstar = false;
            let braceEscaped = false;
            let backslashes = false;
            let negated = false;
            let negatedExtglob = false;
            let finished = false;
            let braces = 0;
            let prev;
            let code;
            let token = {
                value: '',
                depth: 0,
                isGlob: false
            };
            const eos = ()=>index >= length;
            const peek = ()=>str.charCodeAt(index + 1);
            const advance = ()=>{
                prev = code;
                return str.charCodeAt(++index);
            };
            while(index < length){
                code = advance();
                let next;
                if (code === CHAR_BACKWARD_SLASH) {
                    backslashes = token.backslashes = true;
                    code = advance();
                    if (code === CHAR_LEFT_CURLY_BRACE) braceEscaped = true;
                    continue;
                }
                if (true === braceEscaped || code === CHAR_LEFT_CURLY_BRACE) {
                    braces++;
                    while(true !== eos() && (code = advance())){
                        if (code === CHAR_BACKWARD_SLASH) {
                            backslashes = token.backslashes = true;
                            advance();
                            continue;
                        }
                        if (code === CHAR_LEFT_CURLY_BRACE) {
                            braces++;
                            continue;
                        }
                        if (true !== braceEscaped && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
                            isBrace = token.isBrace = true;
                            isGlob = token.isGlob = true;
                            finished = true;
                            if (true === scanToEnd) continue;
                            break;
                        }
                        if (true !== braceEscaped && code === CHAR_COMMA) {
                            isBrace = token.isBrace = true;
                            isGlob = token.isGlob = true;
                            finished = true;
                            if (true === scanToEnd) continue;
                            break;
                        }
                        if (code === CHAR_RIGHT_CURLY_BRACE) {
                            braces--;
                            if (0 === braces) {
                                braceEscaped = false;
                                isBrace = token.isBrace = true;
                                finished = true;
                                break;
                            }
                        }
                    }
                    if (true === scanToEnd) continue;
                    break;
                }
                if (code === CHAR_FORWARD_SLASH) {
                    slashes.push(index);
                    tokens.push(token);
                    token = {
                        value: '',
                        depth: 0,
                        isGlob: false
                    };
                    if (true === finished) continue;
                    if (prev === CHAR_DOT && index === start + 1) {
                        start += 2;
                        continue;
                    }
                    lastIndex = index + 1;
                    continue;
                }
                if (true !== opts.noext) {
                    const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
                    if (true === isExtglobChar && peek() === CHAR_LEFT_PARENTHESES) {
                        isGlob = token.isGlob = true;
                        isExtglob = token.isExtglob = true;
                        finished = true;
                        if (code === CHAR_EXCLAMATION_MARK && index === start) negatedExtglob = true;
                        if (true === scanToEnd) {
                            while(true !== eos() && (code = advance())){
                                if (code === CHAR_BACKWARD_SLASH) {
                                    backslashes = token.backslashes = true;
                                    code = advance();
                                    continue;
                                }
                                if (code === CHAR_RIGHT_PARENTHESES) {
                                    isGlob = token.isGlob = true;
                                    finished = true;
                                    break;
                                }
                            }
                            continue;
                        }
                        break;
                    }
                }
                if (code === CHAR_ASTERISK) {
                    if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    if (true === scanToEnd) continue;
                    break;
                }
                if (code === CHAR_QUESTION_MARK) {
                    isGlob = token.isGlob = true;
                    finished = true;
                    if (true === scanToEnd) continue;
                    break;
                }
                if (code === CHAR_LEFT_SQUARE_BRACKET) {
                    while(true !== eos() && (next = advance())){
                        if (next === CHAR_BACKWARD_SLASH) {
                            backslashes = token.backslashes = true;
                            advance();
                            continue;
                        }
                        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                            isBracket = token.isBracket = true;
                            isGlob = token.isGlob = true;
                            finished = true;
                            break;
                        }
                    }
                    if (true === scanToEnd) continue;
                    break;
                }
                if (true !== opts.nonegate && code === CHAR_EXCLAMATION_MARK && index === start) {
                    negated = token.negated = true;
                    start++;
                    continue;
                }
                if (true !== opts.noparen && code === CHAR_LEFT_PARENTHESES) {
                    isGlob = token.isGlob = true;
                    if (true === scanToEnd) {
                        while(true !== eos() && (code = advance())){
                            if (code === CHAR_LEFT_PARENTHESES) {
                                backslashes = token.backslashes = true;
                                code = advance();
                                continue;
                            }
                            if (code === CHAR_RIGHT_PARENTHESES) {
                                finished = true;
                                break;
                            }
                        }
                        continue;
                    }
                    break;
                }
                if (true === isGlob) {
                    finished = true;
                    if (true === scanToEnd) continue;
                    break;
                }
            }
            if (true === opts.noext) {
                isExtglob = false;
                isGlob = false;
            }
            let base = str;
            let prefix = '';
            let glob = '';
            if (start > 0) {
                prefix = str.slice(0, start);
                str = str.slice(start);
                lastIndex -= start;
            }
            if (base && true === isGlob && lastIndex > 0) {
                base = str.slice(0, lastIndex);
                glob = str.slice(lastIndex);
            } else if (true === isGlob) {
                base = '';
                glob = str;
            } else base = str;
            if (base && '' !== base && '/' !== base && base !== str) {
                if (isPathSeparator(base.charCodeAt(base.length - 1))) base = base.slice(0, -1);
            }
            if (true === opts.unescape) {
                if (glob) glob = utils.removeBackslashes(glob);
                if (base && true === backslashes) base = utils.removeBackslashes(base);
            }
            const state = {
                prefix,
                input,
                start,
                base,
                glob,
                isBrace,
                isBracket,
                isGlob,
                isExtglob,
                isGlobstar,
                negated,
                negatedExtglob
            };
            if (true === opts.tokens) {
                state.maxDepth = 0;
                if (!isPathSeparator(code)) tokens.push(token);
                state.tokens = tokens;
            }
            if (true === opts.parts || true === opts.tokens) {
                let prevIndex;
                for(let idx = 0; idx < slashes.length; idx++){
                    const n = prevIndex ? prevIndex + 1 : start;
                    const i = slashes[idx];
                    const value = input.slice(n, i);
                    if (opts.tokens) {
                        if (0 === idx && 0 !== start) {
                            tokens[idx].isPrefix = true;
                            tokens[idx].value = prefix;
                        } else tokens[idx].value = value;
                        depth(tokens[idx]);
                        state.maxDepth += tokens[idx].depth;
                    }
                    if (0 !== idx || '' !== value) parts.push(value);
                    prevIndex = i;
                }
                if (prevIndex && prevIndex + 1 < input.length) {
                    const value = input.slice(prevIndex + 1);
                    parts.push(value);
                    if (opts.tokens) {
                        tokens[tokens.length - 1].value = value;
                        depth(tokens[tokens.length - 1]);
                        state.maxDepth += tokens[tokens.length - 1].depth;
                    }
                }
                state.slashes = slashes;
                state.parts = parts;
            }
            return state;
        };
        module.exports = scan;
    },
    "../../node_modules/.pnpm/picomatch@4.0.3/node_modules/picomatch/lib/utils.js" (__unused_rspack_module, exports, __webpack_require__) {
        const { REGEX_BACKSLASH, REGEX_REMOVE_BACKSLASH, REGEX_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_GLOBAL } = __webpack_require__("../../node_modules/.pnpm/picomatch@4.0.3/node_modules/picomatch/lib/constants.js");
        exports.isObject = (val)=>null !== val && 'object' == typeof val && !Array.isArray(val);
        exports.hasRegexChars = (str)=>REGEX_SPECIAL_CHARS.test(str);
        exports.isRegexChar = (str)=>1 === str.length && exports.hasRegexChars(str);
        exports.escapeRegex = (str)=>str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
        exports.toPosixSlashes = (str)=>str.replace(REGEX_BACKSLASH, '/');
        exports.isWindows = ()=>{
            if ('undefined' != typeof navigator && navigator.platform) {
                const platform = navigator.platform.toLowerCase();
                return 'win32' === platform || 'windows' === platform;
            }
            if ('undefined' != typeof process && process.platform) return 'win32' === process.platform;
            return false;
        };
        exports.removeBackslashes = (str)=>str.replace(REGEX_REMOVE_BACKSLASH, (match)=>'\\' === match ? '' : match);
        exports.escapeLast = (input, char, lastIdx)=>{
            const idx = input.lastIndexOf(char, lastIdx);
            if (-1 === idx) return input;
            if ('\\' === input[idx - 1]) return exports.escapeLast(input, char, idx - 1);
            return `${input.slice(0, idx)}\\${input.slice(idx)}`;
        };
        exports.removePrefix = (input, state = {})=>{
            let output = input;
            if (output.startsWith('./')) {
                output = output.slice(2);
                state.prefix = './';
            }
            return output;
        };
        exports.wrapOutput = (input, state = {}, options = {})=>{
            const prepend = options.contains ? '' : '^';
            const append = options.contains ? '' : '$';
            let output = `${prepend}(?:${input})${append}`;
            if (true === state.negated) output = `(?:^(?!${output}).*$)`;
            return output;
        };
        exports.basename = (path, { windows } = {})=>{
            const segs = path.split(windows ? /[\\/]/ : '/');
            const last = segs[segs.length - 1];
            if ('' === last) return segs[segs.length - 2];
            return last;
        };
    }
});
const picocolors = __webpack_require__("../../node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js");
var picocolors_default = /*#__PURE__*/ __webpack_require__.n(picocolors);
const formatRootStr = (rootStr, root)=>rootStr.replace('<rootDir>', normalize(root));
function getAbsolutePath(base, filepath) {
    return isAbsolute(filepath) ? filepath : join(base, filepath);
}
const parsePosix = (filePath)=>{
    const { dir, base } = parse(filePath);
    return {
        dir: dir.split("/").join('/'),
        base
    };
};
const isObject = (obj)=>'[object Object]' === Object.prototype.toString.call(obj);
const castArray = (arr)=>{
    if (void 0 === arr) return [];
    return Array.isArray(arr) ? arr : [
        arr
    ];
};
const isPlainObject = (obj)=>null !== obj && 'object' == typeof obj && Object.getPrototypeOf(obj) === Object.prototype;
function formatError(error) {
    if ('string' == typeof error || error instanceof Error) return error;
    if (isPlainObject(error) && error.message) {
        const e = new Error(error.name || 'unknown error');
        e.message = error.message;
        e.stack = error.stack;
        return e;
    }
    return String(error);
}
const prettyTime = (milliseconds)=>{
    if (milliseconds < 1000) return `${Math.round(milliseconds)}ms`;
    const seconds = milliseconds / 1000;
    const getSecond = (seconds, needDigits)=>{
        if (!needDigits || seconds === Math.ceil(seconds)) return `${Math.round(seconds).toString()}s`;
        const digits = seconds < 10 ? seconds >= 0.01 ? 2 : 3 : 1;
        return `${seconds.toFixed(digits)}s`;
    };
    const minutes = Math.floor(seconds / 60);
    const secondsRemainder = seconds % 60;
    let time = '';
    if (minutes > 0) time += `${minutes}m`;
    if (secondsRemainder > 0) {
        if (minutes > 0) time += ' ';
        time += getSecond(secondsRemainder, !minutes);
    }
    return time;
};
const getTaskNames = (test)=>(test.parentNames || []).concat(test.name).filter(Boolean);
const getTaskNameWithPrefix = (test, delimiter = ">")=>getTaskNames(test).join(` ${delimiter} `);
const REGEXP_FLAG_PREFIX = 'RSTEST_REGEXP:';
const wrapRegex = (value)=>`${REGEXP_FLAG_PREFIX}${value.toString()}`;
const unwrapRegex = (value)=>{
    if (value.startsWith(REGEXP_FLAG_PREFIX)) {
        const regexStr = value.slice(REGEXP_FLAG_PREFIX.length);
        const matches = regexStr.match(/^\/(.+)\/([gimuy]*)$/);
        if (matches) {
            const [, pattern, flags] = matches;
            return new RegExp(pattern, flags);
        }
    }
    return value;
};
const serializableConfig = (normalizedConfig)=>{
    const { testNamePattern } = normalizedConfig;
    return {
        ...normalizedConfig,
        testNamePattern: testNamePattern && 'string' != typeof testNamePattern ? wrapRegex(testNamePattern) : testNamePattern
    };
};
const undoSerializableConfig = (normalizedConfig)=>{
    const { testNamePattern } = normalizedConfig;
    return {
        ...normalizedConfig,
        testNamePattern: testNamePattern && 'string' == typeof testNamePattern ? unwrapRegex(testNamePattern) : testNamePattern
    };
};
const getNodeVersion = ()=>{
    if ('string' == typeof process.versions?.node) {
        const [major = 0, minor = 0, patch = 0] = process.versions.node.split('.').map(Number);
        return {
            major,
            minor,
            patch
        };
    }
    return {
        major: 0,
        minor: 0,
        patch: 0
    };
};
const needFlagExperimentalDetectModule = ()=>{
    const { major, minor } = getNodeVersion();
    if (20 === major && minor >= 10) return true;
    if (22 === major && minor < 7) return true;
    return false;
};
const ADDITIONAL_NODE_BUILTINS = [
    /^node:/,
    'pnpapi'
];
const bgColor = (background, str)=>{
    if ([
        'bgRed',
        'bgBlack'
    ].includes(background)) return picocolors_default()[background](picocolors_default().white(picocolors_default().bold(str)));
    return picocolors_default()[background](picocolors_default().blackBright(picocolors_default().bold(str)));
};
const isTTY = (type = 'stdout')=>('stdin' === type ? process.stdin.isTTY : process.stdout.isTTY) && !process.env.CI;
const external_node_path_ = __webpack_require__("node:path");
const external_node_fs_ = __webpack_require__("fs");
var __require = /* @__PURE__ */ createRequire(import.meta.url);
function cleanPath(path) {
    let normalized = (0, external_node_path_.normalize)(path);
    if (normalized.length > 1 && normalized[normalized.length - 1] === external_node_path_.sep) normalized = normalized.substring(0, normalized.length - 1);
    return normalized;
}
const SLASHES_REGEX = /[\\/]/g;
function convertSlashes(path, separator) {
    return path.replace(SLASHES_REGEX, separator);
}
const WINDOWS_ROOT_DIR_REGEX = /^[a-z]:[\\/]$/i;
function isRootDirectory(path) {
    return "/" === path || WINDOWS_ROOT_DIR_REGEX.test(path);
}
function normalizePath(path, options) {
    const { resolvePaths, normalizePath: normalizePath$1, pathSeparator } = options;
    const pathNeedsCleaning = "win32" === process.platform && path.includes("/") || path.startsWith(".");
    if (resolvePaths) path = (0, external_node_path_.resolve)(path);
    if (normalizePath$1 || pathNeedsCleaning) path = cleanPath(path);
    if ("." === path) return "";
    const needsSeperator = path[path.length - 1] !== pathSeparator;
    return convertSlashes(needsSeperator ? path + pathSeparator : path, pathSeparator);
}
function joinPathWithBasePath(filename, directoryPath) {
    return directoryPath + filename;
}
function joinPathWithRelativePath(root, options) {
    return function(filename, directoryPath) {
        const sameRoot = directoryPath.startsWith(root);
        if (sameRoot) return directoryPath.slice(root.length) + filename;
        return convertSlashes((0, external_node_path_.relative)(root, directoryPath), options.pathSeparator) + options.pathSeparator + filename;
    };
}
function joinPath(filename) {
    return filename;
}
function joinDirectoryPath(filename, directoryPath, separator) {
    return directoryPath + filename + separator;
}
function build$7(root, options) {
    const { relativePaths, includeBasePath } = options;
    return relativePaths && root ? joinPathWithRelativePath(root, options) : includeBasePath ? joinPathWithBasePath : joinPath;
}
function pushDirectoryWithRelativePath(root) {
    return function(directoryPath, paths) {
        paths.push(directoryPath.substring(root.length) || ".");
    };
}
function pushDirectoryFilterWithRelativePath(root) {
    return function(directoryPath, paths, filters) {
        const relativePath = directoryPath.substring(root.length) || ".";
        if (filters.every((filter)=>filter(relativePath, true))) paths.push(relativePath);
    };
}
const pushDirectory = (directoryPath, paths)=>{
    paths.push(directoryPath || ".");
};
const pushDirectoryFilter = (directoryPath, paths, filters)=>{
    const path = directoryPath || ".";
    if (filters.every((filter)=>filter(path, true))) paths.push(path);
};
const empty$2 = ()=>{};
function build$6(root, options) {
    const { includeDirs, filters, relativePaths } = options;
    if (!includeDirs) return empty$2;
    if (relativePaths) return filters && filters.length ? pushDirectoryFilterWithRelativePath(root) : pushDirectoryWithRelativePath(root);
    return filters && filters.length ? pushDirectoryFilter : pushDirectory;
}
const pushFileFilterAndCount = (filename, _paths, counts, filters)=>{
    if (filters.every((filter)=>filter(filename, false))) counts.files++;
};
const pushFileFilter = (filename, paths, _counts, filters)=>{
    if (filters.every((filter)=>filter(filename, false))) paths.push(filename);
};
const pushFileCount = (_filename, _paths, counts, _filters)=>{
    counts.files++;
};
const pushFile = (filename, paths)=>{
    paths.push(filename);
};
const empty$1 = ()=>{};
function build$5(options) {
    const { excludeFiles, filters, onlyCounts } = options;
    if (excludeFiles) return empty$1;
    if (filters && filters.length) return onlyCounts ? pushFileFilterAndCount : pushFileFilter;
    if (onlyCounts) return pushFileCount;
    return pushFile;
}
const getArray = (paths)=>paths;
const getArrayGroup = ()=>[
        ""
    ].slice(0, 0);
function build$4(options) {
    return options.group ? getArrayGroup : getArray;
}
const groupFiles = (groups, directory, files)=>{
    groups.push({
        directory,
        files,
        dir: directory
    });
};
const empty = ()=>{};
function build$3(options) {
    return options.group ? groupFiles : empty;
}
const resolveSymlinksAsync = function(path, state, callback$1) {
    const { queue, fs, options: { suppressErrors } } = state;
    queue.enqueue();
    fs.realpath(path, (error, resolvedPath)=>{
        if (error) return queue.dequeue(suppressErrors ? null : error, state);
        fs.stat(resolvedPath, (error$1, stat)=>{
            if (error$1) return queue.dequeue(suppressErrors ? null : error$1, state);
            if (stat.isDirectory() && isRecursive(path, resolvedPath, state)) return queue.dequeue(null, state);
            callback$1(stat, resolvedPath);
            queue.dequeue(null, state);
        });
    });
};
const resolveSymlinks = function(path, state, callback$1) {
    const { queue, fs, options: { suppressErrors } } = state;
    queue.enqueue();
    try {
        const resolvedPath = fs.realpathSync(path);
        const stat = fs.statSync(resolvedPath);
        if (stat.isDirectory() && isRecursive(path, resolvedPath, state)) return;
        callback$1(stat, resolvedPath);
    } catch (e) {
        if (!suppressErrors) throw e;
    }
};
function build$2(options, isSynchronous) {
    if (!options.resolveSymlinks || options.excludeSymlinks) return null;
    return isSynchronous ? resolveSymlinks : resolveSymlinksAsync;
}
function isRecursive(path, resolved, state) {
    if (state.options.useRealPaths) return isRecursiveUsingRealPaths(resolved, state);
    let parent = (0, external_node_path_.dirname)(path);
    let depth = 1;
    while(parent !== state.root && depth < 2){
        const resolvedPath = state.symlinks.get(parent);
        const isSameRoot = !!resolvedPath && (resolvedPath === resolved || resolvedPath.startsWith(resolved) || resolved.startsWith(resolvedPath));
        if (isSameRoot) depth++;
        else parent = (0, external_node_path_.dirname)(parent);
    }
    state.symlinks.set(path, resolved);
    return depth > 1;
}
function isRecursiveUsingRealPaths(resolved, state) {
    return state.visited.includes(resolved + state.options.pathSeparator);
}
const onlyCountsSync = (state)=>state.counts;
const groupsSync = (state)=>state.groups;
const defaultSync = (state)=>state.paths;
const limitFilesSync = (state)=>state.paths.slice(0, state.options.maxFiles);
const onlyCountsAsync = (state, error, callback$1)=>{
    report(error, callback$1, state.counts, state.options.suppressErrors);
    return null;
};
const defaultAsync = (state, error, callback$1)=>{
    report(error, callback$1, state.paths, state.options.suppressErrors);
    return null;
};
const limitFilesAsync = (state, error, callback$1)=>{
    report(error, callback$1, state.paths.slice(0, state.options.maxFiles), state.options.suppressErrors);
    return null;
};
const groupsAsync = (state, error, callback$1)=>{
    report(error, callback$1, state.groups, state.options.suppressErrors);
    return null;
};
function report(error, callback$1, output, suppressErrors) {
    callback$1(error && !suppressErrors ? error : null, output);
}
function build$1(options, isSynchronous) {
    const { onlyCounts, group, maxFiles } = options;
    if (onlyCounts) return isSynchronous ? onlyCountsSync : onlyCountsAsync;
    if (group) return isSynchronous ? groupsSync : groupsAsync;
    if (maxFiles) return isSynchronous ? limitFilesSync : limitFilesAsync;
    return isSynchronous ? defaultSync : defaultAsync;
}
const readdirOpts = {
    withFileTypes: true
};
const walkAsync = (state, crawlPath, directoryPath, currentDepth, callback$1)=>{
    state.queue.enqueue();
    if (currentDepth < 0) return state.queue.dequeue(null, state);
    const { fs } = state;
    state.visited.push(crawlPath);
    state.counts.directories++;
    fs.readdir(crawlPath || ".", readdirOpts, (error, entries = [])=>{
        callback$1(entries, directoryPath, currentDepth);
        state.queue.dequeue(state.options.suppressErrors ? null : error, state);
    });
};
const walkSync = (state, crawlPath, directoryPath, currentDepth, callback$1)=>{
    const { fs } = state;
    if (currentDepth < 0) return;
    state.visited.push(crawlPath);
    state.counts.directories++;
    let entries = [];
    try {
        entries = fs.readdirSync(crawlPath || ".", readdirOpts);
    } catch (e) {
        if (!state.options.suppressErrors) throw e;
    }
    callback$1(entries, directoryPath, currentDepth);
};
function build(isSynchronous) {
    return isSynchronous ? walkSync : walkAsync;
}
var Queue = class {
    count = 0;
    constructor(onQueueEmpty){
        this.onQueueEmpty = onQueueEmpty;
    }
    enqueue() {
        this.count++;
        return this.count;
    }
    dequeue(error, output) {
        if (this.onQueueEmpty && (--this.count <= 0 || error)) {
            this.onQueueEmpty(error, output);
            if (error) {
                output.controller.abort();
                this.onQueueEmpty = void 0;
            }
        }
    }
};
var Counter = class {
    _files = 0;
    _directories = 0;
    set files(num) {
        this._files = num;
    }
    get files() {
        return this._files;
    }
    set directories(num) {
        this._directories = num;
    }
    get directories() {
        return this._directories;
    }
    get dirs() {
        return this._directories;
    }
};
var Aborter = class {
    aborted = false;
    abort() {
        this.aborted = true;
    }
};
var Walker = class {
    root;
    isSynchronous;
    state;
    joinPath;
    pushDirectory;
    pushFile;
    getArray;
    groupFiles;
    resolveSymlink;
    walkDirectory;
    callbackInvoker;
    constructor(root, options, callback$1){
        this.isSynchronous = !callback$1;
        this.callbackInvoker = build$1(options, this.isSynchronous);
        this.root = normalizePath(root, options);
        this.state = {
            root: isRootDirectory(this.root) ? this.root : this.root.slice(0, -1),
            paths: [
                ""
            ].slice(0, 0),
            groups: [],
            counts: new Counter(),
            options,
            queue: new Queue((error, state)=>this.callbackInvoker(state, error, callback$1)),
            symlinks: /* @__PURE__ */ new Map(),
            visited: [
                ""
            ].slice(0, 0),
            controller: new Aborter(),
            fs: options.fs || external_node_fs_
        };
        this.joinPath = build$7(this.root, options);
        this.pushDirectory = build$6(this.root, options);
        this.pushFile = build$5(options);
        this.getArray = build$4(options);
        this.groupFiles = build$3(options);
        this.resolveSymlink = build$2(options, this.isSynchronous);
        this.walkDirectory = build(this.isSynchronous);
    }
    start() {
        this.pushDirectory(this.root, this.state.paths, this.state.options.filters);
        this.walkDirectory(this.state, this.root, this.root, this.state.options.maxDepth, this.walk);
        return this.isSynchronous ? this.callbackInvoker(this.state, null) : null;
    }
    walk = (entries, directoryPath, depth)=>{
        const { paths, options: { filters, resolveSymlinks: resolveSymlinks$1, excludeSymlinks, exclude, maxFiles, signal, useRealPaths, pathSeparator }, controller } = this.state;
        if (controller.aborted || signal && signal.aborted || maxFiles && paths.length > maxFiles) return;
        const files = this.getArray(this.state.paths);
        for(let i = 0; i < entries.length; ++i){
            const entry = entries[i];
            if (entry.isFile() || entry.isSymbolicLink() && !resolveSymlinks$1 && !excludeSymlinks) {
                const filename = this.joinPath(entry.name, directoryPath);
                this.pushFile(filename, files, this.state.counts, filters);
            } else if (entry.isDirectory()) {
                let path = joinDirectoryPath(entry.name, directoryPath, this.state.options.pathSeparator);
                if (exclude && exclude(entry.name, path)) continue;
                this.pushDirectory(path, paths, filters);
                this.walkDirectory(this.state, path, path, depth - 1, this.walk);
            } else if (this.resolveSymlink && entry.isSymbolicLink()) {
                let path = joinPathWithBasePath(entry.name, directoryPath);
                this.resolveSymlink(path, this.state, (stat, resolvedPath)=>{
                    if (stat.isDirectory()) {
                        resolvedPath = normalizePath(resolvedPath, this.state.options);
                        if (exclude && exclude(entry.name, useRealPaths ? resolvedPath : path + pathSeparator)) return;
                        this.walkDirectory(this.state, resolvedPath, useRealPaths ? resolvedPath : path + pathSeparator, depth - 1, this.walk);
                    } else {
                        resolvedPath = useRealPaths ? resolvedPath : path;
                        const filename = (0, external_node_path_.basename)(resolvedPath);
                        const directoryPath$1 = normalizePath((0, external_node_path_.dirname)(resolvedPath), this.state.options);
                        resolvedPath = this.joinPath(filename, directoryPath$1);
                        this.pushFile(resolvedPath, files, this.state.counts, filters);
                    }
                });
            }
        }
        this.groupFiles(this.state.groups, directoryPath, files);
    };
};
function promise(root, options) {
    return new Promise((resolve$1, reject)=>{
        callback(root, options, (err, output)=>{
            if (err) return reject(err);
            resolve$1(output);
        });
    });
}
function callback(root, options, callback$1) {
    let walker = new Walker(root, options, callback$1);
    walker.start();
}
function sync(root, options) {
    const walker = new Walker(root, options);
    return walker.start();
}
var APIBuilder = class {
    constructor(root, options){
        this.root = root;
        this.options = options;
    }
    withPromise() {
        return promise(this.root, this.options);
    }
    withCallback(cb) {
        callback(this.root, this.options, cb);
    }
    sync() {
        return sync(this.root, this.options);
    }
};
let pm = null;
try {
    __require.resolve("picomatch");
    pm = __require("picomatch");
} catch  {}
var Builder = class {
    globCache = {};
    options = {
        maxDepth: 1 / 0,
        suppressErrors: true,
        pathSeparator: external_node_path_.sep,
        filters: []
    };
    globFunction;
    constructor(options){
        this.options = {
            ...this.options,
            ...options
        };
        this.globFunction = this.options.globFunction;
    }
    group() {
        this.options.group = true;
        return this;
    }
    withPathSeparator(separator) {
        this.options.pathSeparator = separator;
        return this;
    }
    withBasePath() {
        this.options.includeBasePath = true;
        return this;
    }
    withRelativePaths() {
        this.options.relativePaths = true;
        return this;
    }
    withDirs() {
        this.options.includeDirs = true;
        return this;
    }
    withMaxDepth(depth) {
        this.options.maxDepth = depth;
        return this;
    }
    withMaxFiles(limit) {
        this.options.maxFiles = limit;
        return this;
    }
    withFullPaths() {
        this.options.resolvePaths = true;
        this.options.includeBasePath = true;
        return this;
    }
    withErrors() {
        this.options.suppressErrors = false;
        return this;
    }
    withSymlinks({ resolvePaths = true } = {}) {
        this.options.resolveSymlinks = true;
        this.options.useRealPaths = resolvePaths;
        return this.withFullPaths();
    }
    withAbortSignal(signal) {
        this.options.signal = signal;
        return this;
    }
    normalize() {
        this.options.normalizePath = true;
        return this;
    }
    filter(predicate) {
        this.options.filters.push(predicate);
        return this;
    }
    onlyDirs() {
        this.options.excludeFiles = true;
        this.options.includeDirs = true;
        return this;
    }
    exclude(predicate) {
        this.options.exclude = predicate;
        return this;
    }
    onlyCounts() {
        this.options.onlyCounts = true;
        return this;
    }
    crawl(root) {
        return new APIBuilder(root || ".", this.options);
    }
    withGlobFunction(fn) {
        this.globFunction = fn;
        return this;
    }
    crawlWithOptions(root, options) {
        this.options = {
            ...this.options,
            ...options
        };
        return new APIBuilder(root || ".", this.options);
    }
    glob(...patterns) {
        if (this.globFunction) return this.globWithOptions(patterns);
        return this.globWithOptions(patterns, {
            dot: true
        });
    }
    globWithOptions(patterns, ...options) {
        const globFn = this.globFunction || pm;
        if (!globFn) throw new Error("Please specify a glob function to use glob matching.");
        var isMatch = this.globCache[patterns.join("\0")];
        if (!isMatch) {
            isMatch = globFn(patterns, ...options);
            this.globCache[patterns.join("\0")] = isMatch;
        }
        this.options.filters.push((path)=>isMatch(path));
        return this;
    }
};
const isReadonlyArray = Array.isArray;
const isWin = "win32" === process.platform;
const ONLY_PARENT_DIRECTORIES = /^(\/?\.\.)+$/;
function getPartialMatcher(patterns, options = {}) {
    const patternsCount = patterns.length;
    const patternsParts = Array(patternsCount);
    const matchers = Array(patternsCount);
    const globstarEnabled = !options.noglobstar;
    for(let i = 0; i < patternsCount; i++){
        const parts = splitPattern(patterns[i]);
        patternsParts[i] = parts;
        const partsCount = parts.length;
        const partMatchers = Array(partsCount);
        for(let j = 0; j < partsCount; j++)partMatchers[j] = picomatch(parts[j], options);
        matchers[i] = partMatchers;
    }
    return (input)=>{
        const inputParts = input.split("/");
        if (".." === inputParts[0] && ONLY_PARENT_DIRECTORIES.test(input)) return true;
        for(let i = 0; i < patterns.length; i++){
            const patternParts = patternsParts[i];
            const matcher = matchers[i];
            const inputPatternCount = inputParts.length;
            const minParts = Math.min(inputPatternCount, patternParts.length);
            let j = 0;
            while(j < minParts){
                const part = patternParts[j];
                if (part.includes("/")) return true;
                const match = matcher[j](inputParts[j]);
                if (!match) break;
                if (globstarEnabled && "**" === part) return true;
                j++;
            }
            if (j === inputPatternCount) return true;
        }
        return false;
    };
}
const WIN32_ROOT_DIR = /^[A-Z]:\/$/i;
const isRoot = isWin ? (p)=>WIN32_ROOT_DIR.test(p) : (p)=>"/" === p;
function buildFormat(cwd, root, absolute) {
    if (cwd === root || root.startsWith(`${cwd}/`)) {
        if (absolute) {
            const start = isRoot(cwd) ? cwd.length : cwd.length + 1;
            return (p, isDir)=>p.slice(start, isDir ? -1 : void 0) || ".";
        }
        const prefix = root.slice(cwd.length + 1);
        if (prefix) return (p, isDir)=>{
            if ("." === p) return prefix;
            const result = `${prefix}/${p}`;
            return isDir ? result.slice(0, -1) : result;
        };
        return (p, isDir)=>isDir && "." !== p ? p.slice(0, -1) : p;
    }
    if (absolute) return (p)=>external_node_path_.posix.relative(cwd, p) || ".";
    return (p)=>external_node_path_.posix.relative(cwd, `${root}/${p}`) || ".";
}
function buildRelative(cwd, root) {
    if (root.startsWith(`${cwd}/`)) {
        const prefix = root.slice(cwd.length + 1);
        return (p)=>`${prefix}/${p}`;
    }
    return (p)=>{
        const result = external_node_path_.posix.relative(cwd, `${root}/${p}`);
        if (p.endsWith("/") && "" !== result) return `${result}/`;
        return result || ".";
    };
}
const splitPatternOptions = {
    parts: true
};
function splitPattern(path$1) {
    var _result$parts;
    const result = picomatch.scan(path$1, splitPatternOptions);
    return (null == (_result$parts = result.parts) ? void 0 : _result$parts.length) ? result.parts : [
        path$1
    ];
}
const POSIX_UNESCAPED_GLOB_SYMBOLS = /(?<!\\)([()[\]{}*?|]|^!|[!+@](?=\()|\\(?![()[\]{}!*+?@|]))/g;
const WIN32_UNESCAPED_GLOB_SYMBOLS = /(?<!\\)([()[\]{}]|^!|[!+@](?=\())/g;
const escapePosixPath = (path$1)=>path$1.replace(POSIX_UNESCAPED_GLOB_SYMBOLS, "\\$&");
const escapeWin32Path = (path$1)=>path$1.replace(WIN32_UNESCAPED_GLOB_SYMBOLS, "\\$&");
const escapePath = isWin ? escapeWin32Path : escapePosixPath;
function isDynamicPattern(pattern, options) {
    if ((null == options ? void 0 : options.caseSensitiveMatch) === false) return true;
    const scan = picomatch.scan(pattern);
    return scan.isGlob || scan.negated;
}
function log(...tasks) {
    console.log(`[tinyglobby ${/* @__PURE__ */ new Date().toLocaleTimeString("es")}]`, ...tasks);
}
const PARENT_DIRECTORY = /^(\/?\.\.)+/;
const ESCAPING_BACKSLASHES = /\\(?=[()[\]{}!*+?@|])/g;
const BACKSLASHES = /\\/g;
function normalizePattern(pattern, expandDirectories, cwd, props, isIgnore) {
    let result = pattern;
    if (pattern.endsWith("/")) result = pattern.slice(0, -1);
    if (!result.endsWith("*") && expandDirectories) result += "/**";
    const escapedCwd = escapePath(cwd);
    result = external_node_path_["default"].isAbsolute(result.replace(ESCAPING_BACKSLASHES, "")) ? external_node_path_.posix.relative(escapedCwd, result) : external_node_path_.posix.normalize(result);
    const parentDirectoryMatch = PARENT_DIRECTORY.exec(result);
    const parts = splitPattern(result);
    if (null == parentDirectoryMatch ? void 0 : parentDirectoryMatch[0]) {
        const n = (parentDirectoryMatch[0].length + 1) / 3;
        let i = 0;
        const cwdParts = escapedCwd.split("/");
        while(i < n && parts[i + n] === cwdParts[cwdParts.length + i - n]){
            result = result.slice(0, (n - i - 1) * 3) + result.slice((n - i) * 3 + parts[i + n].length + 1) || ".";
            i++;
        }
        const potentialRoot = external_node_path_.posix.join(cwd, parentDirectoryMatch[0].slice(3 * i));
        if (!potentialRoot.startsWith(".") && props.root.length > potentialRoot.length) {
            props.root = potentialRoot;
            props.depthOffset = -n + i;
        }
    }
    if (!isIgnore && props.depthOffset >= 0) {
        null != props.commonPath || (props.commonPath = parts);
        const newCommonPath = [];
        const length = Math.min(props.commonPath.length, parts.length);
        for(let i = 0; i < length; i++){
            const part = parts[i];
            if ("**" === part && !parts[i + 1]) {
                newCommonPath.pop();
                break;
            }
            if (part !== props.commonPath[i] || isDynamicPattern(part) || i === parts.length - 1) break;
            newCommonPath.push(part);
        }
        props.depthOffset = newCommonPath.length;
        props.commonPath = newCommonPath;
        props.root = newCommonPath.length > 0 ? external_node_path_.posix.join(cwd, ...newCommonPath) : cwd;
    }
    return result;
}
function processPatterns({ patterns = [
    "**/*"
], ignore = [], expandDirectories = true }, cwd, props) {
    if ("string" == typeof patterns) patterns = [
        patterns
    ];
    if ("string" == typeof ignore) ignore = [
        ignore
    ];
    const matchPatterns = [];
    const ignorePatterns = [];
    for (const pattern of ignore)if (pattern) {
        if ("!" !== pattern[0] || "(" === pattern[1]) ignorePatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, true));
    }
    for (const pattern of patterns)if (pattern) {
        if ("!" !== pattern[0] || "(" === pattern[1]) matchPatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, false));
        else if ("!" !== pattern[1] || "(" === pattern[2]) ignorePatterns.push(normalizePattern(pattern.slice(1), expandDirectories, cwd, props, true));
    }
    return {
        match: matchPatterns,
        ignore: ignorePatterns
    };
}
function formatPaths(paths, relative) {
    for(let i = paths.length - 1; i >= 0; i--){
        const path$1 = paths[i];
        paths[i] = relative(path$1);
    }
    return paths;
}
function normalizeCwd(cwd) {
    if (!cwd) return process.cwd().replace(BACKSLASHES, "/");
    if (cwd instanceof URL) return fileURLToPath(cwd).replace(BACKSLASHES, "/");
    return external_node_path_["default"].resolve(cwd).replace(BACKSLASHES, "/");
}
function getCrawler(patterns, inputOptions = {}) {
    const options = process.env.TINYGLOBBY_DEBUG ? {
        ...inputOptions,
        debug: true
    } : inputOptions;
    const cwd = normalizeCwd(options.cwd);
    if (options.debug) log("globbing with:", {
        patterns,
        options,
        cwd
    });
    if (Array.isArray(patterns) && 0 === patterns.length) return [
        {
            sync: ()=>[],
            withPromise: async ()=>[]
        },
        false
    ];
    const props = {
        root: cwd,
        commonPath: null,
        depthOffset: 0
    };
    const processed = processPatterns({
        ...options,
        patterns
    }, cwd, props);
    if (options.debug) log("internal processing patterns:", processed);
    const matchOptions = {
        dot: options.dot,
        nobrace: false === options.braceExpansion,
        nocase: false === options.caseSensitiveMatch,
        noextglob: false === options.extglob,
        noglobstar: false === options.globstar,
        posix: true
    };
    const matcher = picomatch(processed.match, {
        ...matchOptions,
        ignore: processed.ignore
    });
    const ignore = picomatch(processed.ignore, matchOptions);
    const partialMatcher = getPartialMatcher(processed.match, matchOptions);
    const format = buildFormat(cwd, props.root, options.absolute);
    const formatExclude = options.absolute ? format : buildFormat(cwd, props.root, true);
    const fdirOptions = {
        filters: [
            options.debug ? (p, isDirectory)=>{
                const path$1 = format(p, isDirectory);
                const matches = matcher(path$1);
                if (matches) log(`matched ${path$1}`);
                return matches;
            } : (p, isDirectory)=>matcher(format(p, isDirectory))
        ],
        exclude: options.debug ? (_, p)=>{
            const relativePath = formatExclude(p, true);
            const skipped = "." !== relativePath && !partialMatcher(relativePath) || ignore(relativePath);
            skipped ? log(`skipped ${p}`) : log(`crawling ${p}`);
            return skipped;
        } : (_, p)=>{
            const relativePath = formatExclude(p, true);
            return "." !== relativePath && !partialMatcher(relativePath) || ignore(relativePath);
        },
        fs: options.fs ? {
            readdir: options.fs.readdir || external_node_fs_["default"].readdir,
            readdirSync: options.fs.readdirSync || external_node_fs_["default"].readdirSync,
            realpath: options.fs.realpath || external_node_fs_["default"].realpath,
            realpathSync: options.fs.realpathSync || external_node_fs_["default"].realpathSync,
            stat: options.fs.stat || external_node_fs_["default"].stat,
            statSync: options.fs.statSync || external_node_fs_["default"].statSync
        } : void 0,
        pathSeparator: "/",
        relativePaths: true,
        resolveSymlinks: true,
        signal: options.signal
    };
    if (void 0 !== options.deep) fdirOptions.maxDepth = Math.round(options.deep - props.depthOffset);
    if (options.absolute) {
        fdirOptions.relativePaths = false;
        fdirOptions.resolvePaths = true;
        fdirOptions.includeBasePath = true;
    }
    if (false === options.followSymbolicLinks) {
        fdirOptions.resolveSymlinks = false;
        fdirOptions.excludeSymlinks = true;
    }
    if (options.onlyDirectories) {
        fdirOptions.excludeFiles = true;
        fdirOptions.includeDirs = true;
    } else if (false === options.onlyFiles) fdirOptions.includeDirs = true;
    props.root = props.root.replace(BACKSLASHES, "");
    const root = props.root;
    if (options.debug) log("internal properties:", props);
    const relative = cwd !== root && !options.absolute && buildRelative(cwd, props.root);
    return [
        new Builder(fdirOptions).crawl(root),
        relative
    ];
}
async function glob(patternsOrOptions, options) {
    if (patternsOrOptions && (null == options ? void 0 : options.patterns)) throw new Error("Cannot pass patterns as both an argument and an option");
    const isModern = isReadonlyArray(patternsOrOptions) || "string" == typeof patternsOrOptions;
    const opts = isModern ? options : patternsOrOptions;
    const patterns = isModern ? patternsOrOptions : patternsOrOptions.patterns;
    const [crawler, relative] = getCrawler(patterns, opts);
    if (!relative) return crawler.withPromise();
    return formatPaths(await crawler.withPromise(), relative);
}
const DEFAULT_CONFIG_NAME = 'rstest.config';
const ROOT_SUITE_NAME = 'Rstest:_internal_root_suite';
const TEMP_RSTEST_OUTPUT_DIR = 'dist/.rstest-temp';
const TEMP_RSTEST_OUTPUT_DIR_GLOB = '**/dist/.rstest-temp';
const DEFAULT_CONFIG_EXTENSIONS = [
    '.js',
    '.ts',
    '.mjs',
    '.mts',
    '.cjs',
    '.cts'
];
const globalApis = [
    'test',
    'describe',
    'it',
    'expect',
    'afterAll',
    'afterEach',
    'beforeAll',
    'beforeEach',
    'rstest',
    'rs',
    'assert',
    'onTestFinished',
    'onTestFailed'
];
const TS_CONFIG_FILE = 'tsconfig.json';
const filterFiles = (testFiles, filters, dir)=>{
    if (!filters.length) return testFiles;
    const fileFilters = 'win32' === process.platform ? filters.map((f)=>f.split(posix.sep).join('/')) : filters;
    return testFiles.filter((t)=>{
        const testFile = posix.relative(dir, t).toLocaleLowerCase();
        return fileFilters.some((f)=>{
            if (posix.isAbsolute(f) && t.startsWith(f)) return true;
            const relativePath = f.endsWith('/') ? posix.join(posix.relative(dir, f), '/') : posix.relative(dir, f);
            return testFile.includes(f.toLocaleLowerCase()) || testFile.includes(relativePath.toLocaleLowerCase());
        });
    });
};
const filterProjects = (projects, options)=>{
    if (options.project) {
        const regexes = castArray(options.project).map((pattern)=>{
            const isNeg = pattern.startsWith('!');
            const escaped = (isNeg ? pattern.slice(1) : pattern).split('*').map((part)=>part.replace(/[.+?^${}()|[\]\\]/g, '\\$&')).join('.*');
            return new RegExp(isNeg ? `^(?!${escaped})` : `^${escaped}$`);
        });
        return projects.filter((proj)=>regexes.some((re)=>re.test(proj.config.name)));
    }
    return projects;
};
const hasInSourceTestCode = (code)=>code.includes('import.meta.rstest');
const formatTestEntryName = (name)=>name.replace(/\.*[/\\]/g, '_').replace(/\./g, '~');
const getTestEntries = async ({ include, exclude, rootPath, projectRoot, fileFilters, includeSource })=>{
    const testFiles = await glob(include, {
        cwd: projectRoot,
        absolute: true,
        ignore: exclude,
        dot: true,
        expandDirectories: false
    });
    if (includeSource?.length) {
        const sourceFiles = await glob(includeSource, {
            cwd: projectRoot,
            absolute: true,
            ignore: exclude,
            dot: true,
            expandDirectories: false
        });
        await Promise.all(sourceFiles.map(async (file)=>{
            try {
                const code = await promises.readFile(file, 'utf-8');
                if (hasInSourceTestCode(code)) testFiles.push(file);
            } catch  {
                return;
            }
        }));
    }
    return Object.fromEntries(filterFiles(testFiles, fileFilters, rootPath).map((entry)=>{
        const relativePath = posix.relative(rootPath, entry);
        return [
            formatTestEntryName(relativePath),
            entry
        ];
    }));
};
const tryResolve = (request, rootPath)=>{
    try {
        const require = external_node_module_createRequire(rootPath);
        return require.resolve(request, {
            paths: [
                rootPath
            ]
        });
    } catch (_err) {
        return;
    }
};
const getSetupFiles = (setups, rootPath)=>{
    if (!setups.length) return {};
    return Object.fromEntries(setups.map((setupFile)=>{
        const setupFilePath = getAbsolutePath(rootPath, setupFile);
        try {
            if (!(0, external_node_fs_.existsSync)(setupFilePath)) {
                let errorMessage = `Setup file ${picocolors_default().red(setupFile)} not found`;
                if (setupFilePath !== setupFile) errorMessage += picocolors_default().gray(` (resolved path: ${setupFilePath})`);
                throw errorMessage;
            }
            const relativePath = posix.relative(rootPath, setupFilePath);
            return [
                formatTestEntryName(relativePath),
                setupFilePath
            ];
        } catch (err) {
            const resolvedPath = tryResolve(setupFile, rootPath);
            if (resolvedPath) return [
                formatTestEntryName(setupFile),
                resolvedPath
            ];
            throw err;
        }
    }));
};
const prettyTestPath = (testPath)=>{
    const { dir, base } = parsePosix(testPath);
    return `${'.' !== dir ? picocolors_default().gray(`${dir}/`) : ''}${picocolors_default().cyan(base)}`;
};
const formatTestPath = (root, testFilePath)=>{
    let testPath = testFilePath;
    if (posix.isAbsolute(testPath) && testPath.includes(root)) testPath = posix.relative(root, testPath);
    return prettyTestPath(testPath);
};
const picomatch = __webpack_require__("../../node_modules/.pnpm/picomatch@4.0.3/node_modules/picomatch/index.js");
export { ADDITIONAL_NODE_BUILTINS, DEFAULT_CONFIG_EXTENSIONS, DEFAULT_CONFIG_NAME, ROOT_SUITE_NAME, TEMP_RSTEST_OUTPUT_DIR, TEMP_RSTEST_OUTPUT_DIR_GLOB, TS_CONFIG_FILE, bgColor, castArray, filterProjects, formatError, formatRootStr, formatTestPath, getAbsolutePath, getSetupFiles, getTaskNameWithPrefix, getTestEntries, glob, globalApis, isDynamicPattern, isObject, isTTY, lstat, needFlagExperimentalDetectModule, prettyTestPath, prettyTime, promises_stat, readdir, realpath, serializableConfig, undoSerializableConfig, writeFile };
