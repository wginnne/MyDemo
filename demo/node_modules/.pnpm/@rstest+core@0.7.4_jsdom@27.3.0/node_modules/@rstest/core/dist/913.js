/*! For license information please see 913.js.LICENSE.txt */
import 'module';
/*#__PURE__*/ import.meta.url;
import { __webpack_require__ } from "./rslib-runtime.js";
import { createRequire } from "./664.js";
__webpack_require__.add({
    "../../node_modules/.pnpm/@jest+diff-sequences@30.0.1/node_modules/@jest/diff-sequences/build/index.js" (module) {
        /*!
 * /**
 *  * Copyright (c) Meta Platforms, Inc. and affiliates.
 *  *
 *  * This source code is licensed under the MIT license found in the
 *  * LICENSE file in the root directory of this source tree.
 *  * /
 */ (()=>{
            "use strict";
            var __nested_rspack_exports__ = {};
            (()=>{
                var exports = __nested_rspack_exports__;
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports["default"] = diffSequence;
                const pkg = '@jest/diff-sequences';
                const NOT_YET_SET = 0;
                const countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon)=>{
                    let nCommon = 0;
                    while(aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)){
                        aIndex += 1;
                        bIndex += 1;
                        nCommon += 1;
                    }
                    return nCommon;
                };
                const countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon)=>{
                    let nCommon = 0;
                    while(aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)){
                        aIndex -= 1;
                        bIndex -= 1;
                        nCommon += 1;
                    }
                    return nCommon;
                };
                const extendPathsF = (d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF)=>{
                    let iF = 0;
                    let kF = -d;
                    let aFirst = aIndexesF[iF];
                    let aIndexPrev1 = aFirst;
                    aIndexesF[iF] += countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
                    const nF = Math.min(d, iMaxF);
                    for(iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2){
                        if (iF !== d && aIndexPrev1 < aIndexesF[iF]) aFirst = aIndexesF[iF];
                        else {
                            aFirst = aIndexPrev1 + 1;
                            if (aEnd <= aFirst) return iF - 1;
                        }
                        aIndexPrev1 = aIndexesF[iF];
                        aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
                    }
                    return iMaxF;
                };
                const extendPathsR = (d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR)=>{
                    let iR = 0;
                    let kR = d;
                    let aFirst = aIndexesR[iR];
                    let aIndexPrev1 = aFirst;
                    aIndexesR[iR] -= countCommonItemsR(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon);
                    const nR = Math.min(d, iMaxR);
                    for(iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2){
                        if (iR !== d && aIndexesR[iR] < aIndexPrev1) aFirst = aIndexesR[iR];
                        else {
                            aFirst = aIndexPrev1 - 1;
                            if (aFirst < aStart) return iR - 1;
                        }
                        aIndexPrev1 = aIndexesR[iR];
                        aIndexesR[iR] = aFirst - countCommonItemsR(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon);
                    }
                    return iMaxR;
                };
                const extendOverlappablePathsF = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)=>{
                    const bF = bStart - aStart;
                    const aLength = aEnd - aStart;
                    const bLength = bEnd - bStart;
                    const baDeltaLength = bLength - aLength;
                    const kMinOverlapF = -baDeltaLength - (d - 1);
                    const kMaxOverlapF = -baDeltaLength + (d - 1);
                    let aIndexPrev1 = NOT_YET_SET;
                    const nF = Math.min(d, iMaxF);
                    for(let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2){
                        const insert = 0 === iF || iF !== d && aIndexPrev1 < aIndexesF[iF];
                        const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;
                        const aFirst = insert ? aLastPrev : aLastPrev + 1;
                        const bFirst = bF + aFirst - kF;
                        const nCommonF = countCommonItemsF(aFirst + 1, aEnd, bFirst + 1, bEnd, isCommon);
                        const aLast = aFirst + nCommonF;
                        aIndexPrev1 = aIndexesF[iF];
                        aIndexesF[iF] = aLast;
                        if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {
                            const iR = (d - 1 - (kF + baDeltaLength)) / 2;
                            if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
                                const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1);
                                const nCommonR = countCommonItemsR(aStart, aLastPrev, bStart, bLastPrev, isCommon);
                                const aIndexPrevFirst = aLastPrev - nCommonR;
                                const bIndexPrevFirst = bLastPrev - nCommonR;
                                const aEndPreceding = aIndexPrevFirst + 1;
                                const bEndPreceding = bIndexPrevFirst + 1;
                                division.nChangePreceding = d - 1;
                                if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {
                                    division.aEndPreceding = aStart;
                                    division.bEndPreceding = bStart;
                                } else {
                                    division.aEndPreceding = aEndPreceding;
                                    division.bEndPreceding = bEndPreceding;
                                }
                                division.nCommonPreceding = nCommonR;
                                if (0 !== nCommonR) {
                                    division.aCommonPreceding = aEndPreceding;
                                    division.bCommonPreceding = bEndPreceding;
                                }
                                division.nCommonFollowing = nCommonF;
                                if (0 !== nCommonF) {
                                    division.aCommonFollowing = aFirst + 1;
                                    division.bCommonFollowing = bFirst + 1;
                                }
                                const aStartFollowing = aLast + 1;
                                const bStartFollowing = bFirst + nCommonF + 1;
                                division.nChangeFollowing = d - 1;
                                if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
                                    division.aStartFollowing = aEnd;
                                    division.bStartFollowing = bEnd;
                                } else {
                                    division.aStartFollowing = aStartFollowing;
                                    division.bStartFollowing = bStartFollowing;
                                }
                                return true;
                            }
                        }
                    }
                    return false;
                };
                const extendOverlappablePathsR = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)=>{
                    const bR = bEnd - aEnd;
                    const aLength = aEnd - aStart;
                    const bLength = bEnd - bStart;
                    const baDeltaLength = bLength - aLength;
                    const kMinOverlapR = baDeltaLength - d;
                    const kMaxOverlapR = baDeltaLength + d;
                    let aIndexPrev1 = NOT_YET_SET;
                    const nR = Math.min(d, iMaxR);
                    for(let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2){
                        const insert = 0 === iR || iR !== d && aIndexesR[iR] < aIndexPrev1;
                        const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;
                        const aFirst = insert ? aLastPrev : aLastPrev - 1;
                        const bFirst = bR + aFirst - kR;
                        const nCommonR = countCommonItemsR(aStart, aFirst - 1, bStart, bFirst - 1, isCommon);
                        const aLast = aFirst - nCommonR;
                        aIndexPrev1 = aIndexesR[iR];
                        aIndexesR[iR] = aLast;
                        if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {
                            const iF = (d + (kR - baDeltaLength)) / 2;
                            if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
                                const bLast = bFirst - nCommonR;
                                division.nChangePreceding = d;
                                if (d === aLast + bLast - aStart - bStart) {
                                    division.aEndPreceding = aStart;
                                    division.bEndPreceding = bStart;
                                } else {
                                    division.aEndPreceding = aLast;
                                    division.bEndPreceding = bLast;
                                }
                                division.nCommonPreceding = nCommonR;
                                if (0 !== nCommonR) {
                                    division.aCommonPreceding = aLast;
                                    division.bCommonPreceding = bLast;
                                }
                                division.nChangeFollowing = d - 1;
                                if (1 === d) {
                                    division.nCommonFollowing = 0;
                                    division.aStartFollowing = aEnd;
                                    division.bStartFollowing = bEnd;
                                } else {
                                    const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1);
                                    const nCommonF = countCommonItemsF(aLastPrev, aEnd, bLastPrev, bEnd, isCommon);
                                    division.nCommonFollowing = nCommonF;
                                    if (0 !== nCommonF) {
                                        division.aCommonFollowing = aLastPrev;
                                        division.bCommonFollowing = bLastPrev;
                                    }
                                    const aStartFollowing = aLastPrev + nCommonF;
                                    const bStartFollowing = bLastPrev + nCommonF;
                                    if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
                                        division.aStartFollowing = aEnd;
                                        division.bStartFollowing = bEnd;
                                    } else {
                                        division.aStartFollowing = aStartFollowing;
                                        division.bStartFollowing = bStartFollowing;
                                    }
                                }
                                return true;
                            }
                        }
                    }
                    return false;
                };
                const divide = (nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division)=>{
                    const bF = bStart - aStart;
                    const bR = bEnd - aEnd;
                    const aLength = aEnd - aStart;
                    const bLength = bEnd - bStart;
                    const baDeltaLength = bLength - aLength;
                    let iMaxF = aLength;
                    let iMaxR = aLength;
                    aIndexesF[0] = aStart - 1;
                    aIndexesR[0] = aEnd;
                    if (baDeltaLength % 2 === 0) {
                        const dMin = (nChange || baDeltaLength) / 2;
                        const dMax = (aLength + bLength) / 2;
                        for(let d = 1; d <= dMax; d += 1){
                            iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
                            if (d < dMin) iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
                            else if (extendOverlappablePathsR(d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)) return;
                        }
                    } else {
                        const dMin = ((nChange || baDeltaLength) + 1) / 2;
                        const dMax = (aLength + bLength + 1) / 2;
                        let d = 1;
                        iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
                        for(d += 1; d <= dMax; d += 1){
                            iMaxR = extendPathsR(d - 1, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
                            if (d < dMin) iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
                            else if (extendOverlappablePathsF(d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)) return;
                        }
                    }
                    throw new Error(`${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`);
                };
                const findSubsequences = (nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division)=>{
                    if (bEnd - bStart < aEnd - aStart) {
                        transposed = !transposed;
                        if (transposed && 1 === callbacks.length) {
                            const { foundSubsequence, isCommon } = callbacks[0];
                            callbacks[1] = {
                                foundSubsequence: (nCommon, bCommon, aCommon)=>{
                                    foundSubsequence(nCommon, aCommon, bCommon);
                                },
                                isCommon: (bIndex, aIndex)=>isCommon(aIndex, bIndex)
                            };
                        }
                        const tStart = aStart;
                        const tEnd = aEnd;
                        aStart = bStart;
                        aEnd = bEnd;
                        bStart = tStart;
                        bEnd = tEnd;
                    }
                    const { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];
                    divide(nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division);
                    const { nChangePreceding, aEndPreceding, bEndPreceding, nCommonPreceding, aCommonPreceding, bCommonPreceding, nCommonFollowing, aCommonFollowing, bCommonFollowing, nChangeFollowing, aStartFollowing, bStartFollowing } = division;
                    if (aStart < aEndPreceding && bStart < bEndPreceding) findSubsequences(nChangePreceding, aStart, aEndPreceding, bStart, bEndPreceding, transposed, callbacks, aIndexesF, aIndexesR, division);
                    if (0 !== nCommonPreceding) foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);
                    if (0 !== nCommonFollowing) foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);
                    if (aStartFollowing < aEnd && bStartFollowing < bEnd) findSubsequences(nChangeFollowing, aStartFollowing, aEnd, bStartFollowing, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division);
                };
                const validateLength = (name, arg)=>{
                    if ('number' != typeof arg) throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);
                    if (!Number.isSafeInteger(arg)) throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);
                    if (arg < 0) throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);
                };
                const validateCallback = (name, arg)=>{
                    const type = typeof arg;
                    if ('function' !== type) throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);
                };
                function diffSequence(aLength, bLength, isCommon, foundSubsequence) {
                    validateLength('aLength', aLength);
                    validateLength('bLength', bLength);
                    validateCallback('isCommon', isCommon);
                    validateCallback('foundSubsequence', foundSubsequence);
                    const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);
                    if (0 !== nCommonF) foundSubsequence(nCommonF, 0, 0);
                    if (aLength !== nCommonF || bLength !== nCommonF) {
                        const aStart = nCommonF;
                        const bStart = nCommonF;
                        const nCommonR = countCommonItemsR(aStart, aLength - 1, bStart, bLength - 1, isCommon);
                        const aEnd = aLength - nCommonR;
                        const bEnd = bLength - nCommonR;
                        const nCommonFR = nCommonF + nCommonR;
                        if (aLength !== nCommonFR && bLength !== nCommonFR) {
                            const nChange = 0;
                            const transposed = false;
                            const callbacks = [
                                {
                                    foundSubsequence,
                                    isCommon
                                }
                            ];
                            const aIndexesF = [
                                NOT_YET_SET
                            ];
                            const aIndexesR = [
                                NOT_YET_SET
                            ];
                            const division = {
                                aCommonFollowing: NOT_YET_SET,
                                aCommonPreceding: NOT_YET_SET,
                                aEndPreceding: NOT_YET_SET,
                                aStartFollowing: NOT_YET_SET,
                                bCommonFollowing: NOT_YET_SET,
                                bCommonPreceding: NOT_YET_SET,
                                bEndPreceding: NOT_YET_SET,
                                bStartFollowing: NOT_YET_SET,
                                nChangeFollowing: NOT_YET_SET,
                                nChangePreceding: NOT_YET_SET,
                                nCommonFollowing: NOT_YET_SET,
                                nCommonPreceding: NOT_YET_SET
                            };
                            findSubsequences(nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division);
                        }
                        if (0 !== nCommonR) foundSubsequence(nCommonR, aEnd, bEnd);
                    }
                }
            })();
            module.exports = __nested_rspack_exports__;
        })();
    },
    "../../node_modules/.pnpm/@jest+get-type@30.1.0/node_modules/@jest/get-type/build/index.js" (module) {
        /*!
 * /**
 *  * Copyright (c) Meta Platforms, Inc. and affiliates.
 *  *
 *  * This source code is licensed under the MIT license found in the
 *  * LICENSE file in the root directory of this source tree.
 *  * /
 */ (()=>{
            "use strict";
            var __nested_rspack_exports__ = {};
            (()=>{
                var exports = __nested_rspack_exports__;
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.getType = getType;
                exports.isPrimitive = void 0;
                function getType(value) {
                    if (void 0 === value) return 'undefined';
                    if (null === value) return 'null';
                    if (Array.isArray(value)) return 'array';
                    if ('boolean' == typeof value) return 'boolean';
                    if ('function' == typeof value) return 'function';
                    else if ('number' == typeof value) return 'number';
                    else if ('string' == typeof value) return 'string';
                    else if ('bigint' == typeof value) return 'bigint';
                    else if ('object' == typeof value) {
                        if (value.constructor === RegExp) return 'regexp';
                        if (value.constructor === Map) return 'map';
                        if (value.constructor === Set) return 'set';
                        else if (value.constructor === Date) return 'date';
                        return 'object';
                    } else if ('symbol' == typeof value) return 'symbol';
                    throw new Error(`value of unknown type: ${value}`);
                }
                const isPrimitive = (value)=>Object(value) !== value;
                exports.isPrimitive = isPrimitive;
            })();
            module.exports = __nested_rspack_exports__;
        })();
    },
    "../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        module = __webpack_require__.nmd(module);
        const wrapAnsi16 = (fn, offset)=>(...args)=>{
                const code = fn(...args);
                return `\u001B[${code + offset}m`;
            };
        const wrapAnsi256 = (fn, offset)=>(...args)=>{
                const code = fn(...args);
                return `\u001B[${38 + offset};5;${code}m`;
            };
        const wrapAnsi16m = (fn, offset)=>(...args)=>{
                const rgb = fn(...args);
                return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
            };
        const ansi2ansi = (n)=>n;
        const rgb2rgb = (r, g, b)=>[
                r,
                g,
                b
            ];
        const setLazyProperty = (object, property, get)=>{
            Object.defineProperty(object, property, {
                get: ()=>{
                    const value = get();
                    Object.defineProperty(object, property, {
                        value,
                        enumerable: true,
                        configurable: true
                    });
                    return value;
                },
                enumerable: true,
                configurable: true
            });
        };
        let colorConvert;
        const makeDynamicStyles = (wrap, targetSpace, identity, isBackground)=>{
            if (void 0 === colorConvert) colorConvert = __webpack_require__("../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js");
            const offset = isBackground ? 10 : 0;
            const styles = {};
            for (const [sourceSpace, suite] of Object.entries(colorConvert)){
                const name = 'ansi16' === sourceSpace ? 'ansi' : sourceSpace;
                if (sourceSpace === targetSpace) styles[name] = wrap(identity, offset);
                else if ('object' == typeof suite) styles[name] = wrap(suite[targetSpace], offset);
            }
            return styles;
        };
        function assembleStyles() {
            const codes = new Map();
            const styles = {
                modifier: {
                    reset: [
                        0,
                        0
                    ],
                    bold: [
                        1,
                        22
                    ],
                    dim: [
                        2,
                        22
                    ],
                    italic: [
                        3,
                        23
                    ],
                    underline: [
                        4,
                        24
                    ],
                    inverse: [
                        7,
                        27
                    ],
                    hidden: [
                        8,
                        28
                    ],
                    strikethrough: [
                        9,
                        29
                    ]
                },
                color: {
                    black: [
                        30,
                        39
                    ],
                    red: [
                        31,
                        39
                    ],
                    green: [
                        32,
                        39
                    ],
                    yellow: [
                        33,
                        39
                    ],
                    blue: [
                        34,
                        39
                    ],
                    magenta: [
                        35,
                        39
                    ],
                    cyan: [
                        36,
                        39
                    ],
                    white: [
                        37,
                        39
                    ],
                    blackBright: [
                        90,
                        39
                    ],
                    redBright: [
                        91,
                        39
                    ],
                    greenBright: [
                        92,
                        39
                    ],
                    yellowBright: [
                        93,
                        39
                    ],
                    blueBright: [
                        94,
                        39
                    ],
                    magentaBright: [
                        95,
                        39
                    ],
                    cyanBright: [
                        96,
                        39
                    ],
                    whiteBright: [
                        97,
                        39
                    ]
                },
                bgColor: {
                    bgBlack: [
                        40,
                        49
                    ],
                    bgRed: [
                        41,
                        49
                    ],
                    bgGreen: [
                        42,
                        49
                    ],
                    bgYellow: [
                        43,
                        49
                    ],
                    bgBlue: [
                        44,
                        49
                    ],
                    bgMagenta: [
                        45,
                        49
                    ],
                    bgCyan: [
                        46,
                        49
                    ],
                    bgWhite: [
                        47,
                        49
                    ],
                    bgBlackBright: [
                        100,
                        49
                    ],
                    bgRedBright: [
                        101,
                        49
                    ],
                    bgGreenBright: [
                        102,
                        49
                    ],
                    bgYellowBright: [
                        103,
                        49
                    ],
                    bgBlueBright: [
                        104,
                        49
                    ],
                    bgMagentaBright: [
                        105,
                        49
                    ],
                    bgCyanBright: [
                        106,
                        49
                    ],
                    bgWhiteBright: [
                        107,
                        49
                    ]
                }
            };
            styles.color.gray = styles.color.blackBright;
            styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
            styles.color.grey = styles.color.blackBright;
            styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
            for (const [groupName, group] of Object.entries(styles)){
                for (const [styleName, style] of Object.entries(group)){
                    styles[styleName] = {
                        open: `\u001B[${style[0]}m`,
                        close: `\u001B[${style[1]}m`
                    };
                    group[styleName] = styles[styleName];
                    codes.set(style[0], style[1]);
                }
                Object.defineProperty(styles, groupName, {
                    value: group,
                    enumerable: false
                });
            }
            Object.defineProperty(styles, 'codes', {
                value: codes,
                enumerable: false
            });
            styles.color.close = '\u001B[39m';
            styles.bgColor.close = '\u001B[49m';
            setLazyProperty(styles.color, 'ansi', ()=>makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
            setLazyProperty(styles.color, 'ansi256', ()=>makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
            setLazyProperty(styles.color, 'ansi16m', ()=>makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
            setLazyProperty(styles.bgColor, 'ansi', ()=>makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
            setLazyProperty(styles.bgColor, 'ansi256', ()=>makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
            setLazyProperty(styles.bgColor, 'ansi16m', ()=>makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));
            return styles;
        }
        Object.defineProperty(module, 'exports', {
            enumerable: true,
            get: assembleStyles
        });
    },
    "../../node_modules/.pnpm/ansi-styles@5.2.0/node_modules/ansi-styles/index.js" (module, exports, __webpack_require__) {
        __webpack_require__.r(exports);
        module = __webpack_require__.nmd(module);
        const ANSI_BACKGROUND_OFFSET = 10;
        const wrapAnsi256 = (offset = 0)=>(code)=>`\u001B[${38 + offset};5;${code}m`;
        const wrapAnsi16m = (offset = 0)=>(red, green, blue)=>`\u001B[${38 + offset};2;${red};${green};${blue}m`;
        function assembleStyles() {
            const codes = new Map();
            const styles = {
                modifier: {
                    reset: [
                        0,
                        0
                    ],
                    bold: [
                        1,
                        22
                    ],
                    dim: [
                        2,
                        22
                    ],
                    italic: [
                        3,
                        23
                    ],
                    underline: [
                        4,
                        24
                    ],
                    overline: [
                        53,
                        55
                    ],
                    inverse: [
                        7,
                        27
                    ],
                    hidden: [
                        8,
                        28
                    ],
                    strikethrough: [
                        9,
                        29
                    ]
                },
                color: {
                    black: [
                        30,
                        39
                    ],
                    red: [
                        31,
                        39
                    ],
                    green: [
                        32,
                        39
                    ],
                    yellow: [
                        33,
                        39
                    ],
                    blue: [
                        34,
                        39
                    ],
                    magenta: [
                        35,
                        39
                    ],
                    cyan: [
                        36,
                        39
                    ],
                    white: [
                        37,
                        39
                    ],
                    blackBright: [
                        90,
                        39
                    ],
                    redBright: [
                        91,
                        39
                    ],
                    greenBright: [
                        92,
                        39
                    ],
                    yellowBright: [
                        93,
                        39
                    ],
                    blueBright: [
                        94,
                        39
                    ],
                    magentaBright: [
                        95,
                        39
                    ],
                    cyanBright: [
                        96,
                        39
                    ],
                    whiteBright: [
                        97,
                        39
                    ]
                },
                bgColor: {
                    bgBlack: [
                        40,
                        49
                    ],
                    bgRed: [
                        41,
                        49
                    ],
                    bgGreen: [
                        42,
                        49
                    ],
                    bgYellow: [
                        43,
                        49
                    ],
                    bgBlue: [
                        44,
                        49
                    ],
                    bgMagenta: [
                        45,
                        49
                    ],
                    bgCyan: [
                        46,
                        49
                    ],
                    bgWhite: [
                        47,
                        49
                    ],
                    bgBlackBright: [
                        100,
                        49
                    ],
                    bgRedBright: [
                        101,
                        49
                    ],
                    bgGreenBright: [
                        102,
                        49
                    ],
                    bgYellowBright: [
                        103,
                        49
                    ],
                    bgBlueBright: [
                        104,
                        49
                    ],
                    bgMagentaBright: [
                        105,
                        49
                    ],
                    bgCyanBright: [
                        106,
                        49
                    ],
                    bgWhiteBright: [
                        107,
                        49
                    ]
                }
            };
            styles.color.gray = styles.color.blackBright;
            styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
            styles.color.grey = styles.color.blackBright;
            styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
            for (const [groupName, group] of Object.entries(styles)){
                for (const [styleName, style] of Object.entries(group)){
                    styles[styleName] = {
                        open: `\u001B[${style[0]}m`,
                        close: `\u001B[${style[1]}m`
                    };
                    group[styleName] = styles[styleName];
                    codes.set(style[0], style[1]);
                }
                Object.defineProperty(styles, groupName, {
                    value: group,
                    enumerable: false
                });
            }
            Object.defineProperty(styles, 'codes', {
                value: codes,
                enumerable: false
            });
            styles.color.close = '\u001B[39m';
            styles.bgColor.close = '\u001B[49m';
            styles.color.ansi256 = wrapAnsi256();
            styles.color.ansi16m = wrapAnsi16m();
            styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
            styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
            Object.defineProperties(styles, {
                rgbToAnsi256: {
                    value: (red, green, blue)=>{
                        if (red === green && green === blue) {
                            if (red < 8) return 16;
                            if (red > 248) return 231;
                            return Math.round((red - 8) / 247 * 24) + 232;
                        }
                        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
                    },
                    enumerable: false
                },
                hexToRgb: {
                    value: (hex)=>{
                        const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
                        if (!matches) return [
                            0,
                            0,
                            0
                        ];
                        let { colorString } = matches.groups;
                        if (3 === colorString.length) colorString = colorString.split('').map((character)=>character + character).join('');
                        const integer = Number.parseInt(colorString, 16);
                        return [
                            integer >> 16 & 0xFF,
                            integer >> 8 & 0xFF,
                            0xFF & integer
                        ];
                    },
                    enumerable: false
                },
                hexToAnsi256: {
                    value: (hex)=>styles.rgbToAnsi256(...styles.hexToRgb(hex)),
                    enumerable: false
                }
            });
            return styles;
        }
        Object.defineProperty(module, 'exports', {
            enumerable: true,
            get: assembleStyles
        });
    },
    "../../node_modules/.pnpm/buffer-from@1.1.2/node_modules/buffer-from/index.js" (module) {
        var toString = Object.prototype.toString;
        var isModern = 'undefined' != typeof Buffer && 'function' == typeof Buffer.alloc && 'function' == typeof Buffer.allocUnsafe && 'function' == typeof Buffer.from;
        function isArrayBuffer(input) {
            return 'ArrayBuffer' === toString.call(input).slice(8, -1);
        }
        function fromArrayBuffer(obj, byteOffset, length) {
            byteOffset >>>= 0;
            var maxLength = obj.byteLength - byteOffset;
            if (maxLength < 0) throw new RangeError("'offset' is out of bounds");
            if (void 0 === length) length = maxLength;
            else {
                length >>>= 0;
                if (length > maxLength) throw new RangeError("'length' is out of bounds");
            }
            return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
        }
        function fromString(string, encoding) {
            if ('string' != typeof encoding || '' === encoding) encoding = 'utf8';
            if (!Buffer.isEncoding(encoding)) throw new TypeError('"encoding" must be a valid string encoding');
            return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
        }
        function bufferFrom(value, encodingOrOffset, length) {
            if ('number' == typeof value) throw new TypeError('"value" argument must not be a number');
            if (isArrayBuffer(value)) return fromArrayBuffer(value, encodingOrOffset, length);
            if ('string' == typeof value) return fromString(value, encodingOrOffset);
            return isModern ? Buffer.from(value) : new Buffer(value);
        }
        module.exports = bufferFrom;
    },
    "../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        const ansiStyles = __webpack_require__("../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js");
        const { stdout: stdoutColor, stderr: stderrColor } = __webpack_require__("../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js");
        const { stringReplaceAll, stringEncaseCRLFWithFirstIndex } = __webpack_require__("../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js");
        const { isArray } = Array;
        const levelMapping = [
            'ansi',
            'ansi',
            'ansi256',
            'ansi16m'
        ];
        const styles = Object.create(null);
        const applyOptions = (object, options = {})=>{
            if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) throw new Error('The `level` option should be an integer from 0 to 3');
            const colorLevel = stdoutColor ? stdoutColor.level : 0;
            object.level = void 0 === options.level ? colorLevel : options.level;
        };
        class ChalkClass {
            constructor(options){
                return chalkFactory(options);
            }
        }
        const chalkFactory = (options)=>{
            const chalk = {};
            applyOptions(chalk, options);
            chalk.template = (...arguments_)=>chalkTag(chalk.template, ...arguments_);
            Object.setPrototypeOf(chalk, Chalk.prototype);
            Object.setPrototypeOf(chalk.template, chalk);
            chalk.template.constructor = ()=>{
                throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
            };
            chalk.template.Instance = ChalkClass;
            return chalk.template;
        };
        function Chalk(options) {
            return chalkFactory(options);
        }
        for (const [styleName, style] of Object.entries(ansiStyles))styles[styleName] = {
            get () {
                const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
                Object.defineProperty(this, styleName, {
                    value: builder
                });
                return builder;
            }
        };
        styles.visible = {
            get () {
                const builder = createBuilder(this, this._styler, true);
                Object.defineProperty(this, 'visible', {
                    value: builder
                });
                return builder;
            }
        };
        const usedModels = [
            'rgb',
            'hex',
            'keyword',
            'hsl',
            'hsv',
            'hwb',
            'ansi',
            'ansi256'
        ];
        for (const model of usedModels)styles[model] = {
            get () {
                const { level } = this;
                return function(...arguments_) {
                    const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
                    return createBuilder(this, styler, this._isEmpty);
                };
            }
        };
        for (const model of usedModels){
            const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
            styles[bgModel] = {
                get () {
                    const { level } = this;
                    return function(...arguments_) {
                        const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
                        return createBuilder(this, styler, this._isEmpty);
                    };
                }
            };
        }
        const proto = Object.defineProperties(()=>{}, {
            ...styles,
            level: {
                enumerable: true,
                get () {
                    return this._generator.level;
                },
                set (level) {
                    this._generator.level = level;
                }
            }
        });
        const createStyler = (open, close, parent)=>{
            let openAll;
            let closeAll;
            if (void 0 === parent) {
                openAll = open;
                closeAll = close;
            } else {
                openAll = parent.openAll + open;
                closeAll = close + parent.closeAll;
            }
            return {
                open,
                close,
                openAll,
                closeAll,
                parent
            };
        };
        const createBuilder = (self, _styler, _isEmpty)=>{
            const builder = (...arguments_)=>{
                if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) return applyStyle(builder, chalkTag(builder, ...arguments_));
                return applyStyle(builder, 1 === arguments_.length ? '' + arguments_[0] : arguments_.join(' '));
            };
            Object.setPrototypeOf(builder, proto);
            builder._generator = self;
            builder._styler = _styler;
            builder._isEmpty = _isEmpty;
            return builder;
        };
        const applyStyle = (self, string)=>{
            if (self.level <= 0 || !string) return self._isEmpty ? '' : string;
            let styler = self._styler;
            if (void 0 === styler) return string;
            const { openAll, closeAll } = styler;
            if (-1 !== string.indexOf('\u001B')) while(void 0 !== styler){
                string = stringReplaceAll(string, styler.close, styler.open);
                styler = styler.parent;
            }
            const lfIndex = string.indexOf('\n');
            if (-1 !== lfIndex) string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
            return openAll + string + closeAll;
        };
        let template;
        const chalkTag = (chalk, ...strings)=>{
            const [firstString] = strings;
            if (!isArray(firstString) || !isArray(firstString.raw)) return strings.join(' ');
            const arguments_ = strings.slice(1);
            const parts = [
                firstString.raw[0]
            ];
            for(let i = 1; i < firstString.length; i++)parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'), String(firstString.raw[i]));
            if (void 0 === template) template = __webpack_require__("../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js");
            return template(chalk, parts.join(''));
        };
        Object.defineProperties(Chalk.prototype, styles);
        const chalk = Chalk();
        chalk.supportsColor = stdoutColor;
        chalk.stderr = Chalk({
            level: stderrColor ? stderrColor.level : 0
        });
        chalk.stderr.supportsColor = stderrColor;
        module.exports = chalk;
    },
    "../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js" (module) {
        const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
        const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
        const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
        const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
        const ESCAPES = new Map([
            [
                'n',
                '\n'
            ],
            [
                'r',
                '\r'
            ],
            [
                't',
                '\t'
            ],
            [
                'b',
                '\b'
            ],
            [
                'f',
                '\f'
            ],
            [
                'v',
                '\v'
            ],
            [
                '0',
                '\0'
            ],
            [
                '\\',
                '\\'
            ],
            [
                'e',
                '\u001B'
            ],
            [
                'a',
                '\u0007'
            ]
        ]);
        function unescape(c) {
            const u = 'u' === c[0];
            const bracket = '{' === c[1];
            if (u && !bracket && 5 === c.length || 'x' === c[0] && 3 === c.length) return String.fromCharCode(parseInt(c.slice(1), 16));
            if (u && bracket) return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
            return ESCAPES.get(c) || c;
        }
        function parseArguments(name, arguments_) {
            const results = [];
            const chunks = arguments_.trim().split(/\s*,\s*/g);
            let matches;
            for (const chunk of chunks){
                const number = Number(chunk);
                if (Number.isNaN(number)) if (matches = chunk.match(STRING_REGEX)) results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character)=>escape ? unescape(escape) : character));
                else throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
                else results.push(number);
            }
            return results;
        }
        function parseStyle(style) {
            STYLE_REGEX.lastIndex = 0;
            const results = [];
            let matches;
            while(null !== (matches = STYLE_REGEX.exec(style))){
                const name = matches[1];
                if (matches[2]) {
                    const args = parseArguments(name, matches[2]);
                    results.push([
                        name
                    ].concat(args));
                } else results.push([
                    name
                ]);
            }
            return results;
        }
        function buildStyle(chalk, styles) {
            const enabled = {};
            for (const layer of styles)for (const style of layer.styles)enabled[style[0]] = layer.inverse ? null : style.slice(1);
            let current = chalk;
            for (const [styleName, styles] of Object.entries(enabled))if (Array.isArray(styles)) {
                if (!(styleName in current)) throw new Error(`Unknown Chalk style: ${styleName}`);
                current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
            }
            return current;
        }
        module.exports = (chalk, temporary)=>{
            const styles = [];
            const chunks = [];
            let chunk = [];
            temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character)=>{
                if (escapeCharacter) chunk.push(unescape(escapeCharacter));
                else if (style) {
                    const string = chunk.join('');
                    chunk = [];
                    chunks.push(0 === styles.length ? string : buildStyle(chalk, styles)(string));
                    styles.push({
                        inverse,
                        styles: parseStyle(style)
                    });
                } else if (close) {
                    if (0 === styles.length) throw new Error('Found extraneous } in Chalk template literal');
                    chunks.push(buildStyle(chalk, styles)(chunk.join('')));
                    chunk = [];
                    styles.pop();
                } else chunk.push(character);
            });
            chunks.push(chunk.join(''));
            if (styles.length > 0) {
                const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${1 === styles.length ? '' : 's'} (\`}\`)`;
                throw new Error(errMessage);
            }
            return chunks.join('');
        };
    },
    "../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js" (module) {
        const stringReplaceAll = (string, substring, replacer)=>{
            let index = string.indexOf(substring);
            if (-1 === index) return string;
            const substringLength = substring.length;
            let endIndex = 0;
            let returnValue = '';
            do {
                returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
                endIndex = index + substringLength;
                index = string.indexOf(substring, endIndex);
            }while (-1 !== index);
            returnValue += string.substr(endIndex);
            return returnValue;
        };
        const stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index)=>{
            let endIndex = 0;
            let returnValue = '';
            do {
                const gotCR = '\r' === string[index - 1];
                returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
                endIndex = index + 1;
                index = string.indexOf('\n', endIndex);
            }while (-1 !== index);
            returnValue += string.substr(endIndex);
            return returnValue;
        };
        module.exports = {
            stringReplaceAll,
            stringEncaseCRLFWithFirstIndex
        };
    },
    "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js" (module, __unused_rspack_exports, __webpack_require__) {
        const cssKeywords = __webpack_require__("../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js");
        const reverseKeywords = {};
        for (const key of Object.keys(cssKeywords))reverseKeywords[cssKeywords[key]] = key;
        const convert = {
            rgb: {
                channels: 3,
                labels: 'rgb'
            },
            hsl: {
                channels: 3,
                labels: 'hsl'
            },
            hsv: {
                channels: 3,
                labels: 'hsv'
            },
            hwb: {
                channels: 3,
                labels: 'hwb'
            },
            cmyk: {
                channels: 4,
                labels: 'cmyk'
            },
            xyz: {
                channels: 3,
                labels: 'xyz'
            },
            lab: {
                channels: 3,
                labels: 'lab'
            },
            lch: {
                channels: 3,
                labels: 'lch'
            },
            hex: {
                channels: 1,
                labels: [
                    'hex'
                ]
            },
            keyword: {
                channels: 1,
                labels: [
                    'keyword'
                ]
            },
            ansi16: {
                channels: 1,
                labels: [
                    'ansi16'
                ]
            },
            ansi256: {
                channels: 1,
                labels: [
                    'ansi256'
                ]
            },
            hcg: {
                channels: 3,
                labels: [
                    'h',
                    'c',
                    'g'
                ]
            },
            apple: {
                channels: 3,
                labels: [
                    'r16',
                    'g16',
                    'b16'
                ]
            },
            gray: {
                channels: 1,
                labels: [
                    'gray'
                ]
            }
        };
        module.exports = convert;
        for (const model of Object.keys(convert)){
            if (!('channels' in convert[model])) throw new Error('missing channels property: ' + model);
            if (!('labels' in convert[model])) throw new Error('missing channel labels property: ' + model);
            if (convert[model].labels.length !== convert[model].channels) throw new Error('channel and label counts mismatch: ' + model);
            const { channels, labels } = convert[model];
            delete convert[model].channels;
            delete convert[model].labels;
            Object.defineProperty(convert[model], 'channels', {
                value: channels
            });
            Object.defineProperty(convert[model], 'labels', {
                value: labels
            });
        }
        convert.rgb.hsl = function(rgb) {
            const r = rgb[0] / 255;
            const g = rgb[1] / 255;
            const b = rgb[2] / 255;
            const min = Math.min(r, g, b);
            const max = Math.max(r, g, b);
            const delta = max - min;
            let h;
            let s;
            if (max === min) h = 0;
            else if (r === max) h = (g - b) / delta;
            else if (g === max) h = 2 + (b - r) / delta;
            else if (b === max) h = 4 + (r - g) / delta;
            h = Math.min(60 * h, 360);
            if (h < 0) h += 360;
            const l = (min + max) / 2;
            s = max === min ? 0 : l <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
            return [
                h,
                100 * s,
                100 * l
            ];
        };
        convert.rgb.hsv = function(rgb) {
            let rdif;
            let gdif;
            let bdif;
            let h;
            let s;
            const r = rgb[0] / 255;
            const g = rgb[1] / 255;
            const b = rgb[2] / 255;
            const v = Math.max(r, g, b);
            const diff = v - Math.min(r, g, b);
            const diffc = function(c) {
                return (v - c) / 6 / diff + 0.5;
            };
            if (0 === diff) {
                h = 0;
                s = 0;
            } else {
                s = diff / v;
                rdif = diffc(r);
                gdif = diffc(g);
                bdif = diffc(b);
                if (r === v) h = bdif - gdif;
                else if (g === v) h = 1 / 3 + rdif - bdif;
                else if (b === v) h = 2 / 3 + gdif - rdif;
                if (h < 0) h += 1;
                else if (h > 1) h -= 1;
            }
            return [
                360 * h,
                100 * s,
                100 * v
            ];
        };
        convert.rgb.hwb = function(rgb) {
            const r = rgb[0];
            const g = rgb[1];
            let b = rgb[2];
            const h = convert.rgb.hsl(rgb)[0];
            const w = 1 / 255 * Math.min(r, Math.min(g, b));
            b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
            return [
                h,
                100 * w,
                100 * b
            ];
        };
        convert.rgb.cmyk = function(rgb) {
            const r = rgb[0] / 255;
            const g = rgb[1] / 255;
            const b = rgb[2] / 255;
            const k = Math.min(1 - r, 1 - g, 1 - b);
            const c = (1 - r - k) / (1 - k) || 0;
            const m = (1 - g - k) / (1 - k) || 0;
            const y = (1 - b - k) / (1 - k) || 0;
            return [
                100 * c,
                100 * m,
                100 * y,
                100 * k
            ];
        };
        function comparativeDistance(x, y) {
            return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
        }
        convert.rgb.keyword = function(rgb) {
            const reversed = reverseKeywords[rgb];
            if (reversed) return reversed;
            let currentClosestDistance = 1 / 0;
            let currentClosestKeyword;
            for (const keyword of Object.keys(cssKeywords)){
                const value = cssKeywords[keyword];
                const distance = comparativeDistance(rgb, value);
                if (distance < currentClosestDistance) {
                    currentClosestDistance = distance;
                    currentClosestKeyword = keyword;
                }
            }
            return currentClosestKeyword;
        };
        convert.keyword.rgb = function(keyword) {
            return cssKeywords[keyword];
        };
        convert.rgb.xyz = function(rgb) {
            let r = rgb[0] / 255;
            let g = rgb[1] / 255;
            let b = rgb[2] / 255;
            r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
            g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
            b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
            const x = 0.4124 * r + 0.3576 * g + 0.1805 * b;
            const y = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            const z = 0.0193 * r + 0.1192 * g + 0.9505 * b;
            return [
                100 * x,
                100 * y,
                100 * z
            ];
        };
        convert.rgb.lab = function(rgb) {
            const xyz = convert.rgb.xyz(rgb);
            let x = xyz[0];
            let y = xyz[1];
            let z = xyz[2];
            x /= 95.047;
            y /= 100;
            z /= 108.883;
            x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
            y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
            z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
            const l = 116 * y - 16;
            const a = 500 * (x - y);
            const b = 200 * (y - z);
            return [
                l,
                a,
                b
            ];
        };
        convert.hsl.rgb = function(hsl) {
            const h = hsl[0] / 360;
            const s = hsl[1] / 100;
            const l = hsl[2] / 100;
            let t2;
            let t3;
            let val;
            if (0 === s) {
                val = 255 * l;
                return [
                    val,
                    val,
                    val
                ];
            }
            t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const t1 = 2 * l - t2;
            const rgb = [
                0,
                0,
                0
            ];
            for(let i = 0; i < 3; i++){
                t3 = h + 1 / 3 * -(i - 1);
                if (t3 < 0) t3++;
                if (t3 > 1) t3--;
                val = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
                rgb[i] = 255 * val;
            }
            return rgb;
        };
        convert.hsl.hsv = function(hsl) {
            const h = hsl[0];
            let s = hsl[1] / 100;
            let l = hsl[2] / 100;
            let smin = s;
            const lmin = Math.max(l, 0.01);
            l *= 2;
            s *= l <= 1 ? l : 2 - l;
            smin *= lmin <= 1 ? lmin : 2 - lmin;
            const v = (l + s) / 2;
            const sv = 0 === l ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
            return [
                h,
                100 * sv,
                100 * v
            ];
        };
        convert.hsv.rgb = function(hsv) {
            const h = hsv[0] / 60;
            const s = hsv[1] / 100;
            let v = hsv[2] / 100;
            const hi = Math.floor(h) % 6;
            const f = h - Math.floor(h);
            const p = 255 * v * (1 - s);
            const q = 255 * v * (1 - s * f);
            const t = 255 * v * (1 - s * (1 - f));
            v *= 255;
            switch(hi){
                case 0:
                    return [
                        v,
                        t,
                        p
                    ];
                case 1:
                    return [
                        q,
                        v,
                        p
                    ];
                case 2:
                    return [
                        p,
                        v,
                        t
                    ];
                case 3:
                    return [
                        p,
                        q,
                        v
                    ];
                case 4:
                    return [
                        t,
                        p,
                        v
                    ];
                case 5:
                    return [
                        v,
                        p,
                        q
                    ];
            }
        };
        convert.hsv.hsl = function(hsv) {
            const h = hsv[0];
            const s = hsv[1] / 100;
            const v = hsv[2] / 100;
            const vmin = Math.max(v, 0.01);
            let sl;
            let l;
            l = (2 - s) * v;
            const lmin = (2 - s) * vmin;
            sl = s * vmin;
            sl /= lmin <= 1 ? lmin : 2 - lmin;
            sl = sl || 0;
            l /= 2;
            return [
                h,
                100 * sl,
                100 * l
            ];
        };
        convert.hwb.rgb = function(hwb) {
            const h = hwb[0] / 360;
            let wh = hwb[1] / 100;
            let bl = hwb[2] / 100;
            const ratio = wh + bl;
            let f;
            if (ratio > 1) {
                wh /= ratio;
                bl /= ratio;
            }
            const i = Math.floor(6 * h);
            const v = 1 - bl;
            f = 6 * h - i;
            if ((0x01 & i) !== 0) f = 1 - f;
            const n = wh + f * (v - wh);
            let r;
            let g;
            let b;
            switch(i){
                default:
                case 6:
                case 0:
                    r = v;
                    g = n;
                    b = wh;
                    break;
                case 1:
                    r = n;
                    g = v;
                    b = wh;
                    break;
                case 2:
                    r = wh;
                    g = v;
                    b = n;
                    break;
                case 3:
                    r = wh;
                    g = n;
                    b = v;
                    break;
                case 4:
                    r = n;
                    g = wh;
                    b = v;
                    break;
                case 5:
                    r = v;
                    g = wh;
                    b = n;
                    break;
            }
            return [
                255 * r,
                255 * g,
                255 * b
            ];
        };
        convert.cmyk.rgb = function(cmyk) {
            const c = cmyk[0] / 100;
            const m = cmyk[1] / 100;
            const y = cmyk[2] / 100;
            const k = cmyk[3] / 100;
            const r = 1 - Math.min(1, c * (1 - k) + k);
            const g = 1 - Math.min(1, m * (1 - k) + k);
            const b = 1 - Math.min(1, y * (1 - k) + k);
            return [
                255 * r,
                255 * g,
                255 * b
            ];
        };
        convert.xyz.rgb = function(xyz) {
            const x = xyz[0] / 100;
            const y = xyz[1] / 100;
            const z = xyz[2] / 100;
            let r;
            let g;
            let b;
            r = 3.2406 * x + -1.5372 * y + -0.4986 * z;
            g = -0.9689 * x + 1.8758 * y + 0.0415 * z;
            b = 0.0557 * x + -0.204 * y + 1.0570 * z;
            r = r > 0.0031308 ? 1.055 * r ** (1.0 / 2.4) - 0.055 : 12.92 * r;
            g = g > 0.0031308 ? 1.055 * g ** (1.0 / 2.4) - 0.055 : 12.92 * g;
            b = b > 0.0031308 ? 1.055 * b ** (1.0 / 2.4) - 0.055 : 12.92 * b;
            r = Math.min(Math.max(0, r), 1);
            g = Math.min(Math.max(0, g), 1);
            b = Math.min(Math.max(0, b), 1);
            return [
                255 * r,
                255 * g,
                255 * b
            ];
        };
        convert.xyz.lab = function(xyz) {
            let x = xyz[0];
            let y = xyz[1];
            let z = xyz[2];
            x /= 95.047;
            y /= 100;
            z /= 108.883;
            x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
            y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
            z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
            const l = 116 * y - 16;
            const a = 500 * (x - y);
            const b = 200 * (y - z);
            return [
                l,
                a,
                b
            ];
        };
        convert.lab.xyz = function(lab) {
            const l = lab[0];
            const a = lab[1];
            const b = lab[2];
            let x;
            let y;
            let z;
            y = (l + 16) / 116;
            x = a / 500 + y;
            z = y - b / 200;
            const y2 = y ** 3;
            const x2 = x ** 3;
            const z2 = z ** 3;
            y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
            x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
            z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
            x *= 95.047;
            y *= 100;
            z *= 108.883;
            return [
                x,
                y,
                z
            ];
        };
        convert.lab.lch = function(lab) {
            const l = lab[0];
            const a = lab[1];
            const b = lab[2];
            let h;
            const hr = Math.atan2(b, a);
            h = 360 * hr / 2 / Math.PI;
            if (h < 0) h += 360;
            const c = Math.sqrt(a * a + b * b);
            return [
                l,
                c,
                h
            ];
        };
        convert.lch.lab = function(lch) {
            const l = lch[0];
            const c = lch[1];
            const h = lch[2];
            const hr = h / 360 * 2 * Math.PI;
            const a = c * Math.cos(hr);
            const b = c * Math.sin(hr);
            return [
                l,
                a,
                b
            ];
        };
        convert.rgb.ansi16 = function(args, saturation = null) {
            const [r, g, b] = args;
            let value = null === saturation ? convert.rgb.hsv(args)[2] : saturation;
            value = Math.round(value / 50);
            if (0 === value) return 30;
            let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
            if (2 === value) ansi += 60;
            return ansi;
        };
        convert.hsv.ansi16 = function(args) {
            return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
        };
        convert.rgb.ansi256 = function(args) {
            const r = args[0];
            const g = args[1];
            const b = args[2];
            if (r === g && g === b) {
                if (r < 8) return 16;
                if (r > 248) return 231;
                return Math.round((r - 8) / 247 * 24) + 232;
            }
            const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
            return ansi;
        };
        convert.ansi16.rgb = function(args) {
            let color = args % 10;
            if (0 === color || 7 === color) {
                if (args > 50) color += 3.5;
                color = color / 10.5 * 255;
                return [
                    color,
                    color,
                    color
                ];
            }
            const mult = (~~(args > 50) + 1) * 0.5;
            const r = (1 & color) * mult * 255;
            const g = (color >> 1 & 1) * mult * 255;
            const b = (color >> 2 & 1) * mult * 255;
            return [
                r,
                g,
                b
            ];
        };
        convert.ansi256.rgb = function(args) {
            if (args >= 232) {
                const c = (args - 232) * 10 + 8;
                return [
                    c,
                    c,
                    c
                ];
            }
            args -= 16;
            let rem;
            const r = Math.floor(args / 36) / 5 * 255;
            const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
            const b = rem % 6 / 5 * 255;
            return [
                r,
                g,
                b
            ];
        };
        convert.rgb.hex = function(args) {
            const integer = ((0xFF & Math.round(args[0])) << 16) + ((0xFF & Math.round(args[1])) << 8) + (0xFF & Math.round(args[2]));
            const string = integer.toString(16).toUpperCase();
            return '000000'.substring(string.length) + string;
        };
        convert.hex.rgb = function(args) {
            const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
            if (!match) return [
                0,
                0,
                0
            ];
            let colorString = match[0];
            if (3 === match[0].length) colorString = colorString.split('').map((char)=>char + char).join('');
            const integer = parseInt(colorString, 16);
            const r = integer >> 16 & 0xFF;
            const g = integer >> 8 & 0xFF;
            const b = 0xFF & integer;
            return [
                r,
                g,
                b
            ];
        };
        convert.rgb.hcg = function(rgb) {
            const r = rgb[0] / 255;
            const g = rgb[1] / 255;
            const b = rgb[2] / 255;
            const max = Math.max(Math.max(r, g), b);
            const min = Math.min(Math.min(r, g), b);
            const chroma = max - min;
            let grayscale;
            let hue;
            grayscale = chroma < 1 ? min / (1 - chroma) : 0;
            hue = chroma <= 0 ? 0 : max === r ? (g - b) / chroma % 6 : max === g ? 2 + (b - r) / chroma : 4 + (r - g) / chroma;
            hue /= 6;
            hue %= 1;
            return [
                360 * hue,
                100 * chroma,
                100 * grayscale
            ];
        };
        convert.hsl.hcg = function(hsl) {
            const s = hsl[1] / 100;
            const l = hsl[2] / 100;
            const c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
            let f = 0;
            if (c < 1.0) f = (l - 0.5 * c) / (1.0 - c);
            return [
                hsl[0],
                100 * c,
                100 * f
            ];
        };
        convert.hsv.hcg = function(hsv) {
            const s = hsv[1] / 100;
            const v = hsv[2] / 100;
            const c = s * v;
            let f = 0;
            if (c < 1.0) f = (v - c) / (1 - c);
            return [
                hsv[0],
                100 * c,
                100 * f
            ];
        };
        convert.hcg.rgb = function(hcg) {
            const h = hcg[0] / 360;
            const c = hcg[1] / 100;
            const g = hcg[2] / 100;
            if (0.0 === c) return [
                255 * g,
                255 * g,
                255 * g
            ];
            const pure = [
                0,
                0,
                0
            ];
            const hi = h % 1 * 6;
            const v = hi % 1;
            const w = 1 - v;
            let mg = 0;
            switch(Math.floor(hi)){
                case 0:
                    pure[0] = 1;
                    pure[1] = v;
                    pure[2] = 0;
                    break;
                case 1:
                    pure[0] = w;
                    pure[1] = 1;
                    pure[2] = 0;
                    break;
                case 2:
                    pure[0] = 0;
                    pure[1] = 1;
                    pure[2] = v;
                    break;
                case 3:
                    pure[0] = 0;
                    pure[1] = w;
                    pure[2] = 1;
                    break;
                case 4:
                    pure[0] = v;
                    pure[1] = 0;
                    pure[2] = 1;
                    break;
                default:
                    pure[0] = 1;
                    pure[1] = 0;
                    pure[2] = w;
            }
            mg = (1.0 - c) * g;
            return [
                (c * pure[0] + mg) * 255,
                (c * pure[1] + mg) * 255,
                (c * pure[2] + mg) * 255
            ];
        };
        convert.hcg.hsv = function(hcg) {
            const c = hcg[1] / 100;
            const g = hcg[2] / 100;
            const v = c + g * (1.0 - c);
            let f = 0;
            if (v > 0.0) f = c / v;
            return [
                hcg[0],
                100 * f,
                100 * v
            ];
        };
        convert.hcg.hsl = function(hcg) {
            const c = hcg[1] / 100;
            const g = hcg[2] / 100;
            const l = g * (1.0 - c) + 0.5 * c;
            let s = 0;
            if (l > 0.0 && l < 0.5) s = c / (2 * l);
            else if (l >= 0.5 && l < 1.0) s = c / (2 * (1 - l));
            return [
                hcg[0],
                100 * s,
                100 * l
            ];
        };
        convert.hcg.hwb = function(hcg) {
            const c = hcg[1] / 100;
            const g = hcg[2] / 100;
            const v = c + g * (1.0 - c);
            return [
                hcg[0],
                (v - c) * 100,
                (1 - v) * 100
            ];
        };
        convert.hwb.hcg = function(hwb) {
            const w = hwb[1] / 100;
            const b = hwb[2] / 100;
            const v = 1 - b;
            const c = v - w;
            let g = 0;
            if (c < 1) g = (v - c) / (1 - c);
            return [
                hwb[0],
                100 * c,
                100 * g
            ];
        };
        convert.apple.rgb = function(apple) {
            return [
                apple[0] / 65535 * 255,
                apple[1] / 65535 * 255,
                apple[2] / 65535 * 255
            ];
        };
        convert.rgb.apple = function(rgb) {
            return [
                rgb[0] / 255 * 65535,
                rgb[1] / 255 * 65535,
                rgb[2] / 255 * 65535
            ];
        };
        convert.gray.rgb = function(args) {
            return [
                args[0] / 100 * 255,
                args[0] / 100 * 255,
                args[0] / 100 * 255
            ];
        };
        convert.gray.hsl = function(args) {
            return [
                0,
                0,
                args[0]
            ];
        };
        convert.gray.hsv = convert.gray.hsl;
        convert.gray.hwb = function(gray) {
            return [
                0,
                100,
                gray[0]
            ];
        };
        convert.gray.cmyk = function(gray) {
            return [
                0,
                0,
                0,
                gray[0]
            ];
        };
        convert.gray.lab = function(gray) {
            return [
                gray[0],
                0,
                0
            ];
        };
        convert.gray.hex = function(gray) {
            const val = 0xFF & Math.round(gray[0] / 100 * 255);
            const integer = (val << 16) + (val << 8) + val;
            const string = integer.toString(16).toUpperCase();
            return '000000'.substring(string.length) + string;
        };
        convert.rgb.gray = function(rgb) {
            const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
            return [
                val / 255 * 100
            ];
        };
    },
    "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        const conversions = __webpack_require__("../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js");
        const route = __webpack_require__("../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js");
        const convert = {};
        const models = Object.keys(conversions);
        function wrapRaw(fn) {
            const wrappedFn = function(...args) {
                const arg0 = args[0];
                if (null == arg0) return arg0;
                if (arg0.length > 1) args = arg0;
                return fn(args);
            };
            if ('conversion' in fn) wrappedFn.conversion = fn.conversion;
            return wrappedFn;
        }
        function wrapRounded(fn) {
            const wrappedFn = function(...args) {
                const arg0 = args[0];
                if (null == arg0) return arg0;
                if (arg0.length > 1) args = arg0;
                const result = fn(args);
                if ('object' == typeof result) for(let len = result.length, i = 0; i < len; i++)result[i] = Math.round(result[i]);
                return result;
            };
            if ('conversion' in fn) wrappedFn.conversion = fn.conversion;
            return wrappedFn;
        }
        models.forEach((fromModel)=>{
            convert[fromModel] = {};
            Object.defineProperty(convert[fromModel], 'channels', {
                value: conversions[fromModel].channels
            });
            Object.defineProperty(convert[fromModel], 'labels', {
                value: conversions[fromModel].labels
            });
            const routes = route(fromModel);
            const routeModels = Object.keys(routes);
            routeModels.forEach((toModel)=>{
                const fn = routes[toModel];
                convert[fromModel][toModel] = wrapRounded(fn);
                convert[fromModel][toModel].raw = wrapRaw(fn);
            });
        });
        module.exports = convert;
    },
    "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js" (module, __unused_rspack_exports, __webpack_require__) {
        const conversions = __webpack_require__("../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js");
        function buildGraph() {
            const graph = {};
            const models = Object.keys(conversions);
            for(let len = models.length, i = 0; i < len; i++)graph[models[i]] = {
                distance: -1,
                parent: null
            };
            return graph;
        }
        function deriveBFS(fromModel) {
            const graph = buildGraph();
            const queue = [
                fromModel
            ];
            graph[fromModel].distance = 0;
            while(queue.length){
                const current = queue.pop();
                const adjacents = Object.keys(conversions[current]);
                for(let len = adjacents.length, i = 0; i < len; i++){
                    const adjacent = adjacents[i];
                    const node = graph[adjacent];
                    if (-1 === node.distance) {
                        node.distance = graph[current].distance + 1;
                        node.parent = current;
                        queue.unshift(adjacent);
                    }
                }
            }
            return graph;
        }
        function link(from, to) {
            return function(args) {
                return to(from(args));
            };
        }
        function wrapConversion(toModel, graph) {
            const path = [
                graph[toModel].parent,
                toModel
            ];
            let fn = conversions[graph[toModel].parent][toModel];
            let cur = graph[toModel].parent;
            while(graph[cur].parent){
                path.unshift(graph[cur].parent);
                fn = link(conversions[graph[cur].parent][cur], fn);
                cur = graph[cur].parent;
            }
            fn.conversion = path;
            return fn;
        }
        module.exports = function(fromModel) {
            const graph = deriveBFS(fromModel);
            const conversion = {};
            const models = Object.keys(graph);
            for(let len = models.length, i = 0; i < len; i++){
                const toModel = models[i];
                const node = graph[toModel];
                if (null !== node.parent) conversion[toModel] = wrapConversion(toModel, graph);
            }
            return conversion;
        };
    },
    "../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js" (module) {
        module.exports = {
            aliceblue: [
                240,
                248,
                255
            ],
            antiquewhite: [
                250,
                235,
                215
            ],
            aqua: [
                0,
                255,
                255
            ],
            aquamarine: [
                127,
                255,
                212
            ],
            azure: [
                240,
                255,
                255
            ],
            beige: [
                245,
                245,
                220
            ],
            bisque: [
                255,
                228,
                196
            ],
            black: [
                0,
                0,
                0
            ],
            blanchedalmond: [
                255,
                235,
                205
            ],
            blue: [
                0,
                0,
                255
            ],
            blueviolet: [
                138,
                43,
                226
            ],
            brown: [
                165,
                42,
                42
            ],
            burlywood: [
                222,
                184,
                135
            ],
            cadetblue: [
                95,
                158,
                160
            ],
            chartreuse: [
                127,
                255,
                0
            ],
            chocolate: [
                210,
                105,
                30
            ],
            coral: [
                255,
                127,
                80
            ],
            cornflowerblue: [
                100,
                149,
                237
            ],
            cornsilk: [
                255,
                248,
                220
            ],
            crimson: [
                220,
                20,
                60
            ],
            cyan: [
                0,
                255,
                255
            ],
            darkblue: [
                0,
                0,
                139
            ],
            darkcyan: [
                0,
                139,
                139
            ],
            darkgoldenrod: [
                184,
                134,
                11
            ],
            darkgray: [
                169,
                169,
                169
            ],
            darkgreen: [
                0,
                100,
                0
            ],
            darkgrey: [
                169,
                169,
                169
            ],
            darkkhaki: [
                189,
                183,
                107
            ],
            darkmagenta: [
                139,
                0,
                139
            ],
            darkolivegreen: [
                85,
                107,
                47
            ],
            darkorange: [
                255,
                140,
                0
            ],
            darkorchid: [
                153,
                50,
                204
            ],
            darkred: [
                139,
                0,
                0
            ],
            darksalmon: [
                233,
                150,
                122
            ],
            darkseagreen: [
                143,
                188,
                143
            ],
            darkslateblue: [
                72,
                61,
                139
            ],
            darkslategray: [
                47,
                79,
                79
            ],
            darkslategrey: [
                47,
                79,
                79
            ],
            darkturquoise: [
                0,
                206,
                209
            ],
            darkviolet: [
                148,
                0,
                211
            ],
            deeppink: [
                255,
                20,
                147
            ],
            deepskyblue: [
                0,
                191,
                255
            ],
            dimgray: [
                105,
                105,
                105
            ],
            dimgrey: [
                105,
                105,
                105
            ],
            dodgerblue: [
                30,
                144,
                255
            ],
            firebrick: [
                178,
                34,
                34
            ],
            floralwhite: [
                255,
                250,
                240
            ],
            forestgreen: [
                34,
                139,
                34
            ],
            fuchsia: [
                255,
                0,
                255
            ],
            gainsboro: [
                220,
                220,
                220
            ],
            ghostwhite: [
                248,
                248,
                255
            ],
            gold: [
                255,
                215,
                0
            ],
            goldenrod: [
                218,
                165,
                32
            ],
            gray: [
                128,
                128,
                128
            ],
            green: [
                0,
                128,
                0
            ],
            greenyellow: [
                173,
                255,
                47
            ],
            grey: [
                128,
                128,
                128
            ],
            honeydew: [
                240,
                255,
                240
            ],
            hotpink: [
                255,
                105,
                180
            ],
            indianred: [
                205,
                92,
                92
            ],
            indigo: [
                75,
                0,
                130
            ],
            ivory: [
                255,
                255,
                240
            ],
            khaki: [
                240,
                230,
                140
            ],
            lavender: [
                230,
                230,
                250
            ],
            lavenderblush: [
                255,
                240,
                245
            ],
            lawngreen: [
                124,
                252,
                0
            ],
            lemonchiffon: [
                255,
                250,
                205
            ],
            lightblue: [
                173,
                216,
                230
            ],
            lightcoral: [
                240,
                128,
                128
            ],
            lightcyan: [
                224,
                255,
                255
            ],
            lightgoldenrodyellow: [
                250,
                250,
                210
            ],
            lightgray: [
                211,
                211,
                211
            ],
            lightgreen: [
                144,
                238,
                144
            ],
            lightgrey: [
                211,
                211,
                211
            ],
            lightpink: [
                255,
                182,
                193
            ],
            lightsalmon: [
                255,
                160,
                122
            ],
            lightseagreen: [
                32,
                178,
                170
            ],
            lightskyblue: [
                135,
                206,
                250
            ],
            lightslategray: [
                119,
                136,
                153
            ],
            lightslategrey: [
                119,
                136,
                153
            ],
            lightsteelblue: [
                176,
                196,
                222
            ],
            lightyellow: [
                255,
                255,
                224
            ],
            lime: [
                0,
                255,
                0
            ],
            limegreen: [
                50,
                205,
                50
            ],
            linen: [
                250,
                240,
                230
            ],
            magenta: [
                255,
                0,
                255
            ],
            maroon: [
                128,
                0,
                0
            ],
            mediumaquamarine: [
                102,
                205,
                170
            ],
            mediumblue: [
                0,
                0,
                205
            ],
            mediumorchid: [
                186,
                85,
                211
            ],
            mediumpurple: [
                147,
                112,
                219
            ],
            mediumseagreen: [
                60,
                179,
                113
            ],
            mediumslateblue: [
                123,
                104,
                238
            ],
            mediumspringgreen: [
                0,
                250,
                154
            ],
            mediumturquoise: [
                72,
                209,
                204
            ],
            mediumvioletred: [
                199,
                21,
                133
            ],
            midnightblue: [
                25,
                25,
                112
            ],
            mintcream: [
                245,
                255,
                250
            ],
            mistyrose: [
                255,
                228,
                225
            ],
            moccasin: [
                255,
                228,
                181
            ],
            navajowhite: [
                255,
                222,
                173
            ],
            navy: [
                0,
                0,
                128
            ],
            oldlace: [
                253,
                245,
                230
            ],
            olive: [
                128,
                128,
                0
            ],
            olivedrab: [
                107,
                142,
                35
            ],
            orange: [
                255,
                165,
                0
            ],
            orangered: [
                255,
                69,
                0
            ],
            orchid: [
                218,
                112,
                214
            ],
            palegoldenrod: [
                238,
                232,
                170
            ],
            palegreen: [
                152,
                251,
                152
            ],
            paleturquoise: [
                175,
                238,
                238
            ],
            palevioletred: [
                219,
                112,
                147
            ],
            papayawhip: [
                255,
                239,
                213
            ],
            peachpuff: [
                255,
                218,
                185
            ],
            peru: [
                205,
                133,
                63
            ],
            pink: [
                255,
                192,
                203
            ],
            plum: [
                221,
                160,
                221
            ],
            powderblue: [
                176,
                224,
                230
            ],
            purple: [
                128,
                0,
                128
            ],
            rebeccapurple: [
                102,
                51,
                153
            ],
            red: [
                255,
                0,
                0
            ],
            rosybrown: [
                188,
                143,
                143
            ],
            royalblue: [
                65,
                105,
                225
            ],
            saddlebrown: [
                139,
                69,
                19
            ],
            salmon: [
                250,
                128,
                114
            ],
            sandybrown: [
                244,
                164,
                96
            ],
            seagreen: [
                46,
                139,
                87
            ],
            seashell: [
                255,
                245,
                238
            ],
            sienna: [
                160,
                82,
                45
            ],
            silver: [
                192,
                192,
                192
            ],
            skyblue: [
                135,
                206,
                235
            ],
            slateblue: [
                106,
                90,
                205
            ],
            slategray: [
                112,
                128,
                144
            ],
            slategrey: [
                112,
                128,
                144
            ],
            snow: [
                255,
                250,
                250
            ],
            springgreen: [
                0,
                255,
                127
            ],
            steelblue: [
                70,
                130,
                180
            ],
            tan: [
                210,
                180,
                140
            ],
            teal: [
                0,
                128,
                128
            ],
            thistle: [
                216,
                191,
                216
            ],
            tomato: [
                255,
                99,
                71
            ],
            turquoise: [
                64,
                224,
                208
            ],
            violet: [
                238,
                130,
                238
            ],
            wheat: [
                245,
                222,
                179
            ],
            white: [
                255,
                255,
                255
            ],
            whitesmoke: [
                245,
                245,
                245
            ],
            yellow: [
                255,
                255,
                0
            ],
            yellowgreen: [
                154,
                205,
                50
            ]
        };
    },
    "../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js" (module) {
        module.exports = (flag, argv = process.argv)=>{
            const prefix = flag.startsWith('-') ? '' : 1 === flag.length ? '-' : '--';
            const position = argv.indexOf(prefix + flag);
            const terminatorPosition = argv.indexOf('--');
            return -1 !== position && (-1 === terminatorPosition || position < terminatorPosition);
        };
    },
    "../../node_modules/.pnpm/jest-diff@30.2.0/node_modules/jest-diff/build/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        /*!
 * /**
 *  * Copyright (c) Meta Platforms, Inc. and affiliates.
 *  *
 *  * This source code is licensed under the MIT license found in the
 *  * LICENSE file in the root directory of this source tree.
 *  * /
 */ (()=>{
            "use strict";
            var __webpack_modules__ = {
                "./src/cleanupSemantic.ts": (__unused_webpack_module, exports)=>{
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.cleanupSemantic = exports.Diff = exports.DIFF_INSERT = exports.DIFF_EQUAL = exports.DIFF_DELETE = void 0;
                    var DIFF_DELETE = exports.DIFF_DELETE = -1;
                    var DIFF_INSERT = exports.DIFF_INSERT = 1;
                    var DIFF_EQUAL = exports.DIFF_EQUAL = 0;
                    class Diff {
                        0;
                        1;
                        constructor(op, text){
                            this[0] = op;
                            this[1] = text;
                        }
                    }
                    exports.Diff = Diff;
                    var diff_commonPrefix = function(text1, text2) {
                        if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) return 0;
                        var pointermin = 0;
                        var pointermax = Math.min(text1.length, text2.length);
                        var pointermid = pointermax;
                        var pointerstart = 0;
                        while(pointermin < pointermid){
                            if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
                                pointermin = pointermid;
                                pointerstart = pointermin;
                            } else pointermax = pointermid;
                            pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
                        }
                        return pointermid;
                    };
                    var diff_commonSuffix = function(text1, text2) {
                        if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) return 0;
                        var pointermin = 0;
                        var pointermax = Math.min(text1.length, text2.length);
                        var pointermid = pointermax;
                        var pointerend = 0;
                        while(pointermin < pointermid){
                            if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
                                pointermin = pointermid;
                                pointerend = pointermin;
                            } else pointermax = pointermid;
                            pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
                        }
                        return pointermid;
                    };
                    var diff_commonOverlap_ = function(text1, text2) {
                        var text1_length = text1.length;
                        var text2_length = text2.length;
                        if (0 == text1_length || 0 == text2_length) return 0;
                        if (text1_length > text2_length) text1 = text1.substring(text1_length - text2_length);
                        else if (text1_length < text2_length) text2 = text2.substring(0, text1_length);
                        var text_length = Math.min(text1_length, text2_length);
                        if (text1 == text2) return text_length;
                        var best = 0;
                        var length = 1;
                        while(true){
                            var pattern = text1.substring(text_length - length);
                            var found = text2.indexOf(pattern);
                            if (-1 == found) return best;
                            length += found;
                            if (0 == found || text1.substring(text_length - length) == text2.substring(0, length)) {
                                best = length;
                                length++;
                            }
                        }
                    };
                    var diff_cleanupSemantic = function(diffs) {
                        var changes = false;
                        var equalities = [];
                        var equalitiesLength = 0;
                        var lastEquality = null;
                        var pointer = 0;
                        var length_insertions1 = 0;
                        var length_deletions1 = 0;
                        var length_insertions2 = 0;
                        var length_deletions2 = 0;
                        while(pointer < diffs.length){
                            if (diffs[pointer][0] == DIFF_EQUAL) {
                                equalities[equalitiesLength++] = pointer;
                                length_insertions1 = length_insertions2;
                                length_deletions1 = length_deletions2;
                                length_insertions2 = 0;
                                length_deletions2 = 0;
                                lastEquality = diffs[pointer][1];
                            } else {
                                if (diffs[pointer][0] == DIFF_INSERT) length_insertions2 += diffs[pointer][1].length;
                                else length_deletions2 += diffs[pointer][1].length;
                                if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
                                    diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality));
                                    diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                                    equalitiesLength--;
                                    equalitiesLength--;
                                    pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
                                    length_insertions1 = 0;
                                    length_deletions1 = 0;
                                    length_insertions2 = 0;
                                    length_deletions2 = 0;
                                    lastEquality = null;
                                    changes = true;
                                }
                            }
                            pointer++;
                        }
                        if (changes) diff_cleanupMerge(diffs);
                        diff_cleanupSemanticLossless(diffs);
                        pointer = 1;
                        while(pointer < diffs.length){
                            if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
                                var deletion = diffs[pointer - 1][1];
                                var insertion = diffs[pointer][1];
                                var overlap_length1 = diff_commonOverlap_(deletion, insertion);
                                var overlap_length2 = diff_commonOverlap_(insertion, deletion);
                                if (overlap_length1 >= overlap_length2) {
                                    if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
                                        diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));
                                        diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
                                        diffs[pointer + 1][1] = insertion.substring(overlap_length1);
                                        pointer++;
                                    }
                                } else if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
                                    diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));
                                    diffs[pointer - 1][0] = DIFF_INSERT;
                                    diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
                                    diffs[pointer + 1][0] = DIFF_DELETE;
                                    diffs[pointer + 1][1] = deletion.substring(overlap_length2);
                                    pointer++;
                                }
                                pointer++;
                            }
                            pointer++;
                        }
                    };
                    exports.cleanupSemantic = diff_cleanupSemantic;
                    var diff_cleanupSemanticLossless = function(diffs) {
                        function diff_cleanupSemanticScore_(one, two) {
                            if (!one || !two) return 6;
                            var char1 = one.charAt(one.length - 1);
                            var char2 = two.charAt(0);
                            var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
                            var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
                            var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
                            var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
                            var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
                            var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
                            var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
                            var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
                            if (blankLine1 || blankLine2) return 5;
                            if (lineBreak1 || lineBreak2) return 4;
                            if (nonAlphaNumeric1 && !whitespace1 && whitespace2) return 3;
                            if (whitespace1 || whitespace2) return 2;
                            if (nonAlphaNumeric1 || nonAlphaNumeric2) return 1;
                            return 0;
                        }
                        var pointer = 1;
                        while(pointer < diffs.length - 1){
                            if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
                                var equality1 = diffs[pointer - 1][1];
                                var edit = diffs[pointer][1];
                                var equality2 = diffs[pointer + 1][1];
                                var commonOffset = diff_commonSuffix(equality1, edit);
                                if (commonOffset) {
                                    var commonString = edit.substring(edit.length - commonOffset);
                                    equality1 = equality1.substring(0, equality1.length - commonOffset);
                                    edit = commonString + edit.substring(0, edit.length - commonOffset);
                                    equality2 = commonString + equality2;
                                }
                                var bestEquality1 = equality1;
                                var bestEdit = edit;
                                var bestEquality2 = equality2;
                                var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
                                while(edit.charAt(0) === equality2.charAt(0)){
                                    equality1 += edit.charAt(0);
                                    edit = edit.substring(1) + equality2.charAt(0);
                                    equality2 = equality2.substring(1);
                                    var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
                                    if (score >= bestScore) {
                                        bestScore = score;
                                        bestEquality1 = equality1;
                                        bestEdit = edit;
                                        bestEquality2 = equality2;
                                    }
                                }
                                if (diffs[pointer - 1][1] != bestEquality1) {
                                    if (bestEquality1) diffs[pointer - 1][1] = bestEquality1;
                                    else {
                                        diffs.splice(pointer - 1, 1);
                                        pointer--;
                                    }
                                    diffs[pointer][1] = bestEdit;
                                    if (bestEquality2) diffs[pointer + 1][1] = bestEquality2;
                                    else {
                                        diffs.splice(pointer + 1, 1);
                                        pointer--;
                                    }
                                }
                            }
                            pointer++;
                        }
                    };
                    var nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
                    var whitespaceRegex_ = /\s/;
                    var linebreakRegex_ = /[\r\n]/;
                    var blanklineEndRegex_ = /\n\r?\n$/;
                    var blanklineStartRegex_ = /^\r?\n\r?\n/;
                    var diff_cleanupMerge = function(diffs) {
                        diffs.push(new Diff(DIFF_EQUAL, ''));
                        var pointer = 0;
                        var count_delete = 0;
                        var count_insert = 0;
                        var text_delete = '';
                        var text_insert = '';
                        var commonlength;
                        while(pointer < diffs.length)switch(diffs[pointer][0]){
                            case DIFF_INSERT:
                                count_insert++;
                                text_insert += diffs[pointer][1];
                                pointer++;
                                break;
                            case DIFF_DELETE:
                                count_delete++;
                                text_delete += diffs[pointer][1];
                                pointer++;
                                break;
                            case DIFF_EQUAL:
                                if (count_delete + count_insert > 1) {
                                    if (0 !== count_delete && 0 !== count_insert) {
                                        commonlength = diff_commonPrefix(text_insert, text_delete);
                                        if (0 !== commonlength) {
                                            if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                                            else {
                                                diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));
                                                pointer++;
                                            }
                                            text_insert = text_insert.substring(commonlength);
                                            text_delete = text_delete.substring(commonlength);
                                        }
                                        commonlength = diff_commonSuffix(text_insert, text_delete);
                                        if (0 !== commonlength) {
                                            diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                                            text_insert = text_insert.substring(0, text_insert.length - commonlength);
                                            text_delete = text_delete.substring(0, text_delete.length - commonlength);
                                        }
                                    }
                                    pointer -= count_delete + count_insert;
                                    diffs.splice(pointer, count_delete + count_insert);
                                    if (text_delete.length) {
                                        diffs.splice(pointer, 0, new Diff(DIFF_DELETE, text_delete));
                                        pointer++;
                                    }
                                    if (text_insert.length) {
                                        diffs.splice(pointer, 0, new Diff(DIFF_INSERT, text_insert));
                                        pointer++;
                                    }
                                    pointer++;
                                } else if (0 !== pointer && diffs[pointer - 1][0] == DIFF_EQUAL) {
                                    diffs[pointer - 1][1] += diffs[pointer][1];
                                    diffs.splice(pointer, 1);
                                } else pointer++;
                                count_insert = 0;
                                count_delete = 0;
                                text_delete = '';
                                text_insert = '';
                                break;
                        }
                        if ('' === diffs[diffs.length - 1][1]) diffs.pop();
                        var changes = false;
                        pointer = 1;
                        while(pointer < diffs.length - 1){
                            if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
                                if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
                                    diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
                                    diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                                    diffs.splice(pointer - 1, 1);
                                    changes = true;
                                } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
                                    diffs[pointer - 1][1] += diffs[pointer + 1][1];
                                    diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                                    diffs.splice(pointer + 1, 1);
                                    changes = true;
                                }
                            }
                            pointer++;
                        }
                        if (changes) diff_cleanupMerge(diffs);
                    };
                },
                "./src/constants.ts": (__unused_webpack_module, exports)=>{
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.SIMILAR_MESSAGE = exports.NO_DIFF_MESSAGE = void 0;
                    exports.NO_DIFF_MESSAGE = 'Compared values have no visual difference.';
                    exports.SIMILAR_MESSAGE = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.";
                },
                "./src/diffLines.ts": (__unused_webpack_module, exports, __nested_rspack_require_20541_20560__)=>{
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.printDiffLines = exports.diffLinesUnified2 = exports.diffLinesUnified = exports.diffLinesRaw = void 0;
                    var _diffSequences = _interopRequireDefault(__webpack_require__("../../node_modules/.pnpm/@jest+diff-sequences@30.0.1/node_modules/@jest/diff-sequences/build/index.js"));
                    var _cleanupSemantic = __nested_rspack_require_20541_20560__("./src/cleanupSemantic.ts");
                    var _escapeControlCharacters = __nested_rspack_require_20541_20560__("./src/escapeControlCharacters.ts");
                    var _joinAlignedDiffs = __nested_rspack_require_20541_20560__("./src/joinAlignedDiffs.ts");
                    var _normalizeDiffOptions = __nested_rspack_require_20541_20560__("./src/normalizeDiffOptions.ts");
                    function _interopRequireDefault(e) {
                        return e && e.__esModule ? e : {
                            default: e
                        };
                    }
                    const isEmptyString = (lines)=>1 === lines.length && 0 === lines[0].length;
                    const countChanges = (diffs)=>{
                        let a = 0;
                        let b = 0;
                        for (const diff of diffs)switch(diff[0]){
                            case _cleanupSemantic.DIFF_DELETE:
                                a += 1;
                                break;
                            case _cleanupSemantic.DIFF_INSERT:
                                b += 1;
                                break;
                        }
                        return {
                            a,
                            b
                        };
                    };
                    const printAnnotation = ({ aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator, includeChangeCounts, omitAnnotationLines }, changeCounts)=>{
                        if (omitAnnotationLines) return '';
                        let aRest = '';
                        let bRest = '';
                        if (includeChangeCounts) {
                            const aCount = String(changeCounts.a);
                            const bCount = String(changeCounts.b);
                            const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;
                            const aAnnotationPadding = ' '.repeat(Math.max(0, baAnnotationLengthDiff));
                            const bAnnotationPadding = ' '.repeat(Math.max(0, -baAnnotationLengthDiff));
                            const baCountLengthDiff = bCount.length - aCount.length;
                            const aCountPadding = ' '.repeat(Math.max(0, baCountLengthDiff));
                            const bCountPadding = ' '.repeat(Math.max(0, -baCountLengthDiff));
                            aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`;
                            bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;
                        }
                        const a = `${aIndicator} ${aAnnotation}${aRest}`;
                        const b = `${bIndicator} ${bAnnotation}${bRest}`;
                        return `${aColor(a)}\n${bColor(b)}\n\n`;
                    };
                    const printDiffLines = (diffs, options)=>printAnnotation(options, countChanges(diffs)) + (options.expand ? (0, _joinAlignedDiffs.joinAlignedDiffsExpand)(diffs, options) : (0, _joinAlignedDiffs.joinAlignedDiffsNoExpand)(diffs, options));
                    exports.printDiffLines = printDiffLines;
                    const diffLinesUnified = (aLines, bLines, options)=>printDiffLines(diffLinesRaw(isEmptyString(aLines) ? [] : aLines.map(_escapeControlCharacters.escapeControlCharacters), isEmptyString(bLines) ? [] : bLines.map(_escapeControlCharacters.escapeControlCharacters)), (0, _normalizeDiffOptions.normalizeDiffOptions)(options));
                    exports.diffLinesUnified = diffLinesUnified;
                    const diffLinesUnified2 = (aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options)=>{
                        if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {
                            aLinesDisplay = [];
                            aLinesCompare = [];
                        }
                        if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {
                            bLinesDisplay = [];
                            bLinesCompare = [];
                        }
                        if (aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length) return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);
                        const diffs = diffLinesRaw(aLinesCompare, bLinesCompare);
                        let aIndex = 0;
                        let bIndex = 0;
                        for (const diff of diffs)switch(diff[0]){
                            case _cleanupSemantic.DIFF_DELETE:
                                diff[1] = aLinesDisplay[aIndex];
                                aIndex += 1;
                                break;
                            case _cleanupSemantic.DIFF_INSERT:
                                diff[1] = bLinesDisplay[bIndex];
                                bIndex += 1;
                                break;
                            default:
                                diff[1] = bLinesDisplay[bIndex];
                                aIndex += 1;
                                bIndex += 1;
                        }
                        return printDiffLines(diffs, (0, _normalizeDiffOptions.normalizeDiffOptions)(options));
                    };
                    exports.diffLinesUnified2 = diffLinesUnified2;
                    const diffLinesRaw = (aLines, bLines)=>{
                        const aLength = aLines.length;
                        const bLength = bLines.length;
                        const isCommon = (aIndex, bIndex)=>aLines[aIndex] === bLines[bIndex];
                        const diffs = [];
                        let aIndex = 0;
                        let bIndex = 0;
                        const foundSubsequence = (nCommon, aCommon, bCommon)=>{
                            for(; aIndex !== aCommon; aIndex += 1)diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, aLines[aIndex]));
                            for(; bIndex !== bCommon; bIndex += 1)diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, bLines[bIndex]));
                            for(; 0 !== nCommon; nCommon -= 1, aIndex += 1, bIndex += 1)diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_EQUAL, bLines[bIndex]));
                        };
                        (0, _diffSequences.default)(aLength, bLength, isCommon, foundSubsequence);
                        for(; aIndex !== aLength; aIndex += 1)diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, aLines[aIndex]));
                        for(; bIndex !== bLength; bIndex += 1)diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, bLines[bIndex]));
                        return diffs;
                    };
                    exports.diffLinesRaw = diffLinesRaw;
                },
                "./src/diffStrings.ts": (__unused_webpack_module, exports, __nested_rspack_require_26529_26548__)=>{
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports["default"] = void 0;
                    var _diffSequences = _interopRequireDefault(__webpack_require__("../../node_modules/.pnpm/@jest+diff-sequences@30.0.1/node_modules/@jest/diff-sequences/build/index.js"));
                    var _cleanupSemantic = __nested_rspack_require_26529_26548__("./src/cleanupSemantic.ts");
                    function _interopRequireDefault(e) {
                        return e && e.__esModule ? e : {
                            default: e
                        };
                    }
                    const diffStrings = (a, b)=>{
                        const isCommon = (aIndex, bIndex)=>a[aIndex] === b[bIndex];
                        let aIndex = 0;
                        let bIndex = 0;
                        const diffs = [];
                        const foundSubsequence = (nCommon, aCommon, bCommon)=>{
                            if (aIndex !== aCommon) diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, a.slice(aIndex, aCommon)));
                            if (bIndex !== bCommon) diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, b.slice(bIndex, bCommon)));
                            aIndex = aCommon + nCommon;
                            bIndex = bCommon + nCommon;
                            diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_EQUAL, b.slice(bCommon, bIndex)));
                        };
                        (0, _diffSequences.default)(a.length, b.length, isCommon, foundSubsequence);
                        if (aIndex !== a.length) diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, a.slice(aIndex)));
                        if (bIndex !== b.length) diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, b.slice(bIndex)));
                        return diffs;
                    };
                    exports["default"] = diffStrings;
                },
                "./src/escapeControlCharacters.ts": (__unused_webpack_module, exports)=>{
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.escapeControlCharacters = void 0;
                    const escapeControlCharacters = (str)=>str.replaceAll(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F-\u009F]/g, (match)=>{
                            switch(match){
                                case '\b':
                                    return '\\b';
                                case '\f':
                                    return '\\f';
                                case '\v':
                                    return '\\v';
                                default:
                                    {
                                        const code = match.codePointAt(0);
                                        return `\\x${code.toString(16).padStart(2, '0')}`;
                                    }
                            }
                        });
                    exports.escapeControlCharacters = escapeControlCharacters;
                },
                "./src/getAlignedDiffs.ts": (__unused_webpack_module, exports, __nested_rspack_require_29271_29290__)=>{
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports["default"] = void 0;
                    var _cleanupSemantic = __nested_rspack_require_29271_29290__("./src/cleanupSemantic.ts");
                    const concatenateRelevantDiffs = (op, diffs, changeColor)=>diffs.reduce((reduced, diff)=>reduced + (diff[0] === _cleanupSemantic.DIFF_EQUAL ? diff[1] : diff[0] === op && diff[1].length > 0 ? changeColor(diff[1]) : ''), '');
                    class ChangeBuffer {
                        op;
                        line;
                        lines;
                        changeColor;
                        constructor(op, changeColor){
                            this.op = op;
                            this.line = [];
                            this.lines = [];
                            this.changeColor = changeColor;
                        }
                        pushSubstring(substring) {
                            this.pushDiff(new _cleanupSemantic.Diff(this.op, substring));
                        }
                        pushLine() {
                            this.lines.push(1 === this.line.length ? this.line[0][0] === this.op ? this.line[0] : new _cleanupSemantic.Diff(this.op, this.line[0][1]) : new _cleanupSemantic.Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)));
                            this.line.length = 0;
                        }
                        isLineEmpty() {
                            return 0 === this.line.length;
                        }
                        pushDiff(diff) {
                            this.line.push(diff);
                        }
                        align(diff) {
                            const string = diff[1];
                            if (string.includes('\n')) {
                                const substrings = string.split('\n');
                                const iLast = substrings.length - 1;
                                for (const [i, substring] of substrings.entries())if (i < iLast) {
                                    this.pushSubstring(substring);
                                    this.pushLine();
                                } else if (substring.length > 0) this.pushSubstring(substring);
                            } else this.pushDiff(diff);
                        }
                        moveLinesTo(lines) {
                            if (!this.isLineEmpty()) this.pushLine();
                            lines.push(...this.lines);
                            this.lines.length = 0;
                        }
                    }
                    class CommonBuffer {
                        deleteBuffer;
                        insertBuffer;
                        lines;
                        constructor(deleteBuffer, insertBuffer){
                            this.deleteBuffer = deleteBuffer;
                            this.insertBuffer = insertBuffer;
                            this.lines = [];
                        }
                        pushDiffCommonLine(diff) {
                            this.lines.push(diff);
                        }
                        pushDiffChangeLines(diff) {
                            const isDiffEmpty = 0 === diff[1].length;
                            if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) this.deleteBuffer.pushDiff(diff);
                            if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) this.insertBuffer.pushDiff(diff);
                        }
                        flushChangeLines() {
                            this.deleteBuffer.moveLinesTo(this.lines);
                            this.insertBuffer.moveLinesTo(this.lines);
                        }
                        align(diff) {
                            const op = diff[0];
                            const string = diff[1];
                            if (string.includes('\n')) {
                                const substrings = string.split('\n');
                                const iLast = substrings.length - 1;
                                for (const [i, substring] of substrings.entries())if (0 === i) {
                                    const subdiff = new _cleanupSemantic.Diff(op, substring);
                                    if (this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()) {
                                        this.flushChangeLines();
                                        this.pushDiffCommonLine(subdiff);
                                    } else {
                                        this.pushDiffChangeLines(subdiff);
                                        this.flushChangeLines();
                                    }
                                } else if (i < iLast) this.pushDiffCommonLine(new _cleanupSemantic.Diff(op, substring));
                                else if (substring.length > 0) this.pushDiffChangeLines(new _cleanupSemantic.Diff(op, substring));
                            } else this.pushDiffChangeLines(diff);
                        }
                        getLines() {
                            this.flushChangeLines();
                            return this.lines;
                        }
                    }
                    const getAlignedDiffs = (diffs, changeColor)=>{
                        const deleteBuffer = new ChangeBuffer(_cleanupSemantic.DIFF_DELETE, changeColor);
                        const insertBuffer = new ChangeBuffer(_cleanupSemantic.DIFF_INSERT, changeColor);
                        const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);
                        for (const diff of diffs)switch(diff[0]){
                            case _cleanupSemantic.DIFF_DELETE:
                                deleteBuffer.align(diff);
                                break;
                            case _cleanupSemantic.DIFF_INSERT:
                                insertBuffer.align(diff);
                                break;
                            default:
                                commonBuffer.align(diff);
                        }
                        return commonBuffer.getLines();
                    };
                    exports["default"] = getAlignedDiffs;
                },
                "./src/joinAlignedDiffs.ts": (__unused_webpack_module, exports, __nested_rspack_require_36141_36160__)=>{
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.joinAlignedDiffsNoExpand = exports.joinAlignedDiffsExpand = void 0;
                    var _cleanupSemantic = __nested_rspack_require_36141_36160__("./src/cleanupSemantic.ts");
                    const formatTrailingSpaces = (line, trailingSpaceFormatter)=>line.replace(/\s+$/, (match)=>trailingSpaceFormatter(match));
                    const printDiffLine = (line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder)=>0 === line.length ? ' ' === indicator ? isFirstOrLast && emptyFirstOrLastLinePlaceholder.length > 0 ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : '' : color(indicator) : color(`${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`);
                    const printDeleteLine = (line, isFirstOrLast, { aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder })=>printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
                    const printInsertLine = (line, isFirstOrLast, { bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder })=>printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
                    const printCommonLine = (line, isFirstOrLast, { commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder })=>printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
                    const createPatchMark = (aStart, aEnd, bStart, bEnd, { patchColor })=>patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);
                    const joinAlignedDiffsNoExpand = (diffs, options)=>{
                        const iLength = diffs.length;
                        const nContextLines = options.contextLines;
                        const nContextLines2 = nContextLines + nContextLines;
                        let jLength = iLength;
                        let hasExcessAtStartOrEnd = false;
                        let nExcessesBetweenChanges = 0;
                        let i = 0;
                        while(i !== iLength){
                            const iStart = i;
                            while(i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL)i += 1;
                            if (iStart !== i) if (0 === iStart) {
                                if (i > nContextLines) {
                                    jLength -= i - nContextLines;
                                    hasExcessAtStartOrEnd = true;
                                }
                            } else if (i === iLength) {
                                const n = i - iStart;
                                if (n > nContextLines) {
                                    jLength -= n - nContextLines;
                                    hasExcessAtStartOrEnd = true;
                                }
                            } else {
                                const n = i - iStart;
                                if (n > nContextLines2) {
                                    jLength -= n - nContextLines2;
                                    nExcessesBetweenChanges += 1;
                                }
                            }
                            while(i !== iLength && diffs[i][0] !== _cleanupSemantic.DIFF_EQUAL)i += 1;
                        }
                        const hasPatch = 0 !== nExcessesBetweenChanges || hasExcessAtStartOrEnd;
                        if (0 !== nExcessesBetweenChanges) jLength += nExcessesBetweenChanges + 1;
                        else if (hasExcessAtStartOrEnd) jLength += 1;
                        const jLast = jLength - 1;
                        const lines = [];
                        let jPatchMark = 0;
                        if (hasPatch) lines.push('');
                        let aStart = 0;
                        let bStart = 0;
                        let aEnd = 0;
                        let bEnd = 0;
                        const pushCommonLine = (line)=>{
                            const j = lines.length;
                            lines.push(printCommonLine(line, 0 === j || j === jLast, options));
                            aEnd += 1;
                            bEnd += 1;
                        };
                        const pushDeleteLine = (line)=>{
                            const j = lines.length;
                            lines.push(printDeleteLine(line, 0 === j || j === jLast, options));
                            aEnd += 1;
                        };
                        const pushInsertLine = (line)=>{
                            const j = lines.length;
                            lines.push(printInsertLine(line, 0 === j || j === jLast, options));
                            bEnd += 1;
                        };
                        i = 0;
                        while(i !== iLength){
                            let iStart = i;
                            while(i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL)i += 1;
                            if (iStart !== i) if (0 === iStart) {
                                if (i > nContextLines) {
                                    iStart = i - nContextLines;
                                    aStart = iStart;
                                    bStart = iStart;
                                    aEnd = aStart;
                                    bEnd = bStart;
                                }
                                for(let iCommon = iStart; iCommon !== i; iCommon += 1)pushCommonLine(diffs[iCommon][1]);
                            } else if (i === iLength) {
                                const iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;
                                for(let iCommon = iStart; iCommon !== iEnd; iCommon += 1)pushCommonLine(diffs[iCommon][1]);
                            } else {
                                const nCommon = i - iStart;
                                if (nCommon > nContextLines2) {
                                    const iEnd = iStart + nContextLines;
                                    for(let iCommon = iStart; iCommon !== iEnd; iCommon += 1)pushCommonLine(diffs[iCommon][1]);
                                    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
                                    jPatchMark = lines.length;
                                    lines.push('');
                                    const nOmit = nCommon - nContextLines2;
                                    aStart = aEnd + nOmit;
                                    bStart = bEnd + nOmit;
                                    aEnd = aStart;
                                    bEnd = bStart;
                                    for(let iCommon = i - nContextLines; iCommon !== i; iCommon += 1)pushCommonLine(diffs[iCommon][1]);
                                } else for(let iCommon = iStart; iCommon !== i; iCommon += 1)pushCommonLine(diffs[iCommon][1]);
                            }
                            while(i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_DELETE){
                                pushDeleteLine(diffs[i][1]);
                                i += 1;
                            }
                            while(i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_INSERT){
                                pushInsertLine(diffs[i][1]);
                                i += 1;
                            }
                        }
                        if (hasPatch) lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
                        return lines.join('\n');
                    };
                    exports.joinAlignedDiffsNoExpand = joinAlignedDiffsNoExpand;
                    const joinAlignedDiffsExpand = (diffs, options)=>diffs.map((diff, i, diffs)=>{
                            const line = diff[1];
                            const isFirstOrLast = 0 === i || i === diffs.length - 1;
                            switch(diff[0]){
                                case _cleanupSemantic.DIFF_DELETE:
                                    return printDeleteLine(line, isFirstOrLast, options);
                                case _cleanupSemantic.DIFF_INSERT:
                                    return printInsertLine(line, isFirstOrLast, options);
                                default:
                                    return printCommonLine(line, isFirstOrLast, options);
                            }
                        }).join('\n');
                    exports.joinAlignedDiffsExpand = joinAlignedDiffsExpand;
                },
                "./src/normalizeDiffOptions.ts": (__unused_webpack_module, exports)=>{
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.normalizeDiffOptions = exports.noColor = void 0;
                    var _chalk = _interopRequireDefault(__webpack_require__("../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js"));
                    function _interopRequireDefault(e) {
                        return e && e.__esModule ? e : {
                            default: e
                        };
                    }
                    const noColor = (string)=>string;
                    exports.noColor = noColor;
                    const DIFF_CONTEXT_DEFAULT = 5;
                    const OPTIONS_DEFAULT = {
                        aAnnotation: 'Expected',
                        aColor: _chalk.default.green,
                        aIndicator: '-',
                        bAnnotation: 'Received',
                        bColor: _chalk.default.red,
                        bIndicator: '+',
                        changeColor: _chalk.default.inverse,
                        changeLineTrailingSpaceColor: noColor,
                        commonColor: _chalk.default.dim,
                        commonIndicator: ' ',
                        commonLineTrailingSpaceColor: noColor,
                        compareKeys: void 0,
                        contextLines: DIFF_CONTEXT_DEFAULT,
                        emptyFirstOrLastLinePlaceholder: '',
                        expand: true,
                        includeChangeCounts: false,
                        omitAnnotationLines: false,
                        patchColor: _chalk.default.yellow
                    };
                    const getCompareKeys = (compareKeys)=>compareKeys && 'function' == typeof compareKeys ? compareKeys : OPTIONS_DEFAULT.compareKeys;
                    const getContextLines = (contextLines)=>'number' == typeof contextLines && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;
                    const normalizeDiffOptions = (options = {})=>({
                            ...OPTIONS_DEFAULT,
                            ...options,
                            compareKeys: getCompareKeys(options.compareKeys),
                            contextLines: getContextLines(options.contextLines)
                        });
                    exports.normalizeDiffOptions = normalizeDiffOptions;
                },
                "./src/printDiffs.ts": (__unused_webpack_module, exports, __nested_rspack_require_45536_45555__)=>{
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.diffStringsUnified = exports.diffStringsRaw = void 0;
                    var _cleanupSemantic = __nested_rspack_require_45536_45555__("./src/cleanupSemantic.ts");
                    var _diffLines = __nested_rspack_require_45536_45555__("./src/diffLines.ts");
                    var _diffStrings = _interopRequireDefault(__nested_rspack_require_45536_45555__("./src/diffStrings.ts"));
                    var _getAlignedDiffs = _interopRequireDefault(__nested_rspack_require_45536_45555__("./src/getAlignedDiffs.ts"));
                    var _normalizeDiffOptions = __nested_rspack_require_45536_45555__("./src/normalizeDiffOptions.ts");
                    function _interopRequireDefault(e) {
                        return e && e.__esModule ? e : {
                            default: e
                        };
                    }
                    const hasCommonDiff = (diffs, isMultiline)=>{
                        if (isMultiline) {
                            const iLast = diffs.length - 1;
                            return diffs.some((diff, i)=>diff[0] === _cleanupSemantic.DIFF_EQUAL && (i !== iLast || '\n' !== diff[1]));
                        }
                        return diffs.some((diff)=>diff[0] === _cleanupSemantic.DIFF_EQUAL);
                    };
                    const diffStringsUnified = (a, b, options)=>{
                        if (a !== b && a.length > 0 && b.length > 0) {
                            const isMultiline = a.includes('\n') || b.includes('\n');
                            const diffs = diffStringsRaw(isMultiline ? `${a}\n` : a, isMultiline ? `${b}\n` : b, true);
                            if (hasCommonDiff(diffs, isMultiline)) {
                                const optionsNormalized = (0, _normalizeDiffOptions.normalizeDiffOptions)(options);
                                const lines = (0, _getAlignedDiffs.default)(diffs, optionsNormalized.changeColor);
                                return (0, _diffLines.printDiffLines)(lines, optionsNormalized);
                            }
                        }
                        return (0, _diffLines.diffLinesUnified)(a.split('\n'), b.split('\n'), options);
                    };
                    exports.diffStringsUnified = diffStringsUnified;
                    const diffStringsRaw = (a, b, cleanup)=>{
                        const diffs = (0, _diffStrings.default)(a, b);
                        if (cleanup) (0, _cleanupSemantic.cleanupSemantic)(diffs);
                        return diffs;
                    };
                    exports.diffStringsRaw = diffStringsRaw;
                }
            };
            var __webpack_module_cache__ = {};
            function __nested_rspack_require_48295__(moduleId) {
                var cachedModule = __webpack_module_cache__[moduleId];
                if (void 0 !== cachedModule) return cachedModule.exports;
                var module = __webpack_module_cache__[moduleId] = {
                    exports: {}
                };
                __webpack_modules__[moduleId](module, module.exports, __nested_rspack_require_48295__);
                return module.exports;
            }
            var __nested_rspack_exports__ = {};
            (()=>{
                var exports = __nested_rspack_exports__;
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                Object.defineProperty(exports, "DIFF_DELETE", {
                    enumerable: true,
                    get: function() {
                        return _cleanupSemantic.DIFF_DELETE;
                    }
                });
                Object.defineProperty(exports, "DIFF_EQUAL", {
                    enumerable: true,
                    get: function() {
                        return _cleanupSemantic.DIFF_EQUAL;
                    }
                });
                Object.defineProperty(exports, "DIFF_INSERT", {
                    enumerable: true,
                    get: function() {
                        return _cleanupSemantic.DIFF_INSERT;
                    }
                });
                Object.defineProperty(exports, "Diff", {
                    enumerable: true,
                    get: function() {
                        return _cleanupSemantic.Diff;
                    }
                });
                exports.diff = diff;
                Object.defineProperty(exports, "diffLinesRaw", {
                    enumerable: true,
                    get: function() {
                        return _diffLines.diffLinesRaw;
                    }
                });
                Object.defineProperty(exports, "diffLinesUnified", {
                    enumerable: true,
                    get: function() {
                        return _diffLines.diffLinesUnified;
                    }
                });
                Object.defineProperty(exports, "diffLinesUnified2", {
                    enumerable: true,
                    get: function() {
                        return _diffLines.diffLinesUnified2;
                    }
                });
                Object.defineProperty(exports, "diffStringsRaw", {
                    enumerable: true,
                    get: function() {
                        return _printDiffs.diffStringsRaw;
                    }
                });
                Object.defineProperty(exports, "diffStringsUnified", {
                    enumerable: true,
                    get: function() {
                        return _printDiffs.diffStringsUnified;
                    }
                });
                var _chalk = _interopRequireDefault(__webpack_require__("../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js"));
                var _getType = __webpack_require__("../../node_modules/.pnpm/@jest+get-type@30.1.0/node_modules/@jest/get-type/build/index.js");
                var _prettyFormat = __webpack_require__("../../node_modules/.pnpm/pretty-format@30.2.0/node_modules/pretty-format/build/index.js");
                var _cleanupSemantic = __nested_rspack_require_48295__("./src/cleanupSemantic.ts");
                var _constants = __nested_rspack_require_48295__("./src/constants.ts");
                var _diffLines = __nested_rspack_require_48295__("./src/diffLines.ts");
                var _escapeControlCharacters = __nested_rspack_require_48295__("./src/escapeControlCharacters.ts");
                var _normalizeDiffOptions = __nested_rspack_require_48295__("./src/normalizeDiffOptions.ts");
                var _printDiffs = __nested_rspack_require_48295__("./src/printDiffs.ts");
                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    };
                }
                var src_Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;
                const getCommonMessage = (message, options)=>{
                    const { commonColor } = (0, _normalizeDiffOptions.normalizeDiffOptions)(options);
                    return commonColor(message);
                };
                const { AsymmetricMatcher, DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent } = _prettyFormat.plugins;
                const PLUGINS = [
                    ReactTestComponent,
                    ReactElement,
                    DOMElement,
                    DOMCollection,
                    Immutable,
                    AsymmetricMatcher
                ];
                const FORMAT_OPTIONS = {
                    plugins: PLUGINS
                };
                const FALLBACK_FORMAT_OPTIONS = {
                    callToJSON: false,
                    maxDepth: 10,
                    plugins: PLUGINS
                };
                function diff(a, b, options) {
                    if (Object.is(a, b)) return getCommonMessage(_constants.NO_DIFF_MESSAGE, options);
                    const aType = (0, _getType.getType)(a);
                    let expectedType = aType;
                    let omitDifference = false;
                    if ('object' === aType && 'function' == typeof a.asymmetricMatch) {
                        if (a.$$typeof !== src_Symbol.for('jest.asymmetricMatcher')) return null;
                        if ('function' != typeof a.getExpectedType) return null;
                        expectedType = a.getExpectedType();
                        omitDifference = 'string' === expectedType;
                    }
                    if (expectedType !== (0, _getType.getType)(b)) return `  Comparing two different types of values. Expected ${_chalk.default.green(expectedType)} but received ${_chalk.default.red((0, _getType.getType)(b))}.`;
                    if (omitDifference) return null;
                    switch(aType){
                        case 'string':
                            return (0, _diffLines.diffLinesUnified)((0, _escapeControlCharacters.escapeControlCharacters)(a).split('\n'), (0, _escapeControlCharacters.escapeControlCharacters)(b).split('\n'), options);
                        case 'boolean':
                        case 'number':
                            return comparePrimitive(a, b, options);
                        case 'map':
                            return compareObjects(sortMap(a), sortMap(b), options);
                        case 'set':
                            return compareObjects(sortSet(a), sortSet(b), options);
                        default:
                            return compareObjects(a, b, options);
                    }
                }
                function comparePrimitive(a, b, options) {
                    const aFormat = (0, _prettyFormat.format)(a, FORMAT_OPTIONS);
                    const bFormat = (0, _prettyFormat.format)(b, FORMAT_OPTIONS);
                    return aFormat === bFormat ? getCommonMessage(_constants.NO_DIFF_MESSAGE, options) : (0, _diffLines.diffLinesUnified)(aFormat.split('\n'), bFormat.split('\n'), options);
                }
                function sortMap(map) {
                    return new Map([
                        ...map
                    ].sort());
                }
                function sortSet(set) {
                    return new Set([
                        ...set
                    ].sort());
                }
                function compareObjects(a, b, options) {
                    let difference;
                    let hasThrown = false;
                    try {
                        const formatOptions = getFormatOptions(FORMAT_OPTIONS, options);
                        difference = getObjectsDifference(a, b, formatOptions, options);
                    } catch  {
                        hasThrown = true;
                    }
                    const noDiffMessage = getCommonMessage(_constants.NO_DIFF_MESSAGE, options);
                    if (void 0 === difference || difference === noDiffMessage) {
                        const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
                        difference = getObjectsDifference(a, b, formatOptions, options);
                        if (difference !== noDiffMessage && !hasThrown) difference = `${getCommonMessage(_constants.SIMILAR_MESSAGE, options)}\n\n${difference}`;
                    }
                    return difference;
                }
                function getFormatOptions(formatOptions, options) {
                    const { compareKeys } = (0, _normalizeDiffOptions.normalizeDiffOptions)(options);
                    return {
                        ...formatOptions,
                        compareKeys
                    };
                }
                function getObjectsDifference(a, b, formatOptions, options) {
                    const formatOptionsZeroIndent = {
                        ...formatOptions,
                        indent: 0
                    };
                    const aCompare = (0, _prettyFormat.format)(a, formatOptionsZeroIndent);
                    const bCompare = (0, _prettyFormat.format)(b, formatOptionsZeroIndent);
                    if (aCompare === bCompare) return getCommonMessage(_constants.NO_DIFF_MESSAGE, options);
                    {
                        const aDisplay = (0, _prettyFormat.format)(a, formatOptions);
                        const bDisplay = (0, _prettyFormat.format)(b, formatOptions);
                        return (0, _diffLines.diffLinesUnified2)(aDisplay.split('\n'), bDisplay.split('\n'), aCompare.split('\n'), bCompare.split('\n'), options);
                    }
                }
            })();
            module.exports = __nested_rspack_exports__;
        })();
    },
    "../../node_modules/.pnpm/pretty-format@30.2.0/node_modules/pretty-format/build/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        /*!
 * /**
 *  * Copyright (c) Meta Platforms, Inc. and affiliates.
 *  *
 *  * This source code is licensed under the MIT license found in the
 *  * LICENSE file in the root directory of this source tree.
 *  * /
 */ (()=>{
            "use strict";
            var __webpack_modules__ = {
                "./src/collections.ts": (__unused_webpack_module, exports)=>{
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.printIteratorEntries = printIteratorEntries;
                    exports.printIteratorValues = printIteratorValues;
                    exports.printListItems = printListItems;
                    exports.printObjectProperties = printObjectProperties;
                    const getKeysOfEnumerableProperties = (object, compareKeys)=>{
                        const rawKeys = Object.keys(object);
                        const keys = null === compareKeys ? rawKeys : rawKeys.sort(compareKeys);
                        if (Object.getOwnPropertySymbols) {
                            for (const symbol of Object.getOwnPropertySymbols(object))if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) keys.push(symbol);
                        }
                        return keys;
                    };
                    function printIteratorEntries(iterator, config, indentation, depth, refs, printer, separator = ': ') {
                        let result = '';
                        let width = 0;
                        let current = iterator.next();
                        if (!current.done) {
                            result += config.spacingOuter;
                            const indentationNext = indentation + config.indent;
                            while(!current.done){
                                result += indentationNext;
                                if (width++ === config.maxWidth) {
                                    result += '';
                                    break;
                                }
                                const name = printer(current.value[0], config, indentationNext, depth, refs);
                                const value = printer(current.value[1], config, indentationNext, depth, refs);
                                result += name + separator + value;
                                current = iterator.next();
                                if (current.done) {
                                    if (!config.min) result += ',';
                                } else result += `,${config.spacingInner}`;
                            }
                            result += config.spacingOuter + indentation;
                        }
                        return result;
                    }
                    function printIteratorValues(iterator, config, indentation, depth, refs, printer) {
                        let result = '';
                        let width = 0;
                        let current = iterator.next();
                        if (!current.done) {
                            result += config.spacingOuter;
                            const indentationNext = indentation + config.indent;
                            while(!current.done){
                                result += indentationNext;
                                if (width++ === config.maxWidth) {
                                    result += '';
                                    break;
                                }
                                result += printer(current.value, config, indentationNext, depth, refs);
                                current = iterator.next();
                                if (current.done) {
                                    if (!config.min) result += ',';
                                } else result += `,${config.spacingInner}`;
                            }
                            result += config.spacingOuter + indentation;
                        }
                        return result;
                    }
                    function printListItems(list, config, indentation, depth, refs, printer) {
                        let result = '';
                        list = list instanceof ArrayBuffer ? new DataView(list) : list;
                        const isDataView = (l)=>l instanceof DataView;
                        const length = isDataView(list) ? list.byteLength : list.length;
                        if (length > 0) {
                            result += config.spacingOuter;
                            const indentationNext = indentation + config.indent;
                            for(let i = 0; i < length; i++){
                                result += indentationNext;
                                if (i === config.maxWidth) {
                                    result += '';
                                    break;
                                }
                                if (isDataView(list) || i in list) result += printer(isDataView(list) ? list.getInt8(i) : list[i], config, indentationNext, depth, refs);
                                if (i < length - 1) result += `,${config.spacingInner}`;
                                else if (!config.min) result += ',';
                            }
                            result += config.spacingOuter + indentation;
                        }
                        return result;
                    }
                    function printObjectProperties(val, config, indentation, depth, refs, printer) {
                        let result = '';
                        const keys = getKeysOfEnumerableProperties(val, config.compareKeys);
                        if (keys.length > 0) {
                            result += config.spacingOuter;
                            const indentationNext = indentation + config.indent;
                            for(let i = 0; i < keys.length; i++){
                                const key = keys[i];
                                const name = printer(key, config, indentationNext, depth, refs);
                                const value = printer(val[key], config, indentationNext, depth, refs);
                                result += `${indentationNext + name}: ${value}`;
                                if (i < keys.length - 1) result += `,${config.spacingInner}`;
                                else if (!config.min) result += ',';
                            }
                            result += config.spacingOuter + indentation;
                        }
                        return result;
                    }
                },
                "./src/plugins/AsymmetricMatcher.ts": (__unused_webpack_module, exports, __nested_rspack_require_5506_5525__)=>{
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.test = exports.serialize = exports["default"] = void 0;
                    var _collections = __nested_rspack_require_5506_5525__("./src/collections.ts");
                    var Symbol1 = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;
                    const asymmetricMatcher = 'function' == typeof Symbol1 && Symbol1.for ? Symbol1.for('jest.asymmetricMatcher') : 0x1357a5;
                    const SPACE = ' ';
                    const serialize = (val, config, indentation, depth, refs, printer)=>{
                        const stringedValue = val.toString();
                        if ('ArrayContaining' === stringedValue || 'ArrayNotContaining' === stringedValue) {
                            if (++depth > config.maxDepth) return `[${stringedValue}]`;
                            return `${stringedValue + SPACE}[${(0, _collections.printListItems)(val.sample, config, indentation, depth, refs, printer)}]`;
                        }
                        if ('ObjectContaining' === stringedValue || 'ObjectNotContaining' === stringedValue) {
                            if (++depth > config.maxDepth) return `[${stringedValue}]`;
                            return `${stringedValue + SPACE}{${(0, _collections.printObjectProperties)(val.sample, config, indentation, depth, refs, printer)}}`;
                        }
                        if ('StringMatching' === stringedValue || 'StringNotMatching' === stringedValue) return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
                        if ('StringContaining' === stringedValue || 'StringNotContaining' === stringedValue) return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
                        if ('ArrayOf' === stringedValue || 'NotArrayOf' === stringedValue) {
                            if (++depth > config.maxDepth) return `[${stringedValue}]`;
                            return `${stringedValue + SPACE}${printer(val.sample, config, indentation, depth, refs)}`;
                        }
                        if ('function' != typeof val.toAsymmetricMatcher) throw new TypeError(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);
                        return val.toAsymmetricMatcher();
                    };
                    exports.serialize = serialize;
                    const test = (val)=>val && val.$$typeof === asymmetricMatcher;
                    exports.test = test;
                    const plugin = {
                        serialize,
                        test
                    };
                    exports["default"] = plugin;
                },
                "./src/plugins/DOMCollection.ts": (__unused_webpack_module, exports, __nested_rspack_require_7970_7989__)=>{
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.test = exports.serialize = exports["default"] = void 0;
                    var _collections = __nested_rspack_require_7970_7989__("./src/collections.ts");
                    const SPACE = ' ';
                    const OBJECT_NAMES = new Set([
                        'DOMStringMap',
                        'NamedNodeMap'
                    ]);
                    const ARRAY_REGEXP = /^(HTML\w*Collection|NodeList)$/;
                    const testName = (name)=>OBJECT_NAMES.has(name) || ARRAY_REGEXP.test(name);
                    const test = (val)=>val && val.constructor && !!val.constructor.name && testName(val.constructor.name);
                    exports.test = test;
                    const isNamedNodeMap = (collection)=>'NamedNodeMap' === collection.constructor.name;
                    const serialize = (collection, config, indentation, depth, refs, printer)=>{
                        const name = collection.constructor.name;
                        if (++depth > config.maxDepth) return `[${name}]`;
                        return (config.min ? '' : name + SPACE) + (OBJECT_NAMES.has(name) ? `{${(0, _collections.printObjectProperties)(isNamedNodeMap(collection) ? [
                            ...collection
                        ].reduce((props, attribute)=>{
                            props[attribute.name] = attribute.value;
                            return props;
                        }, {}) : {
                            ...collection
                        }, config, indentation, depth, refs, printer)}}` : `[${(0, _collections.printListItems)([
                            ...collection
                        ], config, indentation, depth, refs, printer)}]`);
                    };
                    exports.serialize = serialize;
                    const plugin = {
                        serialize,
                        test
                    };
                    exports["default"] = plugin;
                },
                "./src/plugins/DOMElement.ts": (__unused_webpack_module, exports, __nested_rspack_require_9644_9663__)=>{
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.test = exports.serialize = exports["default"] = void 0;
                    var _markup = __nested_rspack_require_9644_9663__("./src/plugins/lib/markup.ts");
                    const ELEMENT_NODE = 1;
                    const TEXT_NODE = 3;
                    const COMMENT_NODE = 8;
                    const FRAGMENT_NODE = 11;
                    const ELEMENT_REGEXP = /^((HTML|SVG)\w*)?Element$/;
                    const testHasAttribute = (val)=>{
                        try {
                            return 'function' == typeof val.hasAttribute && val.hasAttribute('is');
                        } catch  {
                            return false;
                        }
                    };
                    const isCustomElement = (val)=>{
                        const tagName = val?.tagName;
                        return 'string' == typeof tagName && tagName.includes('-') || testHasAttribute(val);
                    };
                    const testNode = (val)=>{
                        const constructorName = val.constructor.name;
                        const { nodeType } = val;
                        return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement(val)) || nodeType === TEXT_NODE && 'Text' === constructorName || nodeType === COMMENT_NODE && 'Comment' === constructorName || nodeType === FRAGMENT_NODE && 'DocumentFragment' === constructorName;
                    };
                    const test = (val)=>(val?.constructor?.name || isCustomElement(val)) && testNode(val);
                    exports.test = test;
                    function nodeIsText(node) {
                        return node.nodeType === TEXT_NODE;
                    }
                    function nodeIsComment(node) {
                        return node.nodeType === COMMENT_NODE;
                    }
                    function nodeIsFragment(node) {
                        return node.nodeType === FRAGMENT_NODE;
                    }
                    const serialize = (node, config, indentation, depth, refs, printer)=>{
                        if (nodeIsText(node)) return (0, _markup.printText)(node.data, config);
                        if (nodeIsComment(node)) return (0, _markup.printComment)(node.data, config);
                        const type = nodeIsFragment(node) ? 'DocumentFragment' : node.tagName.toLowerCase();
                        if (++depth > config.maxDepth) return (0, _markup.printElementAsLeaf)(type, config);
                        return (0, _markup.printElement)(type, (0, _markup.printProps)(nodeIsFragment(node) ? [] : Array.from(node.attributes, (attr)=>attr.name).sort(), nodeIsFragment(node) ? {} : [
                            ...node.attributes
                        ].reduce((props, attribute)=>{
                            props[attribute.name] = attribute.value;
                            return props;
                        }, {}), config, indentation + config.indent, depth, refs, printer), (0, _markup.printChildren)(Array.prototype.slice.call(node.childNodes || node.children), config, indentation + config.indent, depth, refs, printer), config, indentation);
                    };
                    exports.serialize = serialize;
                    const plugin = {
                        serialize,
                        test
                    };
                    exports["default"] = plugin;
                },
                "./src/plugins/Immutable.ts": (__unused_webpack_module, exports, __nested_rspack_require_12421_12440__)=>{
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.test = exports.serialize = exports["default"] = void 0;
                    var _collections = __nested_rspack_require_12421_12440__("./src/collections.ts");
                    const IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
                    const IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
                    const IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
                    const IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
                    const IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
                    const IS_RECORD_SENTINEL = '@@__IMMUTABLE_RECORD__@@';
                    const IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
                    const IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
                    const IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
                    const getImmutableName = (name)=>`Immutable.${name}`;
                    const printAsLeaf = (name)=>`[${name}]`;
                    const SPACE = ' ';
                    const LAZY = '';
                    const printImmutableEntries = (val, config, indentation, depth, refs, printer, type)=>++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}{${(0, _collections.printIteratorEntries)(val.entries(), config, indentation, depth, refs, printer)}}`;
                    function getRecordEntries(val) {
                        let i = 0;
                        return {
                            next () {
                                if (i < val._keys.length) {
                                    const key = val._keys[i++];
                                    return {
                                        done: false,
                                        value: [
                                            key,
                                            val.get(key)
                                        ]
                                    };
                                }
                                return {
                                    done: true,
                                    value: void 0
                                };
                            }
                        };
                    }
                    const printImmutableRecord = (val, config, indentation, depth, refs, printer)=>{
                        const name = getImmutableName(val._name || 'Record');
                        return ++depth > config.maxDepth ? printAsLeaf(name) : `${name + SPACE}{${(0, _collections.printIteratorEntries)(getRecordEntries(val), config, indentation, depth, refs, printer)}}`;
                    };
                    const printImmutableSeq = (val, config, indentation, depth, refs, printer)=>{
                        const name = getImmutableName('Seq');
                        if (++depth > config.maxDepth) return printAsLeaf(name);
                        if (val[IS_KEYED_SENTINEL]) return `${name + SPACE}{${val._iter || val._object ? (0, _collections.printIteratorEntries)(val.entries(), config, indentation, depth, refs, printer) : LAZY}}`;
                        return `${name + SPACE}[${val._iter || val._array || val._collection || val._iterable ? (0, _collections.printIteratorValues)(val.values(), config, indentation, depth, refs, printer) : LAZY}]`;
                    };
                    const printImmutableValues = (val, config, indentation, depth, refs, printer, type)=>++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}[${(0, _collections.printIteratorValues)(val.values(), config, indentation, depth, refs, printer)}]`;
                    const serialize = (val, config, indentation, depth, refs, printer)=>{
                        if (val[IS_MAP_SENTINEL]) return printImmutableEntries(val, config, indentation, depth, refs, printer, val[IS_ORDERED_SENTINEL] ? 'OrderedMap' : 'Map');
                        if (val[IS_LIST_SENTINEL]) return printImmutableValues(val, config, indentation, depth, refs, printer, 'List');
                        if (val[IS_SET_SENTINEL]) return printImmutableValues(val, config, indentation, depth, refs, printer, val[IS_ORDERED_SENTINEL] ? 'OrderedSet' : 'Set');
                        if (val[IS_STACK_SENTINEL]) return printImmutableValues(val, config, indentation, depth, refs, printer, 'Stack');
                        if (val[IS_SEQ_SENTINEL]) return printImmutableSeq(val, config, indentation, depth, refs, printer);
                        return printImmutableRecord(val, config, indentation, depth, refs, printer);
                    };
                    exports.serialize = serialize;
                    const test = (val)=>val && (true === val[IS_ITERABLE_SENTINEL] || true === val[IS_RECORD_SENTINEL]);
                    exports.test = test;
                    const plugin = {
                        serialize,
                        test
                    };
                    exports["default"] = plugin;
                },
                "./src/plugins/ReactElement.ts": (__unused_webpack_module, exports, __nested_rspack_require_17327_17346__)=>{
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.test = exports.serialize = exports["default"] = void 0;
                    var ReactIs = _interopRequireWildcard(__webpack_require__("../../node_modules/.pnpm/react-is@18.3.1/node_modules/react-is/index.js"));
                    var _markup = __nested_rspack_require_17327_17346__("./src/plugins/lib/markup.ts");
                    function _interopRequireWildcard(e, t) {
                        if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap();
                        return (_interopRequireWildcard = function(e, t) {
                            if (!t && e && e.__esModule) return e;
                            var o, i, f = {
                                __proto__: null,
                                default: e
                            };
                            if (null === e || "object" != typeof e && "function" != typeof e) return f;
                            if (o = t ? n : r) {
                                if (o.has(e)) return o.get(e);
                                o.set(e, f);
                            }
                            for(const t in e)"default" !== t && ({}).hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);
                            return f;
                        })(e, t);
                    }
                    const getChildren = (arg, children = [])=>{
                        if (Array.isArray(arg)) for (const item of arg)getChildren(item, children);
                        else if (null != arg && false !== arg && '' !== arg) children.push(arg);
                        return children;
                    };
                    const getType = (element)=>{
                        const type = element.type;
                        if ('string' == typeof type) return type;
                        if ('function' == typeof type) return type.displayName || type.name || 'Unknown';
                        if (ReactIs.isFragment(element)) return 'React.Fragment';
                        if (ReactIs.isSuspense(element)) return 'React.Suspense';
                        if ('object' == typeof type && null !== type) {
                            if (ReactIs.isContextProvider(element)) return 'Context.Provider';
                            if (ReactIs.isContextConsumer(element)) return 'Context.Consumer';
                            if (ReactIs.isForwardRef(element)) {
                                if (type.displayName) return type.displayName;
                                const functionName = type.render.displayName || type.render.name || '';
                                return '' === functionName ? 'ForwardRef' : `ForwardRef(${functionName})`;
                            }
                            if (ReactIs.isMemo(element)) {
                                const functionName = type.displayName || type.type.displayName || type.type.name || '';
                                return '' === functionName ? 'Memo' : `Memo(${functionName})`;
                            }
                        }
                        return 'UNDEFINED';
                    };
                    const getPropKeys = (element)=>{
                        const { props } = element;
                        return Object.keys(props).filter((key)=>'children' !== key && void 0 !== props[key]).sort();
                    };
                    const serialize = (element, config, indentation, depth, refs, printer)=>++depth > config.maxDepth ? (0, _markup.printElementAsLeaf)(getType(element), config) : (0, _markup.printElement)(getType(element), (0, _markup.printProps)(getPropKeys(element), element.props, config, indentation + config.indent, depth, refs, printer), (0, _markup.printChildren)(getChildren(element.props.children), config, indentation + config.indent, depth, refs, printer), config, indentation);
                    exports.serialize = serialize;
                    const test = (val)=>null != val && ReactIs.isElement(val);
                    exports.test = test;
                    const plugin = {
                        serialize,
                        test
                    };
                    exports["default"] = plugin;
                },
                "./src/plugins/ReactTestComponent.ts": (__unused_webpack_module, exports, __nested_rspack_require_20800_20819__)=>{
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.test = exports.serialize = exports["default"] = void 0;
                    var _markup = __nested_rspack_require_20800_20819__("./src/plugins/lib/markup.ts");
                    var Symbol1 = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;
                    const testSymbol = 'function' == typeof Symbol1 && Symbol1.for ? Symbol1.for('react.test.json') : 0xea71357;
                    const getPropKeys = (object)=>{
                        const { props } = object;
                        return props ? Object.keys(props).filter((key)=>void 0 !== props[key]).sort() : [];
                    };
                    const serialize = (object, config, indentation, depth, refs, printer)=>++depth > config.maxDepth ? (0, _markup.printElementAsLeaf)(object.type, config) : (0, _markup.printElement)(object.type, object.props ? (0, _markup.printProps)(getPropKeys(object), object.props, config, indentation + config.indent, depth, refs, printer) : '', object.children ? (0, _markup.printChildren)(object.children, config, indentation + config.indent, depth, refs, printer) : '', config, indentation);
                    exports.serialize = serialize;
                    const test = (val)=>val && val.$$typeof === testSymbol;
                    exports.test = test;
                    const plugin = {
                        serialize,
                        test
                    };
                    exports["default"] = plugin;
                },
                "./src/plugins/lib/escapeHTML.ts": (__unused_webpack_module, exports)=>{
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports["default"] = escapeHTML;
                    function escapeHTML(str) {
                        return str.replaceAll('<', '&lt;').replaceAll('>', '&gt;');
                    }
                },
                "./src/plugins/lib/markup.ts": (__unused_webpack_module, exports, __nested_rspack_require_22882_22901__)=>{
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.printText = exports.printProps = exports.printElementAsLeaf = exports.printElement = exports.printComment = exports.printChildren = void 0;
                    var _escapeHTML = _interopRequireDefault(__nested_rspack_require_22882_22901__("./src/plugins/lib/escapeHTML.ts"));
                    function _interopRequireDefault(e) {
                        return e && e.__esModule ? e : {
                            default: e
                        };
                    }
                    const printProps = (keys, props, config, indentation, depth, refs, printer)=>{
                        const indentationNext = indentation + config.indent;
                        const colors = config.colors;
                        return keys.map((key)=>{
                            const value = props[key];
                            let printed = printer(value, config, indentationNext, depth, refs);
                            if ('string' != typeof value) {
                                if (printed.includes('\n')) printed = config.spacingOuter + indentationNext + printed + config.spacingOuter + indentation;
                                printed = `{${printed}}`;
                            }
                            return `${config.spacingInner + indentation + colors.prop.open + key + colors.prop.close}=${colors.value.open}${printed}${colors.value.close}`;
                        }).join('');
                    };
                    exports.printProps = printProps;
                    const printChildren = (children, config, indentation, depth, refs, printer)=>children.map((child)=>config.spacingOuter + indentation + ('string' == typeof child ? printText(child, config) : printer(child, config, indentation, depth, refs))).join('');
                    exports.printChildren = printChildren;
                    const printText = (text, config)=>{
                        const contentColor = config.colors.content;
                        return contentColor.open + (0, _escapeHTML.default)(text) + contentColor.close;
                    };
                    exports.printText = printText;
                    const printComment = (comment, config)=>{
                        const commentColor = config.colors.comment;
                        return `${commentColor.open}<!--${(0, _escapeHTML.default)(comment)}-->${commentColor.close}`;
                    };
                    exports.printComment = printComment;
                    const printElement = (type, printedProps, printedChildren, config, indentation)=>{
                        const tagColor = config.colors.tag;
                        return `${tagColor.open}<${type}${printedProps && tagColor.close + printedProps + config.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config.spacingOuter}${indentation}${tagColor.open}</${type}` : `${printedProps && !config.min ? '' : ' '}/`}>${tagColor.close}`;
                    };
                    exports.printElement = printElement;
                    const printElementAsLeaf = (type, config)=>{
                        const tagColor = config.colors.tag;
                        return `${tagColor.open}<${type}${tagColor.close} ${tagColor.open} />${tagColor.close}`;
                    };
                    exports.printElementAsLeaf = printElementAsLeaf;
                }
            };
            var __webpack_module_cache__ = {};
            function __nested_rspack_require_26234__(moduleId) {
                var cachedModule = __webpack_module_cache__[moduleId];
                if (void 0 !== cachedModule) return cachedModule.exports;
                var module = __webpack_module_cache__[moduleId] = {
                    exports: {}
                };
                __webpack_modules__[moduleId](module, module.exports, __nested_rspack_require_26234__);
                return module.exports;
            }
            var __nested_rspack_exports__ = {};
            (()=>{
                var exports = __nested_rspack_exports__;
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports["default"] = exports.DEFAULT_OPTIONS = void 0;
                exports.format = format;
                exports.plugins = void 0;
                var _ansiStyles = _interopRequireDefault(__webpack_require__("../../node_modules/.pnpm/ansi-styles@5.2.0/node_modules/ansi-styles/index.js"));
                var _collections = __nested_rspack_require_26234__("./src/collections.ts");
                var _AsymmetricMatcher = _interopRequireDefault(__nested_rspack_require_26234__("./src/plugins/AsymmetricMatcher.ts"));
                var _DOMCollection = _interopRequireDefault(__nested_rspack_require_26234__("./src/plugins/DOMCollection.ts"));
                var _DOMElement = _interopRequireDefault(__nested_rspack_require_26234__("./src/plugins/DOMElement.ts"));
                var _Immutable = _interopRequireDefault(__nested_rspack_require_26234__("./src/plugins/Immutable.ts"));
                var _ReactElement = _interopRequireDefault(__nested_rspack_require_26234__("./src/plugins/ReactElement.ts"));
                var _ReactTestComponent = _interopRequireDefault(__nested_rspack_require_26234__("./src/plugins/ReactTestComponent.ts"));
                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    };
                }
                const src_toString = Object.prototype.toString;
                const toISOString = Date.prototype.toISOString;
                const errorToString = Error.prototype.toString;
                const regExpToString = RegExp.prototype.toString;
                const getConstructorName = (val)=>'function' == typeof val.constructor && val.constructor.name || 'Object';
                const isWindow = (val)=>'undefined' != typeof window && val === window;
                const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
                const NEWLINE_REGEXP = /\n/gi;
                class PrettyFormatPluginError extends Error {
                    constructor(message, stack){
                        super(message);
                        this.stack = stack;
                        this.name = this.constructor.name;
                    }
                }
                function isToStringedArrayType(toStringed) {
                    return '[object Array]' === toStringed || '[object ArrayBuffer]' === toStringed || '[object DataView]' === toStringed || '[object Float32Array]' === toStringed || '[object Float64Array]' === toStringed || '[object Int8Array]' === toStringed || '[object Int16Array]' === toStringed || '[object Int32Array]' === toStringed || '[object Uint8Array]' === toStringed || '[object Uint8ClampedArray]' === toStringed || '[object Uint16Array]' === toStringed || '[object Uint32Array]' === toStringed;
                }
                function printNumber(val) {
                    return Object.is(val, -0) ? '-0' : String(val);
                }
                function printBigInt(val) {
                    return String(`${val}n`);
                }
                function printFunction(val, printFunctionName) {
                    if (!printFunctionName) return '[Function]';
                    return `[Function ${val.name || 'anonymous'}]`;
                }
                function printSymbol(val) {
                    return String(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
                }
                function printError(val) {
                    return `[${errorToString.call(val)}]`;
                }
                function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
                    if (true === val || false === val) return `${val}`;
                    if (void 0 === val) return 'undefined';
                    if (null === val) return 'null';
                    const typeOf = typeof val;
                    if ('number' === typeOf) return printNumber(val);
                    if ('bigint' === typeOf) return printBigInt(val);
                    if ('string' === typeOf) {
                        if (escapeString) return `"${val.replaceAll(/"|\\/g, '\\$&')}"`;
                        return `"${val}"`;
                    }
                    if ('function' === typeOf) return printFunction(val, printFunctionName);
                    if ('symbol' === typeOf) return printSymbol(val);
                    const toStringed = src_toString.call(val);
                    if ('[object Promise]' === toStringed) return 'Promise {}';
                    if ('[object WeakMap]' === toStringed) return 'WeakMap {}';
                    if ('[object WeakSet]' === toStringed) return 'WeakSet {}';
                    if ('[object Function]' === toStringed || '[object GeneratorFunction]' === toStringed) return printFunction(val, printFunctionName);
                    if ('[object Symbol]' === toStringed) return printSymbol(val);
                    if ('[object Date]' === toStringed) return Number.isNaN(+val) ? 'Date { NaN }' : toISOString.call(val);
                    if ('[object Error]' === toStringed) return printError(val);
                    if ('[object RegExp]' === toStringed) {
                        if (escapeRegex) return regExpToString.call(val).replaceAll(/[$()*+.?[\\\]^{|}]/g, '\\$&');
                        return regExpToString.call(val);
                    }
                    if (val instanceof Error) return printError(val);
                    return null;
                }
                function printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON) {
                    if (refs.includes(val)) return '[Circular]';
                    refs = [
                        ...refs
                    ];
                    refs.push(val);
                    const hitMaxDepth = ++depth > config.maxDepth;
                    const min = config.min;
                    if (config.callToJSON && !hitMaxDepth && val.toJSON && 'function' == typeof val.toJSON && !hasCalledToJSON) return printer(val.toJSON(), config, indentation, depth, refs, true);
                    const toStringed = src_toString.call(val);
                    if ('[object Arguments]' === toStringed) return hitMaxDepth ? '[Arguments]' : `${min ? '' : 'Arguments '}[${(0, _collections.printListItems)(val, config, indentation, depth, refs, printer)}]`;
                    if (isToStringedArrayType(toStringed)) return hitMaxDepth ? `[${val.constructor.name}]` : `${min ? '' : !config.printBasicPrototype && 'Array' === val.constructor.name ? '' : `${val.constructor.name} `}[${(0, _collections.printListItems)(val, config, indentation, depth, refs, printer)}]`;
                    if ('[object Map]' === toStringed) return hitMaxDepth ? '[Map]' : `Map {${(0, _collections.printIteratorEntries)(val.entries(), config, indentation, depth, refs, printer, ' => ')}}`;
                    if ('[object Set]' === toStringed) return hitMaxDepth ? '[Set]' : `Set {${(0, _collections.printIteratorValues)(val.values(), config, indentation, depth, refs, printer)}}`;
                    return hitMaxDepth || isWindow(val) ? `[${getConstructorName(val)}]` : `${min ? '' : !config.printBasicPrototype && 'Object' === getConstructorName(val) ? '' : `${getConstructorName(val)} `}{${(0, _collections.printObjectProperties)(val, config, indentation, depth, refs, printer)}}`;
                }
                function isNewPlugin(plugin) {
                    return null != plugin.serialize;
                }
                function printPlugin(plugin, val, config, indentation, depth, refs) {
                    let printed;
                    try {
                        printed = isNewPlugin(plugin) ? plugin.serialize(val, config, indentation, depth, refs, printer) : plugin.print(val, (valChild)=>printer(valChild, config, indentation, depth, refs), (str)=>{
                            const indentationNext = indentation + config.indent;
                            return indentationNext + str.replaceAll(NEWLINE_REGEXP, `\n${indentationNext}`);
                        }, {
                            edgeSpacing: config.spacingOuter,
                            min: config.min,
                            spacing: config.spacingInner
                        }, config.colors);
                    } catch (error) {
                        throw new PrettyFormatPluginError(error.message, error.stack);
                    }
                    if ('string' != typeof printed) throw new TypeError(`pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`);
                    return printed;
                }
                function findPlugin(plugins, val) {
                    for (const plugin of plugins)try {
                        if (plugin.test(val)) return plugin;
                    } catch (error) {
                        throw new PrettyFormatPluginError(error.message, error.stack);
                    }
                    return null;
                }
                function printer(val, config, indentation, depth, refs, hasCalledToJSON) {
                    const plugin = findPlugin(config.plugins, val);
                    if (null !== plugin) return printPlugin(plugin, val, config, indentation, depth, refs);
                    const basicResult = printBasicValue(val, config.printFunctionName, config.escapeRegex, config.escapeString);
                    if (null !== basicResult) return basicResult;
                    return printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON);
                }
                const DEFAULT_THEME = {
                    comment: 'gray',
                    content: 'reset',
                    prop: 'yellow',
                    tag: 'cyan',
                    value: 'green'
                };
                const DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
                const toOptionsSubtype = (options)=>options;
                const DEFAULT_OPTIONS = exports.DEFAULT_OPTIONS = toOptionsSubtype({
                    callToJSON: true,
                    compareKeys: void 0,
                    escapeRegex: false,
                    escapeString: true,
                    highlight: false,
                    indent: 2,
                    maxDepth: 1 / 0,
                    maxWidth: 1 / 0,
                    min: false,
                    plugins: [],
                    printBasicPrototype: true,
                    printFunctionName: true,
                    theme: DEFAULT_THEME
                });
                function validateOptions(options) {
                    for (const key of Object.keys(options))if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS, key)) throw new Error(`pretty-format: Unknown option "${key}".`);
                    if (options.min && void 0 !== options.indent && 0 !== options.indent) throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
                    if (void 0 !== options.theme) {
                        if (null === options.theme) throw new Error('pretty-format: Option "theme" must not be null.');
                        if ('object' != typeof options.theme) throw new TypeError(`pretty-format: Option "theme" must be of type "object" but instead received "${typeof options.theme}".`);
                    }
                }
                const getColorsHighlight = (options)=>DEFAULT_THEME_KEYS.reduce((colors, key)=>{
                        const value = options.theme && void 0 !== options.theme[key] ? options.theme[key] : DEFAULT_THEME[key];
                        const color = value && _ansiStyles.default[value];
                        if (color && 'string' == typeof color.close && 'string' == typeof color.open) colors[key] = color;
                        else throw new Error(`pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`);
                        return colors;
                    }, Object.create(null));
                const getColorsEmpty = ()=>DEFAULT_THEME_KEYS.reduce((colors, key)=>{
                        colors[key] = {
                            close: '',
                            open: ''
                        };
                        return colors;
                    }, Object.create(null));
                const getPrintFunctionName = (options)=>options?.printFunctionName ?? DEFAULT_OPTIONS.printFunctionName;
                const getEscapeRegex = (options)=>options?.escapeRegex ?? DEFAULT_OPTIONS.escapeRegex;
                const getEscapeString = (options)=>options?.escapeString ?? DEFAULT_OPTIONS.escapeString;
                const getConfig = (options)=>({
                        callToJSON: options?.callToJSON ?? DEFAULT_OPTIONS.callToJSON,
                        colors: options?.highlight ? getColorsHighlight(options) : getColorsEmpty(),
                        compareKeys: 'function' == typeof options?.compareKeys || options?.compareKeys === null ? options.compareKeys : DEFAULT_OPTIONS.compareKeys,
                        escapeRegex: getEscapeRegex(options),
                        escapeString: getEscapeString(options),
                        indent: options?.min ? '' : createIndent(options?.indent ?? DEFAULT_OPTIONS.indent),
                        maxDepth: options?.maxDepth ?? DEFAULT_OPTIONS.maxDepth,
                        maxWidth: options?.maxWidth ?? DEFAULT_OPTIONS.maxWidth,
                        min: options?.min ?? DEFAULT_OPTIONS.min,
                        plugins: options?.plugins ?? DEFAULT_OPTIONS.plugins,
                        printBasicPrototype: options?.printBasicPrototype ?? true,
                        printFunctionName: getPrintFunctionName(options),
                        spacingInner: options?.min ? ' ' : '\n',
                        spacingOuter: options?.min ? '' : '\n'
                    });
                function createIndent(indent) {
                    return Array.from({
                        length: indent + 1
                    }).join(' ');
                }
                function format(val, options) {
                    if (options) {
                        validateOptions(options);
                        if (options.plugins) {
                            const plugin = findPlugin(options.plugins, val);
                            if (null !== plugin) return printPlugin(plugin, val, getConfig(options), '', 0, []);
                        }
                    }
                    const basicResult = printBasicValue(val, getPrintFunctionName(options), getEscapeRegex(options), getEscapeString(options));
                    if (null !== basicResult) return basicResult;
                    return printComplexValue(val, getConfig(options), '', 0, []);
                }
                exports.plugins = {
                    AsymmetricMatcher: _AsymmetricMatcher.default,
                    DOMCollection: _DOMCollection.default,
                    DOMElement: _DOMElement.default,
                    Immutable: _Immutable.default,
                    ReactElement: _ReactElement.default,
                    ReactTestComponent: _ReactTestComponent.default
                };
                exports["default"] = format;
            })();
            module.exports = __nested_rspack_exports__;
        })();
    },
    "../../node_modules/.pnpm/react-is@18.3.1/node_modules/react-is/cjs/react-is.development.js" (__unused_rspack_module, exports) {
        /**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ if ("production" !== process.env.NODE_ENV) (function() {
            'use strict';
            var REACT_ELEMENT_TYPE = Symbol.for('react.element');
            var REACT_PORTAL_TYPE = Symbol.for('react.portal');
            var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
            var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
            var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
            var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
            var REACT_CONTEXT_TYPE = Symbol.for('react.context');
            var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
            var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
            var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
            var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
            var REACT_MEMO_TYPE = Symbol.for('react.memo');
            var REACT_LAZY_TYPE = Symbol.for('react.lazy');
            var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
            var enableScopeAPI = false;
            var enableCacheElement = false;
            var enableTransitionTracing = false;
            var enableLegacyHidden = false;
            var enableDebugTracing = false;
            var REACT_MODULE_REFERENCE;
            REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
            function isValidElementType(type) {
                if ('string' == typeof type || 'function' == typeof type) return true;
                if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) return true;
                if ('object' == typeof type && null !== type) {
                    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || void 0 !== type.getModuleId) return true;
                }
                return false;
            }
            function typeOf(object) {
                if ('object' == typeof object && null !== object) {
                    var $$typeof = object.$$typeof;
                    switch($$typeof){
                        case REACT_ELEMENT_TYPE:
                            var type = object.type;
                            switch(type){
                                case REACT_FRAGMENT_TYPE:
                                case REACT_PROFILER_TYPE:
                                case REACT_STRICT_MODE_TYPE:
                                case REACT_SUSPENSE_TYPE:
                                case REACT_SUSPENSE_LIST_TYPE:
                                    return type;
                                default:
                                    var $$typeofType = type && type.$$typeof;
                                    switch($$typeofType){
                                        case REACT_SERVER_CONTEXT_TYPE:
                                        case REACT_CONTEXT_TYPE:
                                        case REACT_FORWARD_REF_TYPE:
                                        case REACT_LAZY_TYPE:
                                        case REACT_MEMO_TYPE:
                                        case REACT_PROVIDER_TYPE:
                                            return $$typeofType;
                                        default:
                                            return $$typeof;
                                    }
                            }
                        case REACT_PORTAL_TYPE:
                            return $$typeof;
                    }
                }
            }
            var ContextConsumer = REACT_CONTEXT_TYPE;
            var ContextProvider = REACT_PROVIDER_TYPE;
            var Element = REACT_ELEMENT_TYPE;
            var ForwardRef = REACT_FORWARD_REF_TYPE;
            var Fragment = REACT_FRAGMENT_TYPE;
            var Lazy = REACT_LAZY_TYPE;
            var Memo = REACT_MEMO_TYPE;
            var Portal = REACT_PORTAL_TYPE;
            var Profiler = REACT_PROFILER_TYPE;
            var StrictMode = REACT_STRICT_MODE_TYPE;
            var Suspense = REACT_SUSPENSE_TYPE;
            var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
            var hasWarnedAboutDeprecatedIsAsyncMode = false;
            var hasWarnedAboutDeprecatedIsConcurrentMode = false;
            function isAsyncMode(object) {
                if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                    hasWarnedAboutDeprecatedIsAsyncMode = true;
                    console['warn']("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
                }
                return false;
            }
            function isConcurrentMode(object) {
                if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
                    hasWarnedAboutDeprecatedIsConcurrentMode = true;
                    console['warn']("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
                }
                return false;
            }
            function isContextConsumer(object) {
                return typeOf(object) === REACT_CONTEXT_TYPE;
            }
            function isContextProvider(object) {
                return typeOf(object) === REACT_PROVIDER_TYPE;
            }
            function isElement(object) {
                return 'object' == typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
            }
            function isForwardRef(object) {
                return typeOf(object) === REACT_FORWARD_REF_TYPE;
            }
            function isFragment(object) {
                return typeOf(object) === REACT_FRAGMENT_TYPE;
            }
            function isLazy(object) {
                return typeOf(object) === REACT_LAZY_TYPE;
            }
            function isMemo(object) {
                return typeOf(object) === REACT_MEMO_TYPE;
            }
            function isPortal(object) {
                return typeOf(object) === REACT_PORTAL_TYPE;
            }
            function isProfiler(object) {
                return typeOf(object) === REACT_PROFILER_TYPE;
            }
            function isStrictMode(object) {
                return typeOf(object) === REACT_STRICT_MODE_TYPE;
            }
            function isSuspense(object) {
                return typeOf(object) === REACT_SUSPENSE_TYPE;
            }
            function isSuspenseList(object) {
                return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
            }
            exports.ContextConsumer = ContextConsumer;
            exports.ContextProvider = ContextProvider;
            exports.Element = Element;
            exports.ForwardRef = ForwardRef;
            exports.Fragment = Fragment;
            exports.Lazy = Lazy;
            exports.Memo = Memo;
            exports.Portal = Portal;
            exports.Profiler = Profiler;
            exports.StrictMode = StrictMode;
            exports.Suspense = Suspense;
            exports.SuspenseList = SuspenseList;
            exports.isAsyncMode = isAsyncMode;
            exports.isConcurrentMode = isConcurrentMode;
            exports.isContextConsumer = isContextConsumer;
            exports.isContextProvider = isContextProvider;
            exports.isElement = isElement;
            exports.isForwardRef = isForwardRef;
            exports.isFragment = isFragment;
            exports.isLazy = isLazy;
            exports.isMemo = isMemo;
            exports.isPortal = isPortal;
            exports.isProfiler = isProfiler;
            exports.isStrictMode = isStrictMode;
            exports.isSuspense = isSuspense;
            exports.isSuspenseList = isSuspenseList;
            exports.isValidElementType = isValidElementType;
            exports.typeOf = typeOf;
        })();
    },
    "../../node_modules/.pnpm/react-is@18.3.1/node_modules/react-is/cjs/react-is.production.min.js" (__unused_rspack_module, exports) {
        /**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u;
        u = Symbol.for("react.module.reference");
        function v(a) {
            if ("object" == typeof a && null !== a) {
                var r = a.$$typeof;
                switch(r){
                    case b:
                        switch(a = a.type){
                            case d:
                            case f:
                            case e:
                            case m:
                            case n:
                                return a;
                            default:
                                switch(a = a && a.$$typeof){
                                    case k:
                                    case h:
                                    case l:
                                    case q:
                                    case p:
                                    case g:
                                        return a;
                                    default:
                                        return r;
                                }
                        }
                    case c:
                        return r;
                }
            }
        }
        exports.ContextConsumer = h;
        exports.ContextProvider = g;
        exports.Element = b;
        exports.ForwardRef = l;
        exports.Fragment = d;
        exports.Lazy = q;
        exports.Memo = p;
        exports.Portal = c;
        exports.Profiler = f;
        exports.StrictMode = e;
        exports.Suspense = m;
        exports.SuspenseList = n;
        exports.isAsyncMode = function() {
            return !1;
        };
        exports.isConcurrentMode = function() {
            return !1;
        };
        exports.isContextConsumer = function(a) {
            return v(a) === h;
        };
        exports.isContextProvider = function(a) {
            return v(a) === g;
        };
        exports.isElement = function(a) {
            return "object" == typeof a && null !== a && a.$$typeof === b;
        };
        exports.isForwardRef = function(a) {
            return v(a) === l;
        };
        exports.isFragment = function(a) {
            return v(a) === d;
        };
        exports.isLazy = function(a) {
            return v(a) === q;
        };
        exports.isMemo = function(a) {
            return v(a) === p;
        };
        exports.isPortal = function(a) {
            return v(a) === c;
        };
        exports.isProfiler = function(a) {
            return v(a) === f;
        };
        exports.isStrictMode = function(a) {
            return v(a) === e;
        };
        exports.isSuspense = function(a) {
            return v(a) === m;
        };
        exports.isSuspenseList = function(a) {
            return v(a) === n;
        };
        exports.isValidElementType = function(a) {
            return "string" == typeof a || "function" == typeof a || a === d || a === f || a === e || a === m || a === n || a === t || "object" == typeof a && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === u || void 0 !== a.getModuleId);
        };
        exports.typeOf = v;
    },
    "../../node_modules/.pnpm/react-is@18.3.1/node_modules/react-is/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        if ('production' === process.env.NODE_ENV) module.exports = __webpack_require__("../../node_modules/.pnpm/react-is@18.3.1/node_modules/react-is/cjs/react-is.production.min.js");
        else module.exports = __webpack_require__("../../node_modules/.pnpm/react-is@18.3.1/node_modules/react-is/cjs/react-is.development.js");
    },
    "../../node_modules/.pnpm/source-map-support@0.5.21/node_modules/source-map-support/source-map-support.js" (module, exports, __webpack_require__) {
        module = __webpack_require__.nmd(module);
        var SourceMapConsumer = __webpack_require__("../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/source-map.js").SourceMapConsumer;
        var path = __webpack_require__("node:path");
        var fs;
        try {
            fs = __webpack_require__("fs");
            if (!fs.existsSync || !fs.readFileSync) fs = null;
        } catch (err) {}
        var bufferFrom = __webpack_require__("../../node_modules/.pnpm/buffer-from@1.1.2/node_modules/buffer-from/index.js");
        function dynamicRequire(mod, request) {
            return mod.require(request);
        }
        var errorFormatterInstalled = false;
        var uncaughtShimInstalled = false;
        var emptyCacheBetweenOperations = false;
        var environment = "auto";
        var fileContentsCache = {};
        var sourceMapCache = {};
        var reSourceMap = /^data:application\/json[^,]+base64,/;
        var retrieveFileHandlers = [];
        var retrieveMapHandlers = [];
        function isInBrowser() {
            if ("browser" === environment) return true;
            if ("node" === environment) return false;
            return 'undefined' != typeof window && 'function' == typeof XMLHttpRequest && !(window.require && window.module && window.process && "renderer" === window.process.type);
        }
        function hasGlobalProcessEventEmitter() {
            return 'object' == typeof process && null !== process && 'function' == typeof process.on;
        }
        function globalProcessVersion() {
            if ('object' == typeof process && null !== process) return process.version;
            return '';
        }
        function globalProcessStderr() {
            if ('object' == typeof process && null !== process) return process.stderr;
        }
        function globalProcessExit(code) {
            if ('object' == typeof process && null !== process && 'function' == typeof process.exit) return process.exit(code);
        }
        function handlerExec(list) {
            return function(arg) {
                for(var i = 0; i < list.length; i++){
                    var ret = list[i](arg);
                    if (ret) return ret;
                }
                return null;
            };
        }
        var retrieveFile = handlerExec(retrieveFileHandlers);
        retrieveFileHandlers.push(function(path) {
            path = path.trim();
            if (/^file:/.test(path)) path = path.replace(/file:\/\/\/(\w:)?/, function(protocol, drive) {
                return drive ? '' : '/';
            });
            if (path in fileContentsCache) return fileContentsCache[path];
            var contents = '';
            try {
                if (fs) {
                    if (fs.existsSync(path)) contents = fs.readFileSync(path, 'utf8');
                } else {
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', path, false);
                    xhr.send(null);
                    if (4 === xhr.readyState && 200 === xhr.status) contents = xhr.responseText;
                }
            } catch (er) {}
            return fileContentsCache[path] = contents;
        });
        function supportRelativeURL(file, url) {
            if (!file) return url;
            var dir = path.dirname(file);
            var match = /^\w+:\/\/[^\/]*/.exec(dir);
            var protocol = match ? match[0] : '';
            var startPath = dir.slice(protocol.length);
            if (protocol && /^\/\w\:/.test(startPath)) {
                protocol += '/';
                return protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\/g, '/');
            }
            return protocol + path.resolve(dir.slice(protocol.length), url);
        }
        function retrieveSourceMapURL(source) {
            var fileData;
            if (isInBrowser()) try {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', source, false);
                xhr.send(null);
                fileData = 4 === xhr.readyState ? xhr.responseText : null;
                var sourceMapHeader = xhr.getResponseHeader("SourceMap") || xhr.getResponseHeader("X-SourceMap");
                if (sourceMapHeader) return sourceMapHeader;
            } catch (e) {}
            fileData = retrieveFile(source);
            var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg;
            var lastMatch, match;
            while(match = re.exec(fileData))lastMatch = match;
            if (!lastMatch) return null;
            return lastMatch[1];
        }
        var retrieveSourceMap = handlerExec(retrieveMapHandlers);
        retrieveMapHandlers.push(function(source) {
            var sourceMappingURL = retrieveSourceMapURL(source);
            if (!sourceMappingURL) return null;
            var sourceMapData;
            if (reSourceMap.test(sourceMappingURL)) {
                var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);
                sourceMapData = bufferFrom(rawData, "base64").toString();
                sourceMappingURL = source;
            } else {
                sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
                sourceMapData = retrieveFile(sourceMappingURL);
            }
            if (!sourceMapData) return null;
            return {
                url: sourceMappingURL,
                map: sourceMapData
            };
        });
        function mapSourcePosition(position) {
            var sourceMap = sourceMapCache[position.source];
            if (!sourceMap) {
                var urlAndMap = retrieveSourceMap(position.source);
                if (urlAndMap) {
                    sourceMap = sourceMapCache[position.source] = {
                        url: urlAndMap.url,
                        map: new SourceMapConsumer(urlAndMap.map)
                    };
                    if (sourceMap.map.sourcesContent) sourceMap.map.sources.forEach(function(source, i) {
                        var contents = sourceMap.map.sourcesContent[i];
                        if (contents) {
                            var url = supportRelativeURL(sourceMap.url, source);
                            fileContentsCache[url] = contents;
                        }
                    });
                } else sourceMap = sourceMapCache[position.source] = {
                    url: null,
                    map: null
                };
            }
            if (sourceMap && sourceMap.map && 'function' == typeof sourceMap.map.originalPositionFor) {
                var originalPosition = sourceMap.map.originalPositionFor(position);
                if (null !== originalPosition.source) {
                    originalPosition.source = supportRelativeURL(sourceMap.url, originalPosition.source);
                    return originalPosition;
                }
            }
            return position;
        }
        function mapEvalOrigin(origin) {
            var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
            if (match) {
                var position = mapSourcePosition({
                    source: match[2],
                    line: +match[3],
                    column: match[4] - 1
                });
                return 'eval at ' + match[1] + ' (' + position.source + ':' + position.line + ':' + (position.column + 1) + ')';
            }
            match = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
            if (match) return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';
            return origin;
        }
        function CallSiteToString() {
            var fileName;
            var fileLocation = "";
            if (this.isNative()) fileLocation = "native";
            else {
                fileName = this.getScriptNameOrSourceURL();
                if (!fileName && this.isEval()) {
                    fileLocation = this.getEvalOrigin();
                    fileLocation += ", ";
                }
                if (fileName) fileLocation += fileName;
                else fileLocation += "<anonymous>";
                var lineNumber = this.getLineNumber();
                if (null != lineNumber) {
                    fileLocation += ":" + lineNumber;
                    var columnNumber = this.getColumnNumber();
                    if (columnNumber) fileLocation += ":" + columnNumber;
                }
            }
            var line = "";
            var functionName = this.getFunctionName();
            var addSuffix = true;
            var isConstructor = this.isConstructor();
            var isMethodCall = !(this.isToplevel() || isConstructor);
            if (isMethodCall) {
                var typeName = this.getTypeName();
                if ("[object Object]" === typeName) typeName = "null";
                var methodName = this.getMethodName();
                if (functionName) {
                    if (typeName && 0 != functionName.indexOf(typeName)) line += typeName + ".";
                    line += functionName;
                    if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1) line += " [as " + methodName + "]";
                } else line += typeName + "." + (methodName || "<anonymous>");
            } else if (isConstructor) line += "new " + (functionName || "<anonymous>");
            else if (functionName) line += functionName;
            else {
                line += fileLocation;
                addSuffix = false;
            }
            if (addSuffix) line += " (" + fileLocation + ")";
            return line;
        }
        function cloneCallSite(frame) {
            var object = {};
            Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
                object[name] = /^(?:is|get)/.test(name) ? function() {
                    return frame[name].call(frame);
                } : frame[name];
            });
            object.toString = CallSiteToString;
            return object;
        }
        function wrapCallSite(frame, state) {
            if (void 0 === state) state = {
                nextPosition: null,
                curPosition: null
            };
            if (frame.isNative()) {
                state.curPosition = null;
                return frame;
            }
            var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
            if (source) {
                var line = frame.getLineNumber();
                var column = frame.getColumnNumber() - 1;
                var noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/;
                var headerLength = noHeader.test(globalProcessVersion()) ? 0 : 62;
                if (1 === line && column > headerLength && !isInBrowser() && !frame.isEval()) column -= headerLength;
                var position = mapSourcePosition({
                    source: source,
                    line: line,
                    column: column
                });
                state.curPosition = position;
                frame = cloneCallSite(frame);
                var originalFunctionName = frame.getFunctionName;
                frame.getFunctionName = function() {
                    if (null == state.nextPosition) return originalFunctionName();
                    return state.nextPosition.name || originalFunctionName();
                };
                frame.getFileName = function() {
                    return position.source;
                };
                frame.getLineNumber = function() {
                    return position.line;
                };
                frame.getColumnNumber = function() {
                    return position.column + 1;
                };
                frame.getScriptNameOrSourceURL = function() {
                    return position.source;
                };
                return frame;
            }
            var origin = frame.isEval() && frame.getEvalOrigin();
            if (origin) {
                origin = mapEvalOrigin(origin);
                frame = cloneCallSite(frame);
                frame.getEvalOrigin = function() {
                    return origin;
                };
            }
            return frame;
        }
        function prepareStackTrace(error, stack) {
            if (emptyCacheBetweenOperations) {
                fileContentsCache = {};
                sourceMapCache = {};
            }
            var name = error.name || 'Error';
            var message = error.message || '';
            var errorString = name + ": " + message;
            var state = {
                nextPosition: null,
                curPosition: null
            };
            var processedStack = [];
            for(var i = stack.length - 1; i >= 0; i--){
                processedStack.push('\n    at ' + wrapCallSite(stack[i], state));
                state.nextPosition = state.curPosition;
            }
            state.curPosition = state.nextPosition = null;
            return errorString + processedStack.reverse().join('');
        }
        function getErrorSource(error) {
            var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
            if (match) {
                var source = match[1];
                var line = +match[2];
                var column = +match[3];
                var contents = fileContentsCache[source];
                if (!contents && fs && fs.existsSync(source)) try {
                    contents = fs.readFileSync(source, 'utf8');
                } catch (er) {
                    contents = '';
                }
                if (contents) {
                    var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
                    if (code) return source + ':' + line + '\n' + code + '\n' + new Array(column).join(' ') + '^';
                }
            }
            return null;
        }
        function printErrorAndExit(error) {
            var source = getErrorSource(error);
            var stderr = globalProcessStderr();
            if (stderr && stderr._handle && stderr._handle.setBlocking) stderr._handle.setBlocking(true);
            if (source) {
                console.error();
                console.error(source);
            }
            console.error(error.stack);
            globalProcessExit(1);
        }
        function shimEmitUncaughtException() {
            var origEmit = process.emit;
            process.emit = function(type) {
                if ('uncaughtException' === type) {
                    var hasStack = arguments[1] && arguments[1].stack;
                    var hasListeners = this.listeners(type).length > 0;
                    if (hasStack && !hasListeners) return printErrorAndExit(arguments[1]);
                }
                return origEmit.apply(this, arguments);
            };
        }
        var originalRetrieveFileHandlers = retrieveFileHandlers.slice(0);
        var originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);
        exports.wrapCallSite = wrapCallSite;
        exports.getErrorSource = getErrorSource;
        exports.mapSourcePosition = mapSourcePosition;
        exports.retrieveSourceMap = retrieveSourceMap;
        exports.install = function(options) {
            options = options || {};
            if (options.environment) {
                environment = options.environment;
                if (-1 === [
                    "node",
                    "browser",
                    "auto"
                ].indexOf(environment)) throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}");
            }
            if (options.retrieveFile) {
                if (options.overrideRetrieveFile) retrieveFileHandlers.length = 0;
                retrieveFileHandlers.unshift(options.retrieveFile);
            }
            if (options.retrieveSourceMap) {
                if (options.overrideRetrieveSourceMap) retrieveMapHandlers.length = 0;
                retrieveMapHandlers.unshift(options.retrieveSourceMap);
            }
            if (options.hookRequire && !isInBrowser()) {
                var Module = dynamicRequire(module, 'module');
                var $compile = Module.prototype._compile;
                if (!$compile.__sourceMapSupport) {
                    Module.prototype._compile = function(content, filename) {
                        fileContentsCache[filename] = content;
                        sourceMapCache[filename] = void 0;
                        return $compile.call(this, content, filename);
                    };
                    Module.prototype._compile.__sourceMapSupport = true;
                }
            }
            if (!emptyCacheBetweenOperations) emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ? options.emptyCacheBetweenOperations : false;
            if (!errorFormatterInstalled) {
                errorFormatterInstalled = true;
                Error.prepareStackTrace = prepareStackTrace;
            }
            if (!uncaughtShimInstalled) {
                var installHandler = 'handleUncaughtExceptions' in options ? options.handleUncaughtExceptions : true;
                try {
                    var worker_threads = dynamicRequire(module, 'worker_threads');
                    if (false === worker_threads.isMainThread) installHandler = false;
                } catch (e) {}
                if (installHandler && hasGlobalProcessEventEmitter()) {
                    uncaughtShimInstalled = true;
                    shimEmitUncaughtException();
                }
            }
        };
        exports.resetRetrieveHandlers = function() {
            retrieveFileHandlers.length = 0;
            retrieveMapHandlers.length = 0;
            retrieveFileHandlers = originalRetrieveFileHandlers.slice(0);
            retrieveMapHandlers = originalRetrieveMapHandlers.slice(0);
            retrieveSourceMap = handlerExec(retrieveMapHandlers);
            retrieveFile = handlerExec(retrieveFileHandlers);
        };
    },
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js" (__unused_rspack_module, exports, __webpack_require__) {
        var util = __webpack_require__("../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js");
        var has = Object.prototype.hasOwnProperty;
        var hasNativeMap = "undefined" != typeof Map;
        function ArraySet() {
            this._array = [];
            this._set = hasNativeMap ? new Map() : Object.create(null);
        }
        ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
            var set = new ArraySet();
            for(var i = 0, len = aArray.length; i < len; i++)set.add(aArray[i], aAllowDuplicates);
            return set;
        };
        ArraySet.prototype.size = function ArraySet_size() {
            return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
        };
        ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
            var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
            var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
            var idx = this._array.length;
            if (!isDuplicate || aAllowDuplicates) this._array.push(aStr);
            if (!isDuplicate) if (hasNativeMap) this._set.set(aStr, idx);
            else this._set[sStr] = idx;
        };
        ArraySet.prototype.has = function ArraySet_has(aStr) {
            if (hasNativeMap) return this._set.has(aStr);
            var sStr = util.toSetString(aStr);
            return has.call(this._set, sStr);
        };
        ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
            if (hasNativeMap) {
                var idx = this._set.get(aStr);
                if (idx >= 0) return idx;
            } else {
                var sStr = util.toSetString(aStr);
                if (has.call(this._set, sStr)) return this._set[sStr];
            }
            throw new Error('"' + aStr + '" is not in the set.');
        };
        ArraySet.prototype.at = function ArraySet_at(aIdx) {
            if (aIdx >= 0 && aIdx < this._array.length) return this._array[aIdx];
            throw new Error('No element indexed by ' + aIdx);
        };
        ArraySet.prototype.toArray = function ArraySet_toArray() {
            return this._array.slice();
        };
        exports.ArraySet = ArraySet;
    },
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js" (__unused_rspack_module, exports, __webpack_require__) {
        var base64 = __webpack_require__("../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js");
        var VLQ_BASE_SHIFT = 5;
        var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
        var VLQ_BASE_MASK = VLQ_BASE - 1;
        var VLQ_CONTINUATION_BIT = VLQ_BASE;
        function toVLQSigned(aValue) {
            return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
        }
        function fromVLQSigned(aValue) {
            var isNegative = (1 & aValue) === 1;
            var shifted = aValue >> 1;
            return isNegative ? -shifted : shifted;
        }
        exports.encode = function base64VLQ_encode(aValue) {
            var encoded = "";
            var digit;
            var vlq = toVLQSigned(aValue);
            do {
                digit = vlq & VLQ_BASE_MASK;
                vlq >>>= VLQ_BASE_SHIFT;
                if (vlq > 0) digit |= VLQ_CONTINUATION_BIT;
                encoded += base64.encode(digit);
            }while (vlq > 0);
            return encoded;
        };
        exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
            var strLen = aStr.length;
            var result = 0;
            var shift = 0;
            var continuation, digit;
            do {
                if (aIndex >= strLen) throw new Error("Expected more digits in base 64 VLQ value.");
                digit = base64.decode(aStr.charCodeAt(aIndex++));
                if (-1 === digit) throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
                continuation = !!(digit & VLQ_CONTINUATION_BIT);
                digit &= VLQ_BASE_MASK;
                result += digit << shift;
                shift += VLQ_BASE_SHIFT;
            }while (continuation);
            aOutParam.value = fromVLQSigned(result);
            aOutParam.rest = aIndex;
        };
    },
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js" (__unused_rspack_module, exports) {
        var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
        exports.encode = function(number) {
            if (0 <= number && number < intToCharMap.length) return intToCharMap[number];
            throw new TypeError("Must be between 0 and 63: " + number);
        };
        exports.decode = function(charCode) {
            var bigA = 65;
            var bigZ = 90;
            var littleA = 97;
            var littleZ = 122;
            var zero = 48;
            var nine = 57;
            var plus = 43;
            var slash = 47;
            var littleOffset = 26;
            var numberOffset = 52;
            if (bigA <= charCode && charCode <= bigZ) return charCode - bigA;
            if (littleA <= charCode && charCode <= littleZ) return charCode - littleA + littleOffset;
            if (zero <= charCode && charCode <= nine) return charCode - zero + numberOffset;
            if (charCode == plus) return 62;
            if (charCode == slash) return 63;
            return -1;
        };
    },
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/binary-search.js" (__unused_rspack_module, exports) {
        exports.GREATEST_LOWER_BOUND = 1;
        exports.LEAST_UPPER_BOUND = 2;
        function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
            var mid = Math.floor((aHigh - aLow) / 2) + aLow;
            var cmp = aCompare(aNeedle, aHaystack[mid], true);
            if (0 === cmp) return mid;
            if (cmp > 0) {
                if (aHigh - mid > 1) return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
                if (aBias == exports.LEAST_UPPER_BOUND) return aHigh < aHaystack.length ? aHigh : -1;
                return mid;
            }
            if (mid - aLow > 1) return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
            if (aBias == exports.LEAST_UPPER_BOUND) return mid;
            return aLow < 0 ? -1 : aLow;
        }
        exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
            if (0 === aHaystack.length) return -1;
            var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
            if (index < 0) return -1;
            while(index - 1 >= 0){
                if (0 !== aCompare(aHaystack[index], aHaystack[index - 1], true)) break;
                --index;
            }
            return index;
        };
    },
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js" (__unused_rspack_module, exports, __webpack_require__) {
        var util = __webpack_require__("../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js");
        function generatedPositionAfter(mappingA, mappingB) {
            var lineA = mappingA.generatedLine;
            var lineB = mappingB.generatedLine;
            var columnA = mappingA.generatedColumn;
            var columnB = mappingB.generatedColumn;
            return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
        }
        function MappingList() {
            this._array = [];
            this._sorted = true;
            this._last = {
                generatedLine: -1,
                generatedColumn: 0
            };
        }
        MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
            this._array.forEach(aCallback, aThisArg);
        };
        MappingList.prototype.add = function MappingList_add(aMapping) {
            if (generatedPositionAfter(this._last, aMapping)) {
                this._last = aMapping;
                this._array.push(aMapping);
            } else {
                this._sorted = false;
                this._array.push(aMapping);
            }
        };
        MappingList.prototype.toArray = function MappingList_toArray() {
            if (!this._sorted) {
                this._array.sort(util.compareByGeneratedPositionsInflated);
                this._sorted = true;
            }
            return this._array;
        };
        exports.MappingList = MappingList;
    },
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/quick-sort.js" (__unused_rspack_module, exports) {
        function swap(ary, x, y) {
            var temp = ary[x];
            ary[x] = ary[y];
            ary[y] = temp;
        }
        function randomIntInRange(low, high) {
            return Math.round(low + Math.random() * (high - low));
        }
        function doQuickSort(ary, comparator, p, r) {
            if (p < r) {
                var pivotIndex = randomIntInRange(p, r);
                var i = p - 1;
                swap(ary, pivotIndex, r);
                var pivot = ary[r];
                for(var j = p; j < r; j++)if (comparator(ary[j], pivot) <= 0) {
                    i += 1;
                    swap(ary, i, j);
                }
                swap(ary, i + 1, j);
                var q = i + 1;
                doQuickSort(ary, comparator, p, q - 1);
                doQuickSort(ary, comparator, q + 1, r);
            }
        }
        exports.quickSort = function(ary, comparator) {
            doQuickSort(ary, comparator, 0, ary.length - 1);
        };
    },
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-consumer.js" (__unused_rspack_module, exports, __webpack_require__) {
        var util = __webpack_require__("../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js");
        var binarySearch = __webpack_require__("../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/binary-search.js");
        var ArraySet = __webpack_require__("../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js").ArraySet;
        var base64VLQ = __webpack_require__("../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js");
        var quickSort = __webpack_require__("../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/quick-sort.js").quickSort;
        function SourceMapConsumer(aSourceMap, aSourceMapURL) {
            var sourceMap = aSourceMap;
            if ('string' == typeof aSourceMap) sourceMap = util.parseSourceMapInput(aSourceMap);
            return null != sourceMap.sections ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
        }
        SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
            return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
        };
        SourceMapConsumer.prototype._version = 3;
        SourceMapConsumer.prototype.__generatedMappings = null;
        Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
            configurable: true,
            enumerable: true,
            get: function() {
                if (!this.__generatedMappings) this._parseMappings(this._mappings, this.sourceRoot);
                return this.__generatedMappings;
            }
        });
        SourceMapConsumer.prototype.__originalMappings = null;
        Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
            configurable: true,
            enumerable: true,
            get: function() {
                if (!this.__originalMappings) this._parseMappings(this._mappings, this.sourceRoot);
                return this.__originalMappings;
            }
        });
        SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
            var c = aStr.charAt(index);
            return ";" === c || "," === c;
        };
        SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
            throw new Error("Subclasses must implement _parseMappings");
        };
        SourceMapConsumer.GENERATED_ORDER = 1;
        SourceMapConsumer.ORIGINAL_ORDER = 2;
        SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
        SourceMapConsumer.LEAST_UPPER_BOUND = 2;
        SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
            var context = aContext || null;
            var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
            var mappings;
            switch(order){
                case SourceMapConsumer.GENERATED_ORDER:
                    mappings = this._generatedMappings;
                    break;
                case SourceMapConsumer.ORIGINAL_ORDER:
                    mappings = this._originalMappings;
                    break;
                default:
                    throw new Error("Unknown order of iteration.");
            }
            var sourceRoot = this.sourceRoot;
            mappings.map(function(mapping) {
                var source = null === mapping.source ? null : this._sources.at(mapping.source);
                source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
                return {
                    source: source,
                    generatedLine: mapping.generatedLine,
                    generatedColumn: mapping.generatedColumn,
                    originalLine: mapping.originalLine,
                    originalColumn: mapping.originalColumn,
                    name: null === mapping.name ? null : this._names.at(mapping.name)
                };
            }, this).forEach(aCallback, context);
        };
        SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
            var line = util.getArg(aArgs, 'line');
            var needle = {
                source: util.getArg(aArgs, 'source'),
                originalLine: line,
                originalColumn: util.getArg(aArgs, 'column', 0)
            };
            needle.source = this._findSourceIndex(needle.source);
            if (needle.source < 0) return [];
            var mappings = [];
            var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
            if (index >= 0) {
                var mapping = this._originalMappings[index];
                if (void 0 === aArgs.column) {
                    var originalLine = mapping.originalLine;
                    while(mapping && mapping.originalLine === originalLine){
                        mappings.push({
                            line: util.getArg(mapping, 'generatedLine', null),
                            column: util.getArg(mapping, 'generatedColumn', null),
                            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                        });
                        mapping = this._originalMappings[++index];
                    }
                } else {
                    var originalColumn = mapping.originalColumn;
                    while(mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn){
                        mappings.push({
                            line: util.getArg(mapping, 'generatedLine', null),
                            column: util.getArg(mapping, 'generatedColumn', null),
                            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                        });
                        mapping = this._originalMappings[++index];
                    }
                }
            }
            return mappings;
        };
        exports.SourceMapConsumer = SourceMapConsumer;
        function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
            var sourceMap = aSourceMap;
            if ('string' == typeof aSourceMap) sourceMap = util.parseSourceMapInput(aSourceMap);
            var version = util.getArg(sourceMap, 'version');
            var sources = util.getArg(sourceMap, 'sources');
            var names = util.getArg(sourceMap, 'names', []);
            var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
            var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
            var mappings = util.getArg(sourceMap, 'mappings');
            var file = util.getArg(sourceMap, 'file', null);
            if (version != this._version) throw new Error('Unsupported version: ' + version);
            if (sourceRoot) sourceRoot = util.normalize(sourceRoot);
            sources = sources.map(String).map(util.normalize).map(function(source) {
                return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
            });
            this._names = ArraySet.fromArray(names.map(String), true);
            this._sources = ArraySet.fromArray(sources, true);
            this._absoluteSources = this._sources.toArray().map(function(s) {
                return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
            });
            this.sourceRoot = sourceRoot;
            this.sourcesContent = sourcesContent;
            this._mappings = mappings;
            this._sourceMapURL = aSourceMapURL;
            this.file = file;
        }
        BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
        BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
        BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
            var relativeSource = aSource;
            if (null != this.sourceRoot) relativeSource = util.relative(this.sourceRoot, relativeSource);
            if (this._sources.has(relativeSource)) return this._sources.indexOf(relativeSource);
            var i;
            for(i = 0; i < this._absoluteSources.length; ++i)if (this._absoluteSources[i] == aSource) return i;
            return -1;
        };
        BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
            var smc = Object.create(BasicSourceMapConsumer.prototype);
            var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
            var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
            smc.sourceRoot = aSourceMap._sourceRoot;
            smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
            smc.file = aSourceMap._file;
            smc._sourceMapURL = aSourceMapURL;
            smc._absoluteSources = smc._sources.toArray().map(function(s) {
                return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
            });
            var generatedMappings = aSourceMap._mappings.toArray().slice();
            var destGeneratedMappings = smc.__generatedMappings = [];
            var destOriginalMappings = smc.__originalMappings = [];
            for(var i = 0, length = generatedMappings.length; i < length; i++){
                var srcMapping = generatedMappings[i];
                var destMapping = new Mapping;
                destMapping.generatedLine = srcMapping.generatedLine;
                destMapping.generatedColumn = srcMapping.generatedColumn;
                if (srcMapping.source) {
                    destMapping.source = sources.indexOf(srcMapping.source);
                    destMapping.originalLine = srcMapping.originalLine;
                    destMapping.originalColumn = srcMapping.originalColumn;
                    if (srcMapping.name) destMapping.name = names.indexOf(srcMapping.name);
                    destOriginalMappings.push(destMapping);
                }
                destGeneratedMappings.push(destMapping);
            }
            quickSort(smc.__originalMappings, util.compareByOriginalPositions);
            return smc;
        };
        BasicSourceMapConsumer.prototype._version = 3;
        Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
            get: function() {
                return this._absoluteSources.slice();
            }
        });
        function Mapping() {
            this.generatedLine = 0;
            this.generatedColumn = 0;
            this.source = null;
            this.originalLine = null;
            this.originalColumn = null;
            this.name = null;
        }
        BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
            var generatedLine = 1;
            var previousGeneratedColumn = 0;
            var previousOriginalLine = 0;
            var previousOriginalColumn = 0;
            var previousSource = 0;
            var previousName = 0;
            var length = aStr.length;
            var index = 0;
            var cachedSegments = {};
            var temp = {};
            var originalMappings = [];
            var generatedMappings = [];
            var mapping, str, segment, end, value;
            while(index < length)if (';' === aStr.charAt(index)) {
                generatedLine++;
                index++;
                previousGeneratedColumn = 0;
            } else if (',' === aStr.charAt(index)) index++;
            else {
                mapping = new Mapping();
                mapping.generatedLine = generatedLine;
                for(end = index; end < length && !this._charIsMappingSeparator(aStr, end); end++);
                str = aStr.slice(index, end);
                segment = cachedSegments[str];
                if (segment) index += str.length;
                else {
                    segment = [];
                    while(index < end){
                        base64VLQ.decode(aStr, index, temp);
                        value = temp.value;
                        index = temp.rest;
                        segment.push(value);
                    }
                    if (2 === segment.length) throw new Error('Found a source, but no line and column');
                    if (3 === segment.length) throw new Error('Found a source and line, but no column');
                    cachedSegments[str] = segment;
                }
                mapping.generatedColumn = previousGeneratedColumn + segment[0];
                previousGeneratedColumn = mapping.generatedColumn;
                if (segment.length > 1) {
                    mapping.source = previousSource + segment[1];
                    previousSource += segment[1];
                    mapping.originalLine = previousOriginalLine + segment[2];
                    previousOriginalLine = mapping.originalLine;
                    mapping.originalLine += 1;
                    mapping.originalColumn = previousOriginalColumn + segment[3];
                    previousOriginalColumn = mapping.originalColumn;
                    if (segment.length > 4) {
                        mapping.name = previousName + segment[4];
                        previousName += segment[4];
                    }
                }
                generatedMappings.push(mapping);
                if ('number' == typeof mapping.originalLine) originalMappings.push(mapping);
            }
            quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
            this.__generatedMappings = generatedMappings;
            quickSort(originalMappings, util.compareByOriginalPositions);
            this.__originalMappings = originalMappings;
        };
        BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
            if (aNeedle[aLineName] <= 0) throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
            if (aNeedle[aColumnName] < 0) throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
            return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
        };
        BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
            for(var index = 0; index < this._generatedMappings.length; ++index){
                var mapping = this._generatedMappings[index];
                if (index + 1 < this._generatedMappings.length) {
                    var nextMapping = this._generatedMappings[index + 1];
                    if (mapping.generatedLine === nextMapping.generatedLine) {
                        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                        continue;
                    }
                }
                mapping.lastGeneratedColumn = 1 / 0;
            }
        };
        BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
            var needle = {
                generatedLine: util.getArg(aArgs, 'line'),
                generatedColumn: util.getArg(aArgs, 'column')
            };
            var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
            if (index >= 0) {
                var mapping = this._generatedMappings[index];
                if (mapping.generatedLine === needle.generatedLine) {
                    var source = util.getArg(mapping, 'source', null);
                    if (null !== source) {
                        source = this._sources.at(source);
                        source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
                    }
                    var name = util.getArg(mapping, 'name', null);
                    if (null !== name) name = this._names.at(name);
                    return {
                        source: source,
                        line: util.getArg(mapping, 'originalLine', null),
                        column: util.getArg(mapping, 'originalColumn', null),
                        name: name
                    };
                }
            }
            return {
                source: null,
                line: null,
                column: null,
                name: null
            };
        };
        BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
            if (!this.sourcesContent) return false;
            return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
                return null == sc;
            });
        };
        BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
            if (!this.sourcesContent) return null;
            var index = this._findSourceIndex(aSource);
            if (index >= 0) return this.sourcesContent[index];
            var relativeSource = aSource;
            if (null != this.sourceRoot) relativeSource = util.relative(this.sourceRoot, relativeSource);
            var url;
            if (null != this.sourceRoot && (url = util.urlParse(this.sourceRoot))) {
                var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
                if ("file" == url.scheme && this._sources.has(fileUriAbsPath)) return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
                if ((!url.path || "/" == url.path) && this._sources.has("/" + relativeSource)) return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
            }
            if (nullOnMissing) return null;
            throw new Error('"' + relativeSource + '" is not in the SourceMap.');
        };
        BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
            var source = util.getArg(aArgs, 'source');
            source = this._findSourceIndex(source);
            if (source < 0) return {
                line: null,
                column: null,
                lastColumn: null
            };
            var needle = {
                source: source,
                originalLine: util.getArg(aArgs, 'line'),
                originalColumn: util.getArg(aArgs, 'column')
            };
            var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
            if (index >= 0) {
                var mapping = this._originalMappings[index];
                if (mapping.source === needle.source) return {
                    line: util.getArg(mapping, 'generatedLine', null),
                    column: util.getArg(mapping, 'generatedColumn', null),
                    lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                };
            }
            return {
                line: null,
                column: null,
                lastColumn: null
            };
        };
        function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
            var sourceMap = aSourceMap;
            if ('string' == typeof aSourceMap) sourceMap = util.parseSourceMapInput(aSourceMap);
            var version = util.getArg(sourceMap, 'version');
            var sections = util.getArg(sourceMap, 'sections');
            if (version != this._version) throw new Error('Unsupported version: ' + version);
            this._sources = new ArraySet();
            this._names = new ArraySet();
            var lastOffset = {
                line: -1,
                column: 0
            };
            this._sections = sections.map(function(s) {
                if (s.url) throw new Error('Support for url field in sections not implemented.');
                var offset = util.getArg(s, 'offset');
                var offsetLine = util.getArg(offset, 'line');
                var offsetColumn = util.getArg(offset, 'column');
                if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) throw new Error('Section offsets must be ordered and non-overlapping.');
                lastOffset = offset;
                return {
                    generatedOffset: {
                        generatedLine: offsetLine + 1,
                        generatedColumn: offsetColumn + 1
                    },
                    consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
                };
            });
        }
        IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
        IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
        IndexedSourceMapConsumer.prototype._version = 3;
        Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
            get: function() {
                var sources = [];
                for(var i = 0; i < this._sections.length; i++)for(var j = 0; j < this._sections[i].consumer.sources.length; j++)sources.push(this._sections[i].consumer.sources[j]);
                return sources;
            }
        });
        IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
            var needle = {
                generatedLine: util.getArg(aArgs, 'line'),
                generatedColumn: util.getArg(aArgs, 'column')
            };
            var sectionIndex = binarySearch.search(needle, this._sections, function(needle, section) {
                var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
                if (cmp) return cmp;
                return needle.generatedColumn - section.generatedOffset.generatedColumn;
            });
            var section = this._sections[sectionIndex];
            if (!section) return {
                source: null,
                line: null,
                column: null,
                name: null
            };
            return section.consumer.originalPositionFor({
                line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
                column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
                bias: aArgs.bias
            });
        };
        IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
            return this._sections.every(function(s) {
                return s.consumer.hasContentsOfAllSources();
            });
        };
        IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
            for(var i = 0; i < this._sections.length; i++){
                var section = this._sections[i];
                var content = section.consumer.sourceContentFor(aSource, true);
                if (content) return content;
            }
            if (nullOnMissing) return null;
            throw new Error('"' + aSource + '" is not in the SourceMap.');
        };
        IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
            for(var i = 0; i < this._sections.length; i++){
                var section = this._sections[i];
                if (-1 !== section.consumer._findSourceIndex(util.getArg(aArgs, 'source'))) {
                    var generatedPosition = section.consumer.generatedPositionFor(aArgs);
                    if (generatedPosition) {
                        var ret = {
                            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
                            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
                        };
                        return ret;
                    }
                }
            }
            return {
                line: null,
                column: null
            };
        };
        IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
            this.__generatedMappings = [];
            this.__originalMappings = [];
            for(var i = 0; i < this._sections.length; i++){
                var section = this._sections[i];
                var sectionMappings = section.consumer._generatedMappings;
                for(var j = 0; j < sectionMappings.length; j++){
                    var mapping = sectionMappings[j];
                    var source = section.consumer._sources.at(mapping.source);
                    source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
                    this._sources.add(source);
                    source = this._sources.indexOf(source);
                    var name = null;
                    if (mapping.name) {
                        name = section.consumer._names.at(mapping.name);
                        this._names.add(name);
                        name = this._names.indexOf(name);
                    }
                    var adjustedMapping = {
                        source: source,
                        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
                        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
                        originalLine: mapping.originalLine,
                        originalColumn: mapping.originalColumn,
                        name: name
                    };
                    this.__generatedMappings.push(adjustedMapping);
                    if ('number' == typeof adjustedMapping.originalLine) this.__originalMappings.push(adjustedMapping);
                }
            }
            quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
            quickSort(this.__originalMappings, util.compareByOriginalPositions);
        };
    },
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js" (__unused_rspack_module, exports, __webpack_require__) {
        var base64VLQ = __webpack_require__("../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js");
        var util = __webpack_require__("../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js");
        var ArraySet = __webpack_require__("../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js").ArraySet;
        var MappingList = __webpack_require__("../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js").MappingList;
        function SourceMapGenerator(aArgs) {
            if (!aArgs) aArgs = {};
            this._file = util.getArg(aArgs, 'file', null);
            this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
            this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
            this._sources = new ArraySet();
            this._names = new ArraySet();
            this._mappings = new MappingList();
            this._sourcesContents = null;
        }
        SourceMapGenerator.prototype._version = 3;
        SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
            var sourceRoot = aSourceMapConsumer.sourceRoot;
            var generator = new SourceMapGenerator({
                file: aSourceMapConsumer.file,
                sourceRoot: sourceRoot
            });
            aSourceMapConsumer.eachMapping(function(mapping) {
                var newMapping = {
                    generated: {
                        line: mapping.generatedLine,
                        column: mapping.generatedColumn
                    }
                };
                if (null != mapping.source) {
                    newMapping.source = mapping.source;
                    if (null != sourceRoot) newMapping.source = util.relative(sourceRoot, newMapping.source);
                    newMapping.original = {
                        line: mapping.originalLine,
                        column: mapping.originalColumn
                    };
                    if (null != mapping.name) newMapping.name = mapping.name;
                }
                generator.addMapping(newMapping);
            });
            aSourceMapConsumer.sources.forEach(function(sourceFile) {
                var sourceRelative = sourceFile;
                if (null !== sourceRoot) sourceRelative = util.relative(sourceRoot, sourceFile);
                if (!generator._sources.has(sourceRelative)) generator._sources.add(sourceRelative);
                var content = aSourceMapConsumer.sourceContentFor(sourceFile);
                if (null != content) generator.setSourceContent(sourceFile, content);
            });
            return generator;
        };
        SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
            var generated = util.getArg(aArgs, 'generated');
            var original = util.getArg(aArgs, 'original', null);
            var source = util.getArg(aArgs, 'source', null);
            var name = util.getArg(aArgs, 'name', null);
            if (!this._skipValidation) this._validateMapping(generated, original, source, name);
            if (null != source) {
                source = String(source);
                if (!this._sources.has(source)) this._sources.add(source);
            }
            if (null != name) {
                name = String(name);
                if (!this._names.has(name)) this._names.add(name);
            }
            this._mappings.add({
                generatedLine: generated.line,
                generatedColumn: generated.column,
                originalLine: null != original && original.line,
                originalColumn: null != original && original.column,
                source: source,
                name: name
            });
        };
        SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
            var source = aSourceFile;
            if (null != this._sourceRoot) source = util.relative(this._sourceRoot, source);
            if (null != aSourceContent) {
                if (!this._sourcesContents) this._sourcesContents = Object.create(null);
                this._sourcesContents[util.toSetString(source)] = aSourceContent;
            } else if (this._sourcesContents) {
                delete this._sourcesContents[util.toSetString(source)];
                if (0 === Object.keys(this._sourcesContents).length) this._sourcesContents = null;
            }
        };
        SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
            var sourceFile = aSourceFile;
            if (null == aSourceFile) {
                if (null == aSourceMapConsumer.file) throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');
                sourceFile = aSourceMapConsumer.file;
            }
            var sourceRoot = this._sourceRoot;
            if (null != sourceRoot) sourceFile = util.relative(sourceRoot, sourceFile);
            var newSources = new ArraySet();
            var newNames = new ArraySet();
            this._mappings.unsortedForEach(function(mapping) {
                if (mapping.source === sourceFile && null != mapping.originalLine) {
                    var original = aSourceMapConsumer.originalPositionFor({
                        line: mapping.originalLine,
                        column: mapping.originalColumn
                    });
                    if (null != original.source) {
                        mapping.source = original.source;
                        if (null != aSourceMapPath) mapping.source = util.join(aSourceMapPath, mapping.source);
                        if (null != sourceRoot) mapping.source = util.relative(sourceRoot, mapping.source);
                        mapping.originalLine = original.line;
                        mapping.originalColumn = original.column;
                        if (null != original.name) mapping.name = original.name;
                    }
                }
                var source = mapping.source;
                if (null != source && !newSources.has(source)) newSources.add(source);
                var name = mapping.name;
                if (null != name && !newNames.has(name)) newNames.add(name);
            }, this);
            this._sources = newSources;
            this._names = newNames;
            aSourceMapConsumer.sources.forEach(function(sourceFile) {
                var content = aSourceMapConsumer.sourceContentFor(sourceFile);
                if (null != content) {
                    if (null != aSourceMapPath) sourceFile = util.join(aSourceMapPath, sourceFile);
                    if (null != sourceRoot) sourceFile = util.relative(sourceRoot, sourceFile);
                    this.setSourceContent(sourceFile, content);
                }
            }, this);
        };
        SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
            if (aOriginal && 'number' != typeof aOriginal.line && 'number' != typeof aOriginal.column) throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
            if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) return;
            if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) return;
            throw new Error('Invalid mapping: ' + JSON.stringify({
                generated: aGenerated,
                source: aSource,
                original: aOriginal,
                name: aName
            }));
        };
        SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
            var previousGeneratedColumn = 0;
            var previousGeneratedLine = 1;
            var previousOriginalColumn = 0;
            var previousOriginalLine = 0;
            var previousName = 0;
            var previousSource = 0;
            var result = '';
            var next;
            var mapping;
            var nameIdx;
            var sourceIdx;
            var mappings = this._mappings.toArray();
            for(var i = 0, len = mappings.length; i < len; i++){
                mapping = mappings[i];
                next = '';
                if (mapping.generatedLine !== previousGeneratedLine) {
                    previousGeneratedColumn = 0;
                    while(mapping.generatedLine !== previousGeneratedLine){
                        next += ';';
                        previousGeneratedLine++;
                    }
                } else if (i > 0) {
                    if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) continue;
                    next += ',';
                }
                next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
                previousGeneratedColumn = mapping.generatedColumn;
                if (null != mapping.source) {
                    sourceIdx = this._sources.indexOf(mapping.source);
                    next += base64VLQ.encode(sourceIdx - previousSource);
                    previousSource = sourceIdx;
                    next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
                    previousOriginalLine = mapping.originalLine - 1;
                    next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
                    previousOriginalColumn = mapping.originalColumn;
                    if (null != mapping.name) {
                        nameIdx = this._names.indexOf(mapping.name);
                        next += base64VLQ.encode(nameIdx - previousName);
                        previousName = nameIdx;
                    }
                }
                result += next;
            }
            return result;
        };
        SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
            return aSources.map(function(source) {
                if (!this._sourcesContents) return null;
                if (null != aSourceRoot) source = util.relative(aSourceRoot, source);
                var key = util.toSetString(source);
                return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
            }, this);
        };
        SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
            var map = {
                version: this._version,
                sources: this._sources.toArray(),
                names: this._names.toArray(),
                mappings: this._serializeMappings()
            };
            if (null != this._file) map.file = this._file;
            if (null != this._sourceRoot) map.sourceRoot = this._sourceRoot;
            if (this._sourcesContents) map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
            return map;
        };
        SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
            return JSON.stringify(this.toJSON());
        };
        exports.SourceMapGenerator = SourceMapGenerator;
    },
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-node.js" (__unused_rspack_module, exports, __webpack_require__) {
        var SourceMapGenerator = __webpack_require__("../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
        var util = __webpack_require__("../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js");
        var REGEX_NEWLINE = /(\r?\n)/;
        var NEWLINE_CODE = 10;
        var isSourceNode = "$$$isSourceNode$$$";
        function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
            this.children = [];
            this.sourceContents = {};
            this.line = null == aLine ? null : aLine;
            this.column = null == aColumn ? null : aColumn;
            this.source = null == aSource ? null : aSource;
            this.name = null == aName ? null : aName;
            this[isSourceNode] = true;
            if (null != aChunks) this.add(aChunks);
        }
        SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
            var node = new SourceNode();
            var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
            var remainingLinesIndex = 0;
            var shiftNextLine = function() {
                var lineContents = getNextLine();
                var newLine = getNextLine() || "";
                return lineContents + newLine;
                function getNextLine() {
                    return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
                }
            };
            var lastGeneratedLine = 1, lastGeneratedColumn = 0;
            var lastMapping = null;
            aSourceMapConsumer.eachMapping(function(mapping) {
                if (null !== lastMapping) if (lastGeneratedLine < mapping.generatedLine) {
                    addMappingWithCode(lastMapping, shiftNextLine());
                    lastGeneratedLine++;
                    lastGeneratedColumn = 0;
                } else {
                    var nextLine = remainingLines[remainingLinesIndex] || '';
                    var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
                    remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
                    lastGeneratedColumn = mapping.generatedColumn;
                    addMappingWithCode(lastMapping, code);
                    lastMapping = mapping;
                    return;
                }
                while(lastGeneratedLine < mapping.generatedLine){
                    node.add(shiftNextLine());
                    lastGeneratedLine++;
                }
                if (lastGeneratedColumn < mapping.generatedColumn) {
                    var nextLine = remainingLines[remainingLinesIndex] || '';
                    node.add(nextLine.substr(0, mapping.generatedColumn));
                    remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
                    lastGeneratedColumn = mapping.generatedColumn;
                }
                lastMapping = mapping;
            }, this);
            if (remainingLinesIndex < remainingLines.length) {
                if (lastMapping) addMappingWithCode(lastMapping, shiftNextLine());
                node.add(remainingLines.splice(remainingLinesIndex).join(""));
            }
            aSourceMapConsumer.sources.forEach(function(sourceFile) {
                var content = aSourceMapConsumer.sourceContentFor(sourceFile);
                if (null != content) {
                    if (null != aRelativePath) sourceFile = util.join(aRelativePath, sourceFile);
                    node.setSourceContent(sourceFile, content);
                }
            });
            return node;
            function addMappingWithCode(mapping, code) {
                if (null === mapping || void 0 === mapping.source) node.add(code);
                else {
                    var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
                    node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
                }
            }
        };
        SourceNode.prototype.add = function SourceNode_add(aChunk) {
            if (Array.isArray(aChunk)) aChunk.forEach(function(chunk) {
                this.add(chunk);
            }, this);
            else if (aChunk[isSourceNode] || "string" == typeof aChunk) {
                if (aChunk) this.children.push(aChunk);
            } else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
            return this;
        };
        SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
            if (Array.isArray(aChunk)) for(var i = aChunk.length - 1; i >= 0; i--)this.prepend(aChunk[i]);
            else if (aChunk[isSourceNode] || "string" == typeof aChunk) this.children.unshift(aChunk);
            else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
            return this;
        };
        SourceNode.prototype.walk = function SourceNode_walk(aFn) {
            var chunk;
            for(var i = 0, len = this.children.length; i < len; i++){
                chunk = this.children[i];
                if (chunk[isSourceNode]) chunk.walk(aFn);
                else if ('' !== chunk) aFn(chunk, {
                    source: this.source,
                    line: this.line,
                    column: this.column,
                    name: this.name
                });
            }
        };
        SourceNode.prototype.join = function SourceNode_join(aSep) {
            var newChildren;
            var i;
            var len = this.children.length;
            if (len > 0) {
                newChildren = [];
                for(i = 0; i < len - 1; i++){
                    newChildren.push(this.children[i]);
                    newChildren.push(aSep);
                }
                newChildren.push(this.children[i]);
                this.children = newChildren;
            }
            return this;
        };
        SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
            var lastChild = this.children[this.children.length - 1];
            if (lastChild[isSourceNode]) lastChild.replaceRight(aPattern, aReplacement);
            else if ('string' == typeof lastChild) this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
            else this.children.push(''.replace(aPattern, aReplacement));
            return this;
        };
        SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
            this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
        };
        SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
            for(var i = 0, len = this.children.length; i < len; i++)if (this.children[i][isSourceNode]) this.children[i].walkSourceContents(aFn);
            var sources = Object.keys(this.sourceContents);
            for(var i = 0, len = sources.length; i < len; i++)aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
        };
        SourceNode.prototype.toString = function SourceNode_toString() {
            var str = "";
            this.walk(function(chunk) {
                str += chunk;
            });
            return str;
        };
        SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
            var generated = {
                code: "",
                line: 1,
                column: 0
            };
            var map = new SourceMapGenerator(aArgs);
            var sourceMappingActive = false;
            var lastOriginalSource = null;
            var lastOriginalLine = null;
            var lastOriginalColumn = null;
            var lastOriginalName = null;
            this.walk(function(chunk, original) {
                generated.code += chunk;
                if (null !== original.source && null !== original.line && null !== original.column) {
                    if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) map.addMapping({
                        source: original.source,
                        original: {
                            line: original.line,
                            column: original.column
                        },
                        generated: {
                            line: generated.line,
                            column: generated.column
                        },
                        name: original.name
                    });
                    lastOriginalSource = original.source;
                    lastOriginalLine = original.line;
                    lastOriginalColumn = original.column;
                    lastOriginalName = original.name;
                    sourceMappingActive = true;
                } else if (sourceMappingActive) {
                    map.addMapping({
                        generated: {
                            line: generated.line,
                            column: generated.column
                        }
                    });
                    lastOriginalSource = null;
                    sourceMappingActive = false;
                }
                for(var idx = 0, length = chunk.length; idx < length; idx++)if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
                    generated.line++;
                    generated.column = 0;
                    if (idx + 1 === length) {
                        lastOriginalSource = null;
                        sourceMappingActive = false;
                    } else if (sourceMappingActive) map.addMapping({
                        source: original.source,
                        original: {
                            line: original.line,
                            column: original.column
                        },
                        generated: {
                            line: generated.line,
                            column: generated.column
                        },
                        name: original.name
                    });
                } else generated.column++;
            });
            this.walkSourceContents(function(sourceFile, sourceContent) {
                map.setSourceContent(sourceFile, sourceContent);
            });
            return {
                code: generated.code,
                map: map
            };
        };
    },
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js" (__unused_rspack_module, exports) {
        function getArg(aArgs, aName, aDefaultValue) {
            if (aName in aArgs) return aArgs[aName];
            if (3 === arguments.length) return aDefaultValue;
            throw new Error('"' + aName + '" is a required argument.');
        }
        exports.getArg = getArg;
        var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
        var dataUrlRegexp = /^data:.+\,.+$/;
        function urlParse(aUrl) {
            var match = aUrl.match(urlRegexp);
            if (!match) return null;
            return {
                scheme: match[1],
                auth: match[2],
                host: match[3],
                port: match[4],
                path: match[5]
            };
        }
        exports.urlParse = urlParse;
        function urlGenerate(aParsedUrl) {
            var url = '';
            if (aParsedUrl.scheme) url += aParsedUrl.scheme + ':';
            url += '//';
            if (aParsedUrl.auth) url += aParsedUrl.auth + '@';
            if (aParsedUrl.host) url += aParsedUrl.host;
            if (aParsedUrl.port) url += ":" + aParsedUrl.port;
            if (aParsedUrl.path) url += aParsedUrl.path;
            return url;
        }
        exports.urlGenerate = urlGenerate;
        function normalize(aPath) {
            var path = aPath;
            var url = urlParse(aPath);
            if (url) {
                if (!url.path) return aPath;
                path = url.path;
            }
            var isAbsolute = exports.isAbsolute(path);
            var parts = path.split(/\/+/);
            for(var part, up = 0, i = parts.length - 1; i >= 0; i--){
                part = parts[i];
                if ('.' === part) parts.splice(i, 1);
                else if ('..' === part) up++;
                else if (up > 0) if ('' === part) {
                    parts.splice(i + 1, up);
                    up = 0;
                } else {
                    parts.splice(i, 2);
                    up--;
                }
            }
            path = parts.join('/');
            if ('' === path) path = isAbsolute ? '/' : '.';
            if (url) {
                url.path = path;
                return urlGenerate(url);
            }
            return path;
        }
        exports.normalize = normalize;
        function join(aRoot, aPath) {
            if ("" === aRoot) aRoot = ".";
            if ("" === aPath) aPath = ".";
            var aPathUrl = urlParse(aPath);
            var aRootUrl = urlParse(aRoot);
            if (aRootUrl) aRoot = aRootUrl.path || '/';
            if (aPathUrl && !aPathUrl.scheme) {
                if (aRootUrl) aPathUrl.scheme = aRootUrl.scheme;
                return urlGenerate(aPathUrl);
            }
            if (aPathUrl || aPath.match(dataUrlRegexp)) return aPath;
            if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
                aRootUrl.host = aPath;
                return urlGenerate(aRootUrl);
            }
            var joined = '/' === aPath.charAt(0) ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
            if (aRootUrl) {
                aRootUrl.path = joined;
                return urlGenerate(aRootUrl);
            }
            return joined;
        }
        exports.join = join;
        exports.isAbsolute = function(aPath) {
            return '/' === aPath.charAt(0) || urlRegexp.test(aPath);
        };
        function relative(aRoot, aPath) {
            if ("" === aRoot) aRoot = ".";
            aRoot = aRoot.replace(/\/$/, '');
            var level = 0;
            while(0 !== aPath.indexOf(aRoot + '/')){
                var index = aRoot.lastIndexOf("/");
                if (index < 0) return aPath;
                aRoot = aRoot.slice(0, index);
                if (aRoot.match(/^([^\/]+:\/)?\/*$/)) return aPath;
                ++level;
            }
            return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
        }
        exports.relative = relative;
        var supportsNullProto = function() {
            var obj = Object.create(null);
            return !('__proto__' in obj);
        }();
        function identity(s) {
            return s;
        }
        function toSetString(aStr) {
            if (isProtoString(aStr)) return '$' + aStr;
            return aStr;
        }
        exports.toSetString = supportsNullProto ? identity : toSetString;
        function fromSetString(aStr) {
            if (isProtoString(aStr)) return aStr.slice(1);
            return aStr;
        }
        exports.fromSetString = supportsNullProto ? identity : fromSetString;
        function isProtoString(s) {
            if (!s) return false;
            var length = s.length;
            if (length < 9) return false;
            if (95 !== s.charCodeAt(length - 1) || 95 !== s.charCodeAt(length - 2) || 111 !== s.charCodeAt(length - 3) || 116 !== s.charCodeAt(length - 4) || 111 !== s.charCodeAt(length - 5) || 114 !== s.charCodeAt(length - 6) || 112 !== s.charCodeAt(length - 7) || 95 !== s.charCodeAt(length - 8) || 95 !== s.charCodeAt(length - 9)) return false;
            for(var i = length - 10; i >= 0; i--)if (36 !== s.charCodeAt(i)) return false;
            return true;
        }
        function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
            var cmp = strcmp(mappingA.source, mappingB.source);
            if (0 !== cmp) return cmp;
            cmp = mappingA.originalLine - mappingB.originalLine;
            if (0 !== cmp) return cmp;
            cmp = mappingA.originalColumn - mappingB.originalColumn;
            if (0 !== cmp || onlyCompareOriginal) return cmp;
            cmp = mappingA.generatedColumn - mappingB.generatedColumn;
            if (0 !== cmp) return cmp;
            cmp = mappingA.generatedLine - mappingB.generatedLine;
            if (0 !== cmp) return cmp;
            return strcmp(mappingA.name, mappingB.name);
        }
        exports.compareByOriginalPositions = compareByOriginalPositions;
        function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
            var cmp = mappingA.generatedLine - mappingB.generatedLine;
            if (0 !== cmp) return cmp;
            cmp = mappingA.generatedColumn - mappingB.generatedColumn;
            if (0 !== cmp || onlyCompareGenerated) return cmp;
            cmp = strcmp(mappingA.source, mappingB.source);
            if (0 !== cmp) return cmp;
            cmp = mappingA.originalLine - mappingB.originalLine;
            if (0 !== cmp) return cmp;
            cmp = mappingA.originalColumn - mappingB.originalColumn;
            if (0 !== cmp) return cmp;
            return strcmp(mappingA.name, mappingB.name);
        }
        exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
        function strcmp(aStr1, aStr2) {
            if (aStr1 === aStr2) return 0;
            if (null === aStr1) return 1;
            if (null === aStr2) return -1;
            if (aStr1 > aStr2) return 1;
            return -1;
        }
        function compareByGeneratedPositionsInflated(mappingA, mappingB) {
            var cmp = mappingA.generatedLine - mappingB.generatedLine;
            if (0 !== cmp) return cmp;
            cmp = mappingA.generatedColumn - mappingB.generatedColumn;
            if (0 !== cmp) return cmp;
            cmp = strcmp(mappingA.source, mappingB.source);
            if (0 !== cmp) return cmp;
            cmp = mappingA.originalLine - mappingB.originalLine;
            if (0 !== cmp) return cmp;
            cmp = mappingA.originalColumn - mappingB.originalColumn;
            if (0 !== cmp) return cmp;
            return strcmp(mappingA.name, mappingB.name);
        }
        exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
        function parseSourceMapInput(str) {
            return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
        }
        exports.parseSourceMapInput = parseSourceMapInput;
        function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
            sourceURL = sourceURL || '';
            if (sourceRoot) {
                if ('/' !== sourceRoot[sourceRoot.length - 1] && '/' !== sourceURL[0]) sourceRoot += '/';
                sourceURL = sourceRoot + sourceURL;
            }
            if (sourceMapURL) {
                var parsed = urlParse(sourceMapURL);
                if (!parsed) throw new Error("sourceMapURL could not be parsed");
                if (parsed.path) {
                    var index = parsed.path.lastIndexOf('/');
                    if (index >= 0) parsed.path = parsed.path.substring(0, index + 1);
                }
                sourceURL = join(urlGenerate(parsed), sourceURL);
            }
            return normalize(sourceURL);
        }
        exports.computeSourceURL = computeSourceURL;
    },
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/source-map.js" (__unused_rspack_module, exports, __webpack_require__) {
        __webpack_require__("../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
        exports.SourceMapConsumer = __webpack_require__("../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer;
        __webpack_require__("../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-node.js");
    },
    "../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        const os = __webpack_require__("node:os");
        const tty = __webpack_require__("node:tty");
        const hasFlag = __webpack_require__("../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js");
        const { env } = process;
        let forceColor;
        if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) forceColor = 0;
        else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) forceColor = 1;
        if ('FORCE_COLOR' in env) forceColor = 'true' === env.FORCE_COLOR ? 1 : 'false' === env.FORCE_COLOR ? 0 : 0 === env.FORCE_COLOR.length ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
        function translateLevel(level) {
            if (0 === level) return false;
            return {
                level,
                hasBasic: true,
                has256: level >= 2,
                has16m: level >= 3
            };
        }
        function supportsColor(haveStream, streamIsTTY) {
            if (0 === forceColor) return 0;
            if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) return 3;
            if (hasFlag('color=256')) return 2;
            if (haveStream && !streamIsTTY && void 0 === forceColor) return 0;
            const min = forceColor || 0;
            if ('dumb' === env.TERM) return min;
            if ('win32' === process.platform) {
                const osRelease = os.release().split('.');
                if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
                return 1;
            }
            if ('CI' in env) {
                if ([
                    'TRAVIS',
                    'CIRCLECI',
                    'APPVEYOR',
                    'GITLAB_CI',
                    'GITHUB_ACTIONS',
                    'BUILDKITE'
                ].some((sign)=>sign in env) || 'codeship' === env.CI_NAME) return 1;
                return min;
            }
            if ('TEAMCITY_VERSION' in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
            if ('truecolor' === env.COLORTERM) return 3;
            if ('TERM_PROGRAM' in env) {
                const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
                switch(env.TERM_PROGRAM){
                    case 'iTerm.app':
                        return version >= 3 ? 3 : 2;
                    case 'Apple_Terminal':
                        return 2;
                }
            }
            if (/-256(color)?$/i.test(env.TERM)) return 2;
            if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) return 1;
            if ('COLORTERM' in env) return 1;
            return min;
        }
        function getSupportLevel(stream) {
            const level = supportsColor(stream, stream && stream.isTTY);
            return translateLevel(level);
        }
        module.exports = {
            supportsColor: getSupportLevel,
            stdout: translateLevel(supportsColor(true, tty.isatty(1))),
            stderr: translateLevel(supportsColor(true, tty.isatty(2)))
        };
    }
});
const gracefulExit = process.execArgv.some((execArg)=>execArg.startsWith('--perf') || execArg.startsWith('--prof') || execArg.startsWith('--cpu-prof') || execArg.startsWith('--heap-prof') || execArg.startsWith('--diagnostic-dir'));
if (gracefulExit) process.on('SIGTERM', ()=>{
    process.exit();
});
const build_0 = __webpack_require__("../../node_modules/.pnpm/jest-diff@30.2.0/node_modules/jest-diff/build/index.js");
build_0.DIFF_DELETE;
build_0.DIFF_EQUAL;
build_0.DIFF_INSERT;
build_0.Diff;
const diff = build_0.diff;
build_0.diffLinesRaw;
build_0.diffLinesUnified;
build_0.diffLinesUnified2;
build_0.diffStringsRaw;
build_0.diffStringsUnified;
const build_1 = __webpack_require__("../../node_modules/.pnpm/pretty-format@30.2.0/node_modules/pretty-format/build/index.js");
build_1.DEFAULT_OPTIONS;
const format = build_1.format;
const plugins = build_1.plugins;
build_1["default"];
const external_node_util_ = __webpack_require__("node:util");
const REAL_TIMERS = {};
const setRealTimers = ()=>{
    REAL_TIMERS.setTimeout ??= globalThis.setTimeout.bind(globalThis);
};
const getRealTimers = ()=>REAL_TIMERS;
const formatTestError = (err, test)=>{
    const errors = Array.isArray(err) ? err : [
        err
    ];
    return errors.map((rawError)=>{
        const error = 'string' == typeof rawError ? {
            message: rawError
        } : rawError;
        const errObj = {
            fullStack: error.fullStack,
            message: error.message,
            name: error.name,
            stack: error.stack
        };
        if (error instanceof TestRegisterError && test?.type === 'case') errObj.message = `Can't nest describe or test inside a test. ${error.message} because it is nested within test '${test.name}'`;
        if (error.showDiff || void 0 === error.showDiff && void 0 !== error.expected && void 0 !== error.actual) {
            errObj.diff = diff(err.expected, err.actual, {
                expand: false
            });
            errObj.expected = 'string' == typeof error.expected ? error.expected : format(error.expected, {
                plugins: Object.values(plugins)
            });
            errObj.actual = 'string' == typeof error.actual ? error.actual : format(error.actual, {
                plugins: Object.values(plugins)
            });
        }
        return errObj;
    });
};
const formatRegExp = /%[sdjifoOc%]/;
const formatName = (template, param, index)=>{
    let templateStr = template;
    if ([
        '%%',
        '%#',
        '%$'
    ].some((flag)=>templateStr.includes(flag))) templateStr = templateStr.replace(/%%/g, '__rstest_escaped_%__').replace(/%#/g, `${index}`).replace(/%\$/g, `${index + 1}`).replace(/__rstest_escaped_%__/g, '%%');
    if (Array.isArray(param)) return formatRegExp.test(templateStr) ? (0, external_node_util_.format)(templateStr, ...param) : templateStr;
    if (formatRegExp.test(templateStr)) templateStr = (0, external_node_util_.format)(templateStr, param);
    return templateStr.replace(/\$([$\w.]+)/g, (_, key)=>{
        const value = getValue(param, key);
        return value?.toString();
    });
};
function getValue(source, path, defaultValue) {
    const paths = path.replace(/\[(\d+)\]/g, '.$1').split('.');
    let result = source;
    for (const p of paths){
        result = result[p];
        if (void 0 === result) return defaultValue;
    }
    return result;
}
class TestRegisterError extends Error {
}
class RstestError extends Error {
    fullStack;
}
function checkPkgInstalled(name) {
    const require = createRequire(import.meta.url);
    try {
        require.resolve(name);
    } catch (error) {
        if ('MODULE_NOT_FOUND' === error.code) {
            const error = new RstestError(`Missing dependency "${name}". Please install it first.`);
            error.fullStack = true;
            throw error;
        }
        throw error;
    }
}
export { TestRegisterError, checkPkgInstalled, formatName, formatTestError, getRealTimers, setRealTimers };
