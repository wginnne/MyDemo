import * as __rspack_external__rsbuild_core_1b356efc from "@rsbuild/core";
import node_fs, { promises } from "node:fs";
import { glob } from "../compiled/tinyglobby/index.js";
import { createRequire } from "node:module";
import picocolors from "../compiled/picocolors/index.js";
import { logger } from "../compiled/rslog/index.js";
import node_fs_promises from "node:fs/promises";
import { createRequire as external_module_createRequire } from "module";
import { EventEmitter } from "events";
import node_util from "node:util";
import { basename as external_node_path_basename, node_path, extname, DEFAULT_CONFIG_NAME, dirname, DTS_EXTENSIONS_PATTERN, SWC_HELPERS, CSS_EXTENSIONS_PATTERN, JS_EXTENSIONS_PATTERN, BASE_URI, join, getUndoPath, ABSOLUTE_PUBLIC_PATH, isCssFile, AUTO_PUBLIC_PATH, isAbsolute, isCssGlobalFile, DEFAULT_CONFIG_EXTENSIONS, SINGLE_DOT_PATH_SEGMENT, isCssModulesFile } from "./800.js";
const LibSvgrPatchPlugin_pluginName = 'LIB_SVGR_PATCH_PLUGIN';
const PUBLIC_PATH_PLACEHOLDER = '__RSLIB_SVGR_AUTO_PUBLIC_PATH__';
class LibSvgrPatchPlugin {
    name = LibSvgrPatchPlugin_pluginName;
    apply(compiler) {
        compiler.hooks.make.tap(this.name, (compilation)=>{
            compilation.hooks.processAssets.tap(this.name, (assets)=>{
                const isEsm = Boolean(compilation.options.output.module);
                const chunkAsset = Object.keys(assets).filter((name)=>/js$/.test(name));
                for (const name of chunkAsset)compilation.updateAsset(name, (old)=>{
                    const oldSource = old.source().toString();
                    const newSource = new __rspack_external__rsbuild_core_1b356efc.rspack.sources.ReplaceSource(old);
                    const pattern = new RegExp(`\\(?['"]${PUBLIC_PATH_PLACEHOLDER}(.*)['"]\\)?`, 'g');
                    const matches = [
                        ...oldSource.matchAll(pattern)
                    ];
                    const len = matches.length;
                    if (0 === len) return old;
                    const undoPath = getUndoPath(name, compilation.outputOptions.path, true);
                    for(let i = 0; i < len; i++){
                        const match = matches[i];
                        const filename = match[1];
                        const requirePath = `${undoPath}${filename}`;
                        let replaced = '';
                        replaced = isEsm ? `__rslib_svgr_url__${i}__` : `require("${requirePath}")`;
                        newSource.replace(match.index, match.index + match[0].length - 1, replaced);
                        if (isEsm) newSource.insert(0, `import __rslib_svgr_url__${i}__ from "${requirePath}";\n`);
                    }
                    return newSource;
                });
            });
        });
    }
}
const PLUGIN_NAME = 'rsbuild:lib-asset';
const RSBUILD_SVGR_PLUGIN_NAME = 'rsbuild:svgr';
const pluginLibAsset = ({ bundle })=>({
        name: PLUGIN_NAME,
        pre: [
            RSBUILD_SVGR_PLUGIN_NAME
        ],
        setup (api) {
            api.modifyBundlerChain((config, { CHAIN_ID })=>{
                const svgAssetRule = config.module.rules.get(CHAIN_ID.RULE.SVG).oneOfs.get(CHAIN_ID.ONE_OF.SVG_ASSET);
                const originalTypeOptions = svgAssetRule.get('type');
                const originalParserOptions = svgAssetRule.get('parser');
                const originalGeneratorOptions = svgAssetRule.get('generator');
                const isUserSetPublicPath = 'auto' !== config.output.get('publicPath');
                const generatorOptions = isUserSetPublicPath ? originalGeneratorOptions : {
                    ...originalGeneratorOptions,
                    importMode: 'preserve'
                };
                const rule = config.module.rule(CHAIN_ID.RULE.SVG);
                rule.oneOf(CHAIN_ID.ONE_OF.SVG_ASSET).generator(generatorOptions).issuer({
                    not: CSS_EXTENSIONS_PATTERN
                });
                rule.oneOf(`${CHAIN_ID.ONE_OF.SVG_ASSET}-for-css`).type(originalTypeOptions).parser(originalParserOptions).generator(originalGeneratorOptions).issuer(CSS_EXTENSIONS_PATTERN);
                const ruleIds = [
                    CHAIN_ID.RULE.FONT,
                    CHAIN_ID.RULE.MEDIA,
                    CHAIN_ID.RULE.IMAGE,
                    CHAIN_ID.RULE.ADDITIONAL_ASSETS
                ];
                for (const ruleId of ruleIds){
                    const oneOfId = `${ruleId}-asset`;
                    const assetRule = config.module.rules.get(ruleId);
                    if (!assetRule) continue;
                    const assetRuleOneOf = assetRule.oneOfs.get(oneOfId);
                    const originalTypeOptions = assetRuleOneOf.get('type');
                    const originalParserOptions = assetRuleOneOf.get('parser');
                    const originalGeneratorOptions = assetRuleOneOf.get('generator');
                    const generatorOptions = isUserSetPublicPath ? originalGeneratorOptions : {
                        ...originalGeneratorOptions,
                        importMode: 'preserve'
                    };
                    const rule = config.module.rule(ruleId);
                    rule.oneOf(oneOfId).generator(generatorOptions).issuer({
                        not: CSS_EXTENSIONS_PATTERN
                    });
                    rule.oneOf(`${oneOfId}-for-css`).type(originalTypeOptions).parser(originalParserOptions).generator(originalGeneratorOptions).issuer(CSS_EXTENSIONS_PATTERN);
                }
                const isUsingSvgr = config.module.rule(CHAIN_ID.RULE.SVG).oneOf(CHAIN_ID.RULE.SVG).uses.has(CHAIN_ID.USE.SVGR);
                const isUsingSvgrUrlLoader = config.module.rule(CHAIN_ID.RULE.SVG).oneOf(CHAIN_ID.ONE_OF.SVG).uses.has(CHAIN_ID.USE.URL);
                if (isUsingSvgr && isUsingSvgrUrlLoader) {
                    const urlLoaderRule = config.module.rule(CHAIN_ID.RULE.SVG).oneOf(CHAIN_ID.ONE_OF.SVG).use(CHAIN_ID.USE.URL);
                    const originalOptions = urlLoaderRule.get('options');
                    urlLoaderRule.options({
                        ...originalOptions,
                        publicPath: (url)=>`${PUBLIC_PATH_PLACEHOLDER}${url}`
                    });
                    config.plugin(LibSvgrPatchPlugin.name).use(LibSvgrPatchPlugin, []);
                }
                if (isUsingSvgr) if (bundle) {
                    const rule = config.module.rule(CHAIN_ID.RULE.SVG).oneOf(CHAIN_ID.ONE_OF.SVG_URL);
                    const originalGeneratorOptions = rule.get('generator');
                    const generatorOptions = isUserSetPublicPath ? originalGeneratorOptions : {
                        ...originalGeneratorOptions,
                        importMode: 'preserve'
                    };
                    rule.generator(generatorOptions);
                } else {
                    const rule = config.module.rule(CHAIN_ID.RULE.SVG).oneOf(CHAIN_ID.ONE_OF.SVG);
                    rule.issuer({
                        not: CSS_EXTENSIONS_PATTERN
                    });
                }
                if (bundle) config.plugins.get(CHAIN_ID.PLUGIN.MINI_CSS_EXTRACT)?.tap((options)=>[
                        {
                            ...options[0],
                            enforceRelative: true
                        }
                    ]);
            });
        }
    });
const composeAssetConfig = (bundle, format)=>{
    if ('esm' === format || 'cjs' === format) {
        if (bundle) return {
            output: {
                dataUriLimit: 0,
                assetPrefix: 'auto'
            },
            plugins: [
                pluginLibAsset({
                    bundle: true
                })
            ]
        };
        return {
            output: {
                dataUriLimit: 0,
                assetPrefix: 'auto'
            },
            plugins: [
                pluginLibAsset({
                    bundle: false
                })
            ]
        };
    }
    return {};
};
const LibCssExtractPlugin_pluginName = 'LIB_CSS_EXTRACT_PLUGIN';
class LibCssExtractPlugin {
    name = LibCssExtractPlugin_pluginName;
    options;
    constructor(options){
        this.options = options ?? {};
    }
    apply(compiler) {
        compiler.hooks.make.tap(LibCssExtractPlugin_pluginName, (compilation)=>{
            compilation.hooks.processAssets.tap(LibCssExtractPlugin_pluginName, (assets)=>{
                const chunkAsset = Object.keys(assets).filter((name)=>/\.css/.test(name));
                for (const name of chunkAsset)compilation.updateAsset(name, (old)=>{
                    const oldSource = old.source().toString();
                    const replaceSource = new __rspack_external__rsbuild_core_1b356efc.rspack.sources.ReplaceSource(old);
                    function replace(searchValue, replaceValue) {
                        let start = oldSource.indexOf(searchValue);
                        while(-1 !== start){
                            replaceSource.replace(start, start + searchValue.length - 1, replaceValue);
                            start = oldSource.indexOf(searchValue, start + 1);
                        }
                    }
                    replace(SINGLE_DOT_PATH_SEGMENT, '.');
                    const undoPath = getUndoPath(name, compilation.outputOptions.path, true);
                    replace(`${ABSOLUTE_PUBLIC_PATH}${AUTO_PUBLIC_PATH}`, undoPath);
                    replace(ABSOLUTE_PUBLIC_PATH, '');
                    replace(`${BASE_URI}/`, '');
                    return replaceSource;
                });
            });
        });
    }
}
const cssConfig_require = createRequire(import.meta.url);
const RSLIB_CSS_ENTRY_FLAG = '__rslib_css__';
async function cssExternalHandler(request, callback, jsExtension, auto, styleRedirectPath, styleRedirectExtension, redirectedPath, issuer) {
    if (/compiled\/css-loader\//.test(request)) return void callback();
    let resolvedRequest = request;
    if (styleRedirectPath) {
        if (void 0 === redirectedPath) return false;
        resolvedRequest = redirectedPath;
    }
    if (!isCssFile(resolvedRequest)) {
        if (isCssFile(issuer)) return void callback();
        return false;
    }
    if (styleRedirectExtension) {
        const isCssModulesRequest = isCssModulesFile(resolvedRequest, auto);
        if (isCssModulesRequest) return void callback(void 0, resolvedRequest.replace(/\.[^.]+$/, jsExtension));
        callback(void 0, resolvedRequest.replace(/\.[^.]+$/, '.css'));
        return;
    }
    callback(void 0, resolvedRequest);
}
const cssConfig_PLUGIN_NAME = 'rsbuild:lib-css';
const pluginLibCss = (rootDir, auto, banner, footer)=>({
        name: cssConfig_PLUGIN_NAME,
        setup (api) {
            api.processAssets({
                stage: 'additional'
            }, ({ assets, compilation })=>{
                for (const key of Object.keys(assets))if (key.match(RSLIB_CSS_ENTRY_FLAG)) compilation.deleteAsset(key);
            });
            api.modifyBundlerChain((config, { CHAIN_ID })=>{
                let isUsingCssExtract = false;
                for (const ruleId of [
                    CHAIN_ID.RULE.CSS,
                    CHAIN_ID.RULE.SASS,
                    CHAIN_ID.RULE.LESS,
                    CHAIN_ID.RULE.STYLUS
                ]){
                    if (!config.module.rules.has(ruleId)) continue;
                    const rule = config.module.rule(ruleId);
                    if (rule.uses.has(CHAIN_ID.USE.MINI_CSS_EXTRACT)) {
                        isUsingCssExtract = true;
                        rule.use(CHAIN_ID.USE.MINI_CSS_EXTRACT).loader(cssConfig_require.resolve('./libCssExtractLoader.js')).options({
                            rootDir,
                            auto,
                            banner,
                            footer
                        });
                    }
                }
                if (isUsingCssExtract) {
                    const cssExtract = CHAIN_ID.PLUGIN.MINI_CSS_EXTRACT;
                    config.plugins.delete(cssExtract);
                    config.plugin(LibCssExtractPlugin.name).use(LibCssExtractPlugin);
                }
            });
        }
    });
const composeCssConfig = (rootDir, auto, bundle = true, banner, footer)=>{
    if (bundle || null === rootDir) return {};
    return {
        plugins: [
            pluginLibCss(rootDir, auto, banner, footer)
        ],
        tools: {
            cssLoader: {
                import: false
            }
        }
    };
};
const EntryChunkPlugin_require = createRequire(import.meta.url);
const EntryChunkPlugin_PLUGIN_NAME = 'rsbuild:lib-entry-chunk';
const LOADER_NAME = 'rsbuild:lib-entry-module';
const IMPORT_META_URL_SHIM = `const __rslib_import_meta_url__ = /*#__PURE__*/ (function () {
  return typeof document === 'undefined'
    ? new (require('url'.replace('', '')).URL)('file:' + __filename).href
    : (document.currentScript && document.currentScript.src) ||
      new URL('main.js', document.baseURI).href;
})();
`;
class EntryChunkPlugin {
    shimsInjectedAssets = new Set();
    enabledImportMetaUrlShim;
    contextToWatch = null;
    constructor({ enabledImportMetaUrlShim = true, contextToWatch }){
        this.enabledImportMetaUrlShim = enabledImportMetaUrlShim;
        this.contextToWatch = contextToWatch;
    }
    apply(compiler) {
        compiler.hooks.afterCompile.tap(EntryChunkPlugin_PLUGIN_NAME, (compilation)=>{
            if (null === this.contextToWatch) return;
            const contextDep = compilation.contextDependencies;
            if (!contextDep.has(this.contextToWatch)) contextDep.add(this.contextToWatch);
        });
        compiler.hooks.make.tap(EntryChunkPlugin_PLUGIN_NAME, (compilation)=>{
            compilation.hooks.chunkAsset.tap(EntryChunkPlugin_PLUGIN_NAME, (_chunk, filename)=>{
                const isJs = JS_EXTENSIONS_PATTERN.test(filename);
                if (!isJs) return;
                this.shimsInjectedAssets.add(filename);
            });
        });
        compiler.hooks.make.tap(EntryChunkPlugin_PLUGIN_NAME, (compilation)=>{
            compilation.hooks.processAssets.tap(EntryChunkPlugin_PLUGIN_NAME, (assets)=>{
                if (!this.enabledImportMetaUrlShim) return;
                const chunkAsset = Object.keys(assets).filter((name)=>JS_EXTENSIONS_PATTERN.test(name) && this.shimsInjectedAssets.has(name));
                for (const name of chunkAsset)compilation.updateAsset(name, (old)=>{
                    const oldSource = old.source().toString();
                    const replaceSource = new __rspack_external__rsbuild_core_1b356efc.rspack.sources.ReplaceSource(old);
                    if (oldSource.startsWith('#!')) {
                        const firstLineEnd = oldSource.indexOf('\n');
                        replaceSource.insert(firstLineEnd + 1, IMPORT_META_URL_SHIM);
                    } else if (oldSource.startsWith("'use strict'") || oldSource.startsWith('"use strict"')) replaceSource.replace(0, 11, `"use strict";\n${IMPORT_META_URL_SHIM}`);
                    else replaceSource.insert(0, IMPORT_META_URL_SHIM);
                    return replaceSource;
                });
            });
        });
    }
}
const entryModuleLoaderRsbuildPlugin = ()=>({
        name: EntryChunkPlugin_PLUGIN_NAME,
        setup (api) {
            api.modifyBundlerChain((config, { CHAIN_ID })=>{
                config.module.rule(`Rslib:${CHAIN_ID.RULE.JS}-entry-loader`).test(config.module.rule(CHAIN_ID.RULE.JS).get('test')).issuer(/^$/).use(LOADER_NAME).loader(EntryChunkPlugin_require.resolve('./entryModuleLoader.js'));
            });
        }
    });
const composeEntryChunkConfig = ({ enabledImportMetaUrlShim, useLoader, contextToWatch = null })=>({
        plugins: useLoader ? [
            entryModuleLoaderRsbuildPlugin()
        ] : [],
        tools: {
            rspack: {
                plugins: [
                    new EntryChunkPlugin({
                        enabledImportMetaUrlShim,
                        contextToWatch
                    })
                ]
            }
        }
    });
const pluginCjsImportMetaUrlShim = ()=>({
        name: 'rsbuild:cjs-import-meta-url-shim',
        setup (api) {
            api.modifyEnvironmentConfig((config)=>{
                config.source.define = {
                    ...config.source.define,
                    'import.meta.url': '__rslib_import_meta_url__'
                };
            });
        }
    });
const requireShim = `// Rslib ESM shims
import __rslib_shim_module__ from 'module';
const require = /*#__PURE__*/ __rslib_shim_module__.createRequire(import.meta.url);
`;
const pluginEsmRequireShim = ()=>({
        name: 'rsbuild:esm-require-shim',
        setup (api) {
            api.modifyRspackConfig((config)=>{
                config.plugins ??= [];
                config.plugins.push(new __rspack_external__rsbuild_core_1b356efc.rspack.BannerPlugin({
                    banner: requireShim,
                    stage: __rspack_external__rsbuild_core_1b356efc.rspack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE - 1,
                    raw: true,
                    include: /\.(js|mjs)$/
                }));
            });
        }
    });
const isDebugKey = (keys)=>{
    if (!process.env.DEBUG) return false;
    const values = process.env.DEBUG.toLocaleLowerCase().split(',');
    return keys.some((key)=>values.includes(key));
};
const isDebug = ()=>isDebugKey([
        'rslib',
        'rsbuild',
        'rs*',
        'rstack',
        '*'
    ]);
if (isDebug()) logger.level = 'verbose';
function getTime() {
    const now = new Date();
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    return `${hours}:${minutes}:${seconds}`;
}
logger.override({
    debug: (message, ...args)=>{
        if ('verbose' !== logger.level) return;
        const time = picocolors.gray(getTime());
        console.log(`  ${picocolors.green('rslib')} ${time} ${message}`, ...args);
    }
});
const getDefaultExtension = (options)=>{
    const { format, pkgJson, autoExtension } = options;
    let jsExtension = '.js';
    let dtsExtension = '.d.ts';
    if (!autoExtension) return {
        jsExtension,
        dtsExtension
    };
    if (!pkgJson) {
        logger.warn('The `autoExtension` configuration will not be applied due to read package.json failed');
        return {
            jsExtension,
            dtsExtension
        };
    }
    const isModule = 'module' === pkgJson.type;
    if (isModule && 'cjs' === format) {
        jsExtension = '.cjs';
        dtsExtension = '.d.cts';
    }
    if (!isModule && 'esm' === format) {
        jsExtension = '.mjs';
        dtsExtension = '.d.mts';
    }
    return {
        jsExtension,
        dtsExtension,
        isModule
    };
};
const nodeBuiltInModules = [
    'assert',
    'assert/strict',
    'async_hooks',
    'buffer',
    'child_process',
    'cluster',
    'console',
    'constants',
    'crypto',
    'dgram',
    'diagnostics_channel',
    'dns',
    'dns/promises',
    'domain',
    'events',
    'fs',
    'fs/promises',
    'http',
    'http2',
    'https',
    'inspector',
    'inspector/promises',
    'module',
    'net',
    'os',
    'path',
    'path/posix',
    'path/win32',
    'perf_hooks',
    'process',
    'punycode',
    'querystring',
    'readline',
    'readline/promises',
    'repl',
    'stream',
    'stream/consumers',
    'stream/promises',
    'stream/web',
    'string_decoder',
    'sys',
    'timers',
    'timers/promises',
    'tls',
    'trace_events',
    'tty',
    'url',
    'util',
    'util/types',
    'v8',
    'vm',
    'wasi',
    'worker_threads',
    'zlib',
    /^node:/,
    'pnpapi'
];
async function calcLongestCommonPath(absPaths) {
    if (0 === absPaths.length) return null;
    const sep = node_path.posix.sep;
    const splitPaths = absPaths.map((p)=>p.split(sep));
    let lcaFragments = splitPaths[0];
    for(let i = 1; i < splitPaths.length; i++){
        const currentPath = splitPaths[i];
        const minLength = Math.min(lcaFragments.length, currentPath.length);
        let j = 0;
        while(j < minLength && lcaFragments[j] === currentPath[j])j++;
        lcaFragments = lcaFragments.slice(0, j);
    }
    let lca = lcaFragments.length > 0 ? lcaFragments.join(sep) : sep;
    const stats = await node_fs_promises.stat(lca);
    if (stats?.isFile()) lca = node_path.dirname(lca);
    return lca;
}
function getAbsolutePath(base, filepath) {
    return isAbsolute(filepath) ? filepath : join(base, filepath);
}
const readPackageJson = (rootPath)=>{
    const pkgJsonPath = node_path.join(rootPath, './package.json');
    if (!node_fs.existsSync(pkgJsonPath)) return void logger.warn(`The \`package.json\` file does not exist in the ${rootPath} directory`);
    try {
        return JSON.parse(node_fs.readFileSync(pkgJsonPath, 'utf8'));
    } catch (_err) {
        logger.warn(`Failed to parse ${pkgJsonPath}, it might not be valid JSON`);
        return;
    }
};
const isObject = (obj)=>'[object Object]' === Object.prototype.toString.call(obj);
const isEmptyObject = (obj)=>0 === Object.keys(obj).length;
function pick(obj, keys) {
    return keys.reduce((ret, key)=>{
        if (void 0 !== obj[key]) ret[key] = obj[key];
        return ret;
    }, {});
}
function omit(obj, keysObj) {
    return Object.keys(obj).reduce((ret, key)=>{
        if (true !== keysObj[key]) ret[key] = obj[key];
        return ret;
    }, {});
}
function isPluginIncluded(pluginName, plugins) {
    return Boolean(plugins?.some((plugin)=>{
        if (Array.isArray(plugin)) return isPluginIncluded(pluginName, plugin);
        if ('object' == typeof plugin && null !== plugin && 'name' in plugin) return plugin.name === pluginName;
        return false;
    }));
}
function checkMFPlugin(config, sharedPlugins) {
    if ('mf' !== config.format) return true;
    const added = isPluginIncluded('rsbuild:module-federation-enhanced', [
        ...sharedPlugins || [],
        ...config.plugins || []
    ]);
    if (!added) {
        logger.warn(`${picocolors.green('format: "mf"')} should be used with ${picocolors.blue('@module-federation/rsbuild-plugin')}", consider installing and adding it to plugins. Check the documentation (https://module-federation.io/guide/basic/rsbuild.html#rslib-module) to get started with "mf" output.`);
        process.exit(1);
    }
    return added;
}
function debounce(func, wait) {
    let timeoutId = null;
    return (...args)=>{
        if (null !== timeoutId) clearTimeout(timeoutId);
        timeoutId = setTimeout(()=>{
            func(...args);
        }, wait);
    };
}
const isTTY = (type = 'stdout')=>('stdin' === type ? process.stdin.isTTY : process.stdout.isTTY) && !process.env.CI;
const isIntermediateOutputFormat = (format)=>'cjs' === format || 'esm' === format;
const windowsSlashRegex = /\\/g;
function normalizeSlash(p) {
    return p.replace(windowsSlashRegex, '/');
}
async function isDirectory(filePath) {
    try {
        const stat = await node_fs_promises.stat(filePath);
        return stat.isDirectory();
    } catch  {
        return false;
    }
}
const LATEST_TARGET_VERSIONS = {
    node: [
        'last 1 node versions'
    ],
    web: [
        'last 1 Chrome versions',
        'last 1 Firefox versions',
        'last 1 Edge versions',
        'last 1 Safari versions',
        'last 1 ios_saf versions',
        'not dead'
    ],
    get 'web-worker' () {
        return LATEST_TARGET_VERSIONS.web;
    }
};
const calcEsnextBrowserslistByTarget = (target)=>{
    if ('node' === target) return LATEST_TARGET_VERSIONS.node;
    return LATEST_TARGET_VERSIONS.web;
};
const RSPACK_TARGET_UNLISTED_MODERN_ECMA_VERSIONS = [
    'es2023',
    'es2024',
    'esnext'
];
const ESX_TO_BROWSERSLIST = {
    es5: {
        chrome: '13',
        edge: '12',
        firefox: '2',
        ios: '6',
        node: '0.6',
        safari: '5.1'
    },
    get es6 () {
        return ESX_TO_BROWSERSLIST.es2015;
    },
    es2015: {
        chrome: '51',
        edge: '79',
        firefox: '53',
        ios: '16.3',
        node: '6.5',
        safari: '16.3'
    },
    es2016: {
        chrome: '52',
        edge: '79',
        firefox: '53',
        ios: '16.3',
        node: '7',
        safari: '16.3'
    },
    es2017: {
        chrome: '55',
        edge: '79',
        firefox: '53',
        ios: '16.3',
        node: '7.6',
        safari: '16.3'
    },
    es2018: {
        chrome: '64',
        edge: '79',
        firefox: '78',
        ios: '16.3',
        node: '10',
        safari: '16.3'
    },
    es2019: {
        chrome: '66',
        edge: '79',
        firefox: '78',
        ios: '16.3',
        node: '10',
        safari: '16.3'
    },
    es2020: {
        chrome: '91',
        edge: '91',
        firefox: '80',
        ios: '16.3',
        node: '16.9',
        safari: '16.3'
    },
    es2021: {
        chrome: '91',
        edge: '91',
        firefox: '80',
        ios: '16.3',
        node: '16.9',
        safari: '16.3'
    },
    es2022: {
        chrome: '94',
        edge: '94',
        firefox: '93',
        ios: '16.4',
        node: '16.11',
        safari: '16.4'
    },
    get es2023 () {
        return ESX_TO_BROWSERSLIST.es2022;
    },
    es2024: calcEsnextBrowserslistByTarget,
    esnext: calcEsnextBrowserslistByTarget
};
function transformSyntaxToRspackTarget(syntax) {
    const handleSyntaxItem = (syntaxItem)=>{
        const normalizedSyntaxItem = syntaxItem.toLowerCase();
        if (normalizedSyntaxItem.startsWith('es')) {
            if (normalizedSyntaxItem in ESX_TO_BROWSERSLIST) {
                if (RSPACK_TARGET_UNLISTED_MODERN_ECMA_VERSIONS.includes(normalizedSyntaxItem)) return 'es2022';
                if ('es6' === normalizedSyntaxItem) return 'es2015';
                return normalizedSyntaxItem;
            }
            throw new Error(`Unsupported ES version: ${syntaxItem}`);
        }
        return `browserslist:${syntaxItem}`;
    };
    if (Array.isArray(syntax)) return syntax.map(handleSyntaxItem);
    return [
        handleSyntaxItem(syntax)
    ];
}
function transformSyntaxToBrowserslist(syntax, target) {
    const handleSyntaxItem = (syntaxItem)=>{
        const normalizedSyntaxItem = syntaxItem.toLowerCase();
        if (normalizedSyntaxItem.startsWith('es')) {
            if (normalizedSyntaxItem in ESX_TO_BROWSERSLIST) {
                const browserslistItem = ESX_TO_BROWSERSLIST[normalizedSyntaxItem];
                if ('function' == typeof browserslistItem) return browserslistItem(target);
                return Object.entries(browserslistItem).flatMap(([engine, version])=>{
                    if (Array.isArray(version)) return version;
                    return `${engine} >= ${version}`;
                });
            }
            throw new Error(`Unsupported ES version: ${syntaxItem}`);
        }
        return [
            syntaxItem
        ];
    };
    if (Array.isArray(syntax)) return syntax.flatMap(handleSyntaxItem);
    return handleSyntaxItem(syntax);
}
const POSIX_SEP_RE = new RegExp('\\' + node_path.posix.sep, 'g');
const NATIVE_SEP_RE = new RegExp('\\' + node_path.sep, 'g');
const PATTERN_REGEX_CACHE = new Map();
const GLOB_ALL_PATTERN = "**/*";
const TS_EXTENSIONS = [
    '.ts',
    '.tsx',
    '.mts',
    '.cts'
];
const JS_EXTENSIONS = [
    '.js',
    '.jsx',
    '.mjs',
    '.cjs'
];
const TSJS_EXTENSIONS = TS_EXTENSIONS.concat(JS_EXTENSIONS);
const TS_EXTENSIONS_RE_GROUP = `\\.(?:${TS_EXTENSIONS.map((ext)=>ext.substring(1)).join('|')})`;
const TSJS_EXTENSIONS_RE_GROUP = `\\.(?:${TSJS_EXTENSIONS.map((ext)=>ext.substring(1)).join('|')})`;
const IS_POSIX = node_path.posix.sep === node_path.sep;
function util_makePromise() {
    let resolve, reject;
    const promise = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    return {
        promise,
        resolve,
        reject
    };
}
async function util_resolveTSConfigJson(filename, cache) {
    if ('.json' !== node_path.extname(filename)) return;
    const tsconfig = node_path.resolve(filename);
    if (cache && (cache.hasParseResult(tsconfig) || cache.hasParseResult(filename))) return tsconfig;
    return promises.stat(tsconfig).then((stat)=>{
        if (stat.isFile() || stat.isFIFO()) return tsconfig;
        throw new Error(`${filename} exists but is not a regular file.`);
    });
}
const util_isInNodeModules = IS_POSIX ? (dir)=>dir.includes('/node_modules/') : (dir)=>dir.match(/[/\\]node_modules[/\\]/);
const posix2native = IS_POSIX ? (filename)=>filename : (filename)=>filename.replace(POSIX_SEP_RE, node_path.sep);
const util_native2posix = IS_POSIX ? (filename)=>filename : (filename)=>filename.replace(NATIVE_SEP_RE, node_path.posix.sep);
const resolve2posix = IS_POSIX ? (dir, filename)=>dir ? node_path.resolve(dir, filename) : node_path.resolve(filename) : (dir, filename)=>util_native2posix(dir ? node_path.resolve(posix2native(dir), posix2native(filename)) : node_path.resolve(posix2native(filename)));
function util_resolveReferencedTSConfigFiles(result, options) {
    const dir = node_path.dirname(result.tsconfigFile);
    return result.tsconfig.references.map((ref)=>{
        const refPath = ref.path.endsWith('.json') ? ref.path : node_path.join(ref.path, options?.configName ?? 'tsconfig.json');
        return resolve2posix(dir, refPath);
    });
}
function util_resolveSolutionTSConfig(filename, result) {
    const allowJs = result.tsconfig.compilerOptions?.allowJs;
    const extensions = allowJs ? TSJS_EXTENSIONS : TS_EXTENSIONS;
    if (result.referenced && extensions.some((ext)=>filename.endsWith(ext)) && !util_isIncluded(filename, result)) {
        const solutionTSConfig = result.referenced.find((referenced)=>util_isIncluded(filename, referenced));
        if (solutionTSConfig) return solutionTSConfig;
    }
    return result;
}
function util_isIncluded(filename, result) {
    const dir = util_native2posix(node_path.dirname(result.tsconfigFile));
    const files = (result.tsconfig.files || []).map((file)=>resolve2posix(dir, file));
    const absoluteFilename = resolve2posix(null, filename);
    if (files.includes(filename)) return true;
    const allowJs = result.tsconfig.compilerOptions?.allowJs;
    const isIncluded = isGlobMatch(absoluteFilename, dir, result.tsconfig.include || (result.tsconfig.files ? [] : [
        GLOB_ALL_PATTERN
    ]), allowJs);
    if (isIncluded) {
        const isExcluded = isGlobMatch(absoluteFilename, dir, result.tsconfig.exclude || [], allowJs);
        return !isExcluded;
    }
    return false;
}
function isGlobMatch(filename, dir, patterns, allowJs) {
    const extensions = allowJs ? TSJS_EXTENSIONS : TS_EXTENSIONS;
    return patterns.some((pattern)=>{
        let lastWildcardIndex = pattern.length;
        let hasWildcard = false;
        let hasExtension = false;
        let hasSlash = false;
        let lastSlashIndex = -1;
        for(let i = pattern.length - 1; i > -1; i--){
            const c = pattern[i];
            if (!hasWildcard) {
                if ('*' === c || '?' === c) {
                    lastWildcardIndex = i;
                    hasWildcard = true;
                }
            }
            if (!hasSlash) {
                if ('.' === c) hasExtension = true;
                else if ('/' === c) {
                    lastSlashIndex = i;
                    hasSlash = true;
                }
            }
            if (hasWildcard && hasSlash) break;
        }
        if (!hasExtension && (!hasWildcard || lastWildcardIndex < lastSlashIndex)) {
            pattern += `${pattern.endsWith('/') ? '' : '/'}${GLOB_ALL_PATTERN}`;
            lastWildcardIndex = pattern.length - 1;
            hasWildcard = true;
        }
        if (lastWildcardIndex < pattern.length - 1 && !filename.endsWith(pattern.slice(lastWildcardIndex + 1))) return false;
        if (pattern.endsWith('*') && !extensions.some((ext)=>filename.endsWith(ext))) return false;
        if (pattern === GLOB_ALL_PATTERN) return filename.startsWith(`${dir}/`);
        const resolvedPattern = resolve2posix(dir, pattern);
        let firstWildcardIndex = -1;
        for(let i = 0; i < resolvedPattern.length; i++)if ('*' === resolvedPattern[i] || '?' === resolvedPattern[i]) {
            firstWildcardIndex = i;
            hasWildcard = true;
            break;
        }
        if (firstWildcardIndex > 1 && !filename.startsWith(resolvedPattern.slice(0, firstWildcardIndex - 1))) return false;
        if (!hasWildcard) return filename === resolvedPattern;
        if (firstWildcardIndex + GLOB_ALL_PATTERN.length === resolvedPattern.length - (pattern.length - 1 - lastWildcardIndex) && resolvedPattern.slice(firstWildcardIndex, firstWildcardIndex + GLOB_ALL_PATTERN.length) === GLOB_ALL_PATTERN) return true;
        if (PATTERN_REGEX_CACHE.has(resolvedPattern)) return PATTERN_REGEX_CACHE.get(resolvedPattern).test(filename);
        const regex = pattern2regex(resolvedPattern, allowJs);
        PATTERN_REGEX_CACHE.set(resolvedPattern, regex);
        return regex.test(filename);
    });
}
function pattern2regex(resolvedPattern, allowJs) {
    let regexStr = '^';
    for(let i = 0; i < resolvedPattern.length; i++){
        const char = resolvedPattern[i];
        if ('?' === char) {
            regexStr += '[^\\/]';
            continue;
        }
        if ('*' === char) {
            if ('*' === resolvedPattern[i + 1] && '/' === resolvedPattern[i + 2]) {
                i += 2;
                regexStr += '(?:[^\\/]*\\/)*';
                continue;
            }
            regexStr += '[^\\/]*';
            continue;
        }
        if ('/.+^${}()|[]\\'.includes(char)) regexStr += "\\";
        regexStr += char;
    }
    if (resolvedPattern.endsWith('*')) regexStr += allowJs ? TSJS_EXTENSIONS_RE_GROUP : TS_EXTENSIONS_RE_GROUP;
    regexStr += '$';
    return new RegExp(regexStr);
}
function util_replaceTokens(result) {
    if (result.tsconfig) result.tsconfig = JSON.parse(JSON.stringify(result.tsconfig).replaceAll(/"\${configDir}/g, `"${util_native2posix(node_path.dirname(result.tsconfigFile))}`));
}
async function find(filename, options) {
    let dir = node_path.dirname(node_path.resolve(filename));
    if (options?.ignoreNodeModules && util_isInNodeModules(dir)) return null;
    const cache = options?.cache;
    const configName = options?.configName ?? 'tsconfig.json';
    if (cache?.hasConfigPath(dir, configName)) return cache.getConfigPath(dir, configName);
    const { promise, resolve, reject } = util_makePromise();
    if (options?.root && !node_path.isAbsolute(options.root)) options.root = node_path.resolve(options.root);
    findUp(dir, {
        promise,
        resolve,
        reject
    }, options);
    return promise;
}
function findUp(dir, { resolve, reject, promise }, options) {
    const { cache, root, configName } = options ?? {};
    if (cache) if (cache.hasConfigPath(dir, configName)) {
        let cached;
        try {
            cached = cache.getConfigPath(dir, configName);
        } catch (e) {
            reject(e);
            return;
        }
        if (cached?.then) cached.then(resolve).catch(reject);
        else resolve(cached);
    } else cache.setConfigPath(dir, promise, configName);
    const tsconfig = node_path.join(dir, options?.configName ?? 'tsconfig.json');
    node_fs.stat(tsconfig, (err, stats)=>{
        if (stats && (stats.isFile() || stats.isFIFO())) resolve(tsconfig);
        else if (err?.code !== 'ENOENT') reject(err);
        else {
            let parent;
            if (root === dir || (parent = node_path.dirname(dir)) === dir) resolve(null);
            else findUp(parent, {
                promise,
                resolve,
                reject
            }, options);
        }
    });
}
node_path.sep;
function toJson(tsconfigJson) {
    const stripped = stripDanglingComma(stripJsonComments(stripBom(tsconfigJson)));
    if ('' === stripped.trim()) return '{}';
    return stripped;
}
function stripDanglingComma(pseudoJson) {
    let insideString = false;
    let offset = 0;
    let result = '';
    let danglingCommaPos = null;
    for(let i = 0; i < pseudoJson.length; i++){
        const currentCharacter = pseudoJson[i];
        if ('"' === currentCharacter) {
            const escaped = isEscaped(pseudoJson, i);
            if (!escaped) insideString = !insideString;
        }
        if (insideString) {
            danglingCommaPos = null;
            continue;
        }
        if (',' === currentCharacter) {
            danglingCommaPos = i;
            continue;
        }
        if (danglingCommaPos) {
            if ('}' === currentCharacter || ']' === currentCharacter) {
                result += pseudoJson.slice(offset, danglingCommaPos) + ' ';
                offset = danglingCommaPos + 1;
                danglingCommaPos = null;
            } else if (!currentCharacter.match(/\s/)) danglingCommaPos = null;
        }
    }
    return result + pseudoJson.substring(offset);
}
function isEscaped(jsonString, quotePosition) {
    let index = quotePosition - 1;
    let backslashCount = 0;
    while('\\' === jsonString[index]){
        index -= 1;
        backslashCount += 1;
    }
    return Boolean(backslashCount % 2);
}
function strip(string, start, end) {
    return string.slice(start, end).replace(/\S/g, ' ');
}
const singleComment = Symbol('singleComment');
const multiComment = Symbol('multiComment');
function stripJsonComments(jsonString) {
    let isInsideString = false;
    let isInsideComment = false;
    let offset = 0;
    let result = '';
    for(let index = 0; index < jsonString.length; index++){
        const currentCharacter = jsonString[index];
        const nextCharacter = jsonString[index + 1];
        if (!isInsideComment && '"' === currentCharacter) {
            const escaped = isEscaped(jsonString, index);
            if (!escaped) isInsideString = !isInsideString;
        }
        if (!isInsideString) if (isInsideComment || currentCharacter + nextCharacter !== '//') if (isInsideComment === singleComment && currentCharacter + nextCharacter === '\r\n') {
            index++;
            isInsideComment = false;
            result += strip(jsonString, offset, index);
            offset = index;
        } else if (isInsideComment === singleComment && '\n' === currentCharacter) {
            isInsideComment = false;
            result += strip(jsonString, offset, index);
            offset = index;
        } else if (isInsideComment || currentCharacter + nextCharacter !== '/*') {
            if (isInsideComment === multiComment && currentCharacter + nextCharacter === '*/') {
                index++;
                isInsideComment = false;
                result += strip(jsonString, offset, index + 1);
                offset = index + 1;
            }
        } else {
            result += jsonString.slice(offset, index);
            offset = index;
            isInsideComment = multiComment;
            index++;
        }
        else {
            result += jsonString.slice(offset, index);
            offset = index;
            isInsideComment = singleComment;
            index++;
        }
    }
    return result + (isInsideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));
}
function stripBom(string) {
    if (0xfeff === string.charCodeAt(0)) return string.slice(1);
    return string;
}
const not_found_result = {
    tsconfigFile: null,
    tsconfig: {}
};
async function parse_parse(filename, options) {
    const cache = options?.cache;
    if (cache?.hasParseResult(filename)) return getParsedDeep(filename, cache, options);
    const { resolve, reject, promise } = util_makePromise();
    cache?.setParseResult(filename, promise, true);
    try {
        let tsconfigFile = await util_resolveTSConfigJson(filename, cache) || await find(filename, options);
        if (!tsconfigFile) {
            resolve(not_found_result);
            return promise;
        }
        let result;
        if (filename !== tsconfigFile && cache?.hasParseResult(tsconfigFile)) result = await getParsedDeep(tsconfigFile, cache, options);
        else {
            result = await parseFile(tsconfigFile, cache, filename === tsconfigFile);
            await Promise.all([
                parseExtends(result, cache),
                parseReferences(result, options)
            ]);
        }
        util_replaceTokens(result);
        resolve(util_resolveSolutionTSConfig(filename, result));
    } catch (e) {
        reject(e);
    }
    return promise;
}
async function getParsedDeep(filename, cache, options) {
    const result = await cache.getParseResult(filename);
    if (result.tsconfig.extends && !result.extended || result.tsconfig.references && !result.referenced) {
        const promise = Promise.all([
            parseExtends(result, cache),
            parseReferences(result, options)
        ]).then(()=>result);
        cache.setParseResult(filename, promise, true);
        return promise;
    }
    return result;
}
async function parseFile(tsconfigFile, cache, skipCache) {
    if (!skipCache && cache?.hasParseResult(tsconfigFile) && !cache.getParseResult(tsconfigFile)._isRootFile_) return cache.getParseResult(tsconfigFile);
    const promise = promises.readFile(tsconfigFile, 'utf-8').then(toJson).then((json)=>{
        const parsed = JSON.parse(json);
        applyDefaults(parsed, tsconfigFile);
        return {
            tsconfigFile,
            tsconfig: normalizeTSConfig(parsed, node_path.dirname(tsconfigFile))
        };
    }).catch((e)=>{
        throw new TSConfckParseError(`parsing ${tsconfigFile} failed: ${e}`, 'PARSE_FILE', tsconfigFile, e);
    });
    if (!skipCache && (!cache?.hasParseResult(tsconfigFile) || !cache.getParseResult(tsconfigFile)._isRootFile_)) cache?.setParseResult(tsconfigFile, promise);
    return promise;
}
function normalizeTSConfig(tsconfig, dir) {
    const baseUrl = tsconfig.compilerOptions?.baseUrl;
    if (baseUrl && !baseUrl.startsWith('${') && !node_path.isAbsolute(baseUrl)) tsconfig.compilerOptions.baseUrl = resolve2posix(dir, baseUrl);
    return tsconfig;
}
async function parseReferences(result, options) {
    if (!result.tsconfig.references) return;
    const referencedFiles = util_resolveReferencedTSConfigFiles(result, options);
    const referenced = await Promise.all(referencedFiles.map((file)=>parseFile(file, options?.cache)));
    await Promise.all(referenced.map((ref)=>parseExtends(ref, options?.cache)));
    referenced.forEach((ref)=>{
        ref.solution = result;
        util_replaceTokens(ref);
    });
    result.referenced = referenced;
}
async function parseExtends(result, cache) {
    if (!result.tsconfig.extends) return;
    const extended = [
        {
            tsconfigFile: result.tsconfigFile,
            tsconfig: JSON.parse(JSON.stringify(result.tsconfig))
        }
    ];
    let pos = 0;
    const extendsPath = [];
    let currentBranchDepth = 0;
    while(pos < extended.length){
        const extending = extended[pos];
        extendsPath.push(extending.tsconfigFile);
        if (extending.tsconfig.extends) {
            currentBranchDepth += 1;
            let resolvedExtends;
            resolvedExtends = Array.isArray(extending.tsconfig.extends) ? extending.tsconfig.extends.reverse().map((ex)=>resolveExtends(ex, extending.tsconfigFile)) : [
                resolveExtends(extending.tsconfig.extends, extending.tsconfigFile)
            ];
            const circularExtends = resolvedExtends.find((tsconfigFile)=>extendsPath.includes(tsconfigFile));
            if (circularExtends) {
                const circle = extendsPath.concat([
                    circularExtends
                ]).join(' -> ');
                throw new TSConfckParseError(`Circular dependency in "extends": ${circle}`, 'EXTENDS_CIRCULAR', result.tsconfigFile);
            }
            extended.splice(pos + 1, 0, ...await Promise.all(resolvedExtends.map((file)=>parseFile(file, cache))));
        } else {
            extendsPath.splice(-currentBranchDepth);
            currentBranchDepth = 0;
        }
        pos += 1;
    }
    result.extended = extended;
    for (const ext of result.extended.slice(1))extendTSConfig(result, ext);
}
function resolveExtends(extended, from) {
    if ([
        '.',
        '..'
    ].includes(extended)) extended += '/tsconfig.json';
    const req = external_module_createRequire(from);
    let error;
    try {
        return req.resolve(extended);
    } catch (e) {
        error = e;
    }
    if ('.' !== extended[0] && !node_path.isAbsolute(extended)) try {
        return req.resolve(`${extended}/tsconfig.json`);
    } catch (e) {
        error = e;
    }
    throw new TSConfckParseError(`failed to resolve "extends":"${extended}" in ${from}`, 'EXTENDS_RESOLVE', from, error);
}
const EXTENDABLE_KEYS = [
    'compilerOptions',
    'files',
    'include',
    'exclude',
    'watchOptions',
    'compileOnSave',
    'typeAcquisition',
    'buildOptions'
];
function extendTSConfig(extending, extended) {
    const extendingConfig = extending.tsconfig;
    const extendedConfig = extended.tsconfig;
    const relativePath = util_native2posix(node_path.relative(node_path.dirname(extending.tsconfigFile), node_path.dirname(extended.tsconfigFile)));
    for (const key of Object.keys(extendedConfig).filter((key)=>EXTENDABLE_KEYS.includes(key)))if ('compilerOptions' === key) {
        if (!extendingConfig.compilerOptions) extendingConfig.compilerOptions = {};
        for (const option of Object.keys(extendedConfig.compilerOptions))if (!Object.prototype.hasOwnProperty.call(extendingConfig.compilerOptions, option)) extendingConfig.compilerOptions[option] = rebaseRelative(option, extendedConfig.compilerOptions[option], relativePath);
    } else if (void 0 === extendingConfig[key]) if ('watchOptions' === key) {
        extendingConfig.watchOptions = {};
        for (const option of Object.keys(extendedConfig.watchOptions))extendingConfig.watchOptions[option] = rebaseRelative(option, extendedConfig.watchOptions[option], relativePath);
    } else extendingConfig[key] = rebaseRelative(key, extendedConfig[key], relativePath);
}
const REBASE_KEYS = [
    'files',
    'include',
    'exclude',
    'baseUrl',
    'rootDir',
    'rootDirs',
    'typeRoots',
    'outDir',
    'outFile',
    'declarationDir',
    'excludeDirectories',
    'excludeFiles'
];
function rebaseRelative(key, value, prependPath) {
    if (!REBASE_KEYS.includes(key)) return value;
    if (Array.isArray(value)) return value.map((x)=>rebasePath(x, prependPath));
    return rebasePath(value, prependPath);
}
function rebasePath(value, prependPath) {
    if (node_path.isAbsolute(value) || value.startsWith('${configDir}')) return value;
    return node_path.posix.normalize(node_path.posix.join(prependPath, value));
}
class TSConfckParseError extends Error {
    code;
    cause;
    tsconfigFile;
    constructor(message, code, tsconfigFile, cause){
        super(message);
        Object.setPrototypeOf(this, TSConfckParseError.prototype);
        this.name = TSConfckParseError.name;
        this.code = code;
        this.cause = cause;
        this.tsconfigFile = tsconfigFile;
    }
}
function applyDefaults(tsconfig, tsconfigFile) {
    if (isJSConfig(tsconfigFile)) tsconfig.compilerOptions = {
        ...DEFAULT_JSCONFIG_COMPILER_OPTIONS,
        ...tsconfig.compilerOptions
    };
}
const DEFAULT_JSCONFIG_COMPILER_OPTIONS = {
    allowJs: true,
    maxNodeModuleJsDepth: 2,
    allowSyntheticDefaultImports: true,
    skipLibCheck: true,
    noEmit: true
};
function isJSConfig(configFileName) {
    return 'jsconfig.json' === node_path.basename(configFileName);
}
async function loadTsconfig(root, tsconfigPath = 'tsconfig.json') {
    const tsconfigFileName = await find(join(root, tsconfigPath), {
        root,
        configName: external_node_path_basename(tsconfigPath)
    });
    if (tsconfigFileName) {
        const { tsconfig } = await parse_parse(tsconfigFileName);
        return tsconfig;
    }
    return {};
}
function defineConfig(config) {
    return config;
}
const findConfig = (basePath)=>DEFAULT_CONFIG_EXTENSIONS.map((ext)=>basePath + ext).find(node_fs.existsSync);
const resolveConfigPath = (root, customConfig)=>{
    if (customConfig) {
        const customConfigPath = isAbsolute(customConfig) ? customConfig : join(root, customConfig);
        if (node_fs.existsSync(customConfigPath)) return customConfigPath;
        logger.warn(`Cannot find config file: ${picocolors.dim(customConfigPath)}\n`);
    }
    const configFilePath = findConfig(join(root, DEFAULT_CONFIG_NAME));
    if (configFilePath) return configFilePath;
};
async function loadConfig({ cwd = process.cwd(), path, envMode, loader }) {
    const configFilePath = resolveConfigPath(cwd, path);
    if (!configFilePath) return {
        content: {
            lib: []
        },
        filePath: void 0
    };
    const { content } = await (0, __rspack_external__rsbuild_core_1b356efc.loadConfig)({
        cwd: dirname(configFilePath),
        path: configFilePath,
        envMode,
        loader
    });
    return {
        content: content,
        filePath: configFilePath
    };
}
const handleMatchedExternal = (value, request)=>{
    if ('boolean' == typeof value) return value;
    if ('string' == typeof value) {
        const [first, second] = value.split(' ');
        const hasType = !!second;
        const _request = second ? second : first;
        if (!hasType) return request === _request;
        return false;
    }
    if (Array.isArray(value)) return handleMatchedExternal(value[0] ?? '', request);
    return false;
};
const composeExternalsWarnConfig = (format, ...externalsArray)=>{
    if ('esm' !== format) return {};
    const externals = [];
    for (const e of externalsArray.filter(Boolean))if (Array.isArray(e)) externals.push(...e);
    else externals.push(e);
    const matchUserExternals = (externals, request, callback)=>{
        if ('string' == typeof externals) {
            if (handleMatchedExternal(externals, request)) return void callback(true, true);
        }
        if (Array.isArray(externals)) {
            let i = 0;
            const next = ()=>{
                let asyncFlag;
                const handleExternalsAndCallback = (matched, shouldWarn)=>{
                    if (!matched) {
                        if (asyncFlag) {
                            asyncFlag = false;
                            return;
                        }
                        next();
                        return;
                    }
                    callback(matched, shouldWarn);
                };
                do {
                    asyncFlag = true;
                    if (i >= externals.length) return void callback(false);
                    matchUserExternals(externals[i++], request, handleExternalsAndCallback);
                }while (!asyncFlag);
                asyncFlag = false;
            };
            next();
            return;
        }
        if (externals instanceof RegExp) {
            if (externals.test(request)) return void callback(true, true);
        } else if ('function' == typeof externals) ;
        else if ('object' == typeof externals) {
            if (Object.hasOwn(externals, request)) return void (handleMatchedExternal(externals[request], request) ? callback(true, true) : callback(true));
        }
        callback(false);
    };
    return {
        output: {
            externals: [
                ({ request, dependencyType, contextInfo }, callback)=>{
                    let shouldWarn = false;
                    const _callback = (_matched, _shouldWarn)=>{
                        if (_shouldWarn) shouldWarn = true;
                    };
                    if (contextInfo.issuer && 'commonjs' === dependencyType) {
                        matchUserExternals(externals, request, _callback);
                        if (shouldWarn) logger.warn(composeModuleImportWarn(request, contextInfo.issuer));
                    }
                    callback();
                }
            ]
        }
    };
};
const getAutoExternalDefaultValue = (format, autoExternal)=>autoExternal ?? isIntermediateOutputFormat(format);
const composeAutoExternalConfig = (options)=>{
    const { bundle, format, pkgJson, userExternals } = options;
    if (!bundle) return {};
    const autoExternal = getAutoExternalDefaultValue(format, options.autoExternal);
    if (false === autoExternal) return {};
    if (!pkgJson) {
        logger.warn('The `autoExternal` configuration will not be applied due to read package.json failed');
        return {};
    }
    const userExternalKeys = userExternals && isObject(userExternals) ? Object.keys(userExternals) : [];
    const externalOptions = {
        dependencies: true,
        optionalDependencies: true,
        peerDependencies: true,
        devDependencies: false,
        ...true === autoExternal ? {} : autoExternal
    };
    const externals = [
        'dependencies',
        'peerDependencies',
        'devDependencies',
        'optionalDependencies'
    ].reduce((prev, type)=>{
        if (externalOptions[type]) return pkgJson[type] ? prev.concat(Object.keys(pkgJson[type])) : prev;
        return prev;
    }, []).filter((name)=>!userExternalKeys.includes(name));
    const uniqueExternals = Array.from(new Set(externals));
    return externals.length ? {
        output: {
            externals: [
                ...uniqueExternals.map((dep)=>new RegExp(`^${dep}($|\\/|\\\\)`)),
                ...uniqueExternals
            ]
        }
    } : {};
};
function composeMinifyConfig(config) {
    const minify = config.output?.minify;
    const format = config.format;
    if (void 0 !== minify) return {};
    return {
        output: {
            minify: {
                js: true,
                css: false,
                jsOptions: {
                    test: /\.[cm]?jsx?(\?.*)?$/,
                    minimizerOptions: {
                        mangle: false,
                        minify: 'mf' === format,
                        compress: {
                            directives: false,
                            defaults: false,
                            unused: true,
                            dead_code: true,
                            toplevel: 'mf' !== format
                        },
                        format: {
                            comments: 'some',
                            preserve_annotations: true
                        }
                    }
                }
            }
        }
    };
}
function composeBannerFooterConfig(banner, footer) {
    const bannerConfig = pick(banner, [
        'js',
        'css'
    ]);
    const footerConfig = pick(footer, [
        'js',
        'css'
    ]);
    if (isEmptyObject(bannerConfig) && isEmptyObject(footerConfig)) return {};
    const plugins = [];
    if (!isEmptyObject(bannerConfig)) {
        if (bannerConfig.js) plugins.push(new __rspack_external__rsbuild_core_1b356efc.rspack.BannerPlugin({
            banner: bannerConfig.js,
            stage: __rspack_external__rsbuild_core_1b356efc.rspack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE + 1,
            raw: true,
            include: /\.(js|mjs|cjs)$/
        }));
        if (bannerConfig.css) plugins.push(new __rspack_external__rsbuild_core_1b356efc.rspack.BannerPlugin({
            banner: bannerConfig.css,
            stage: __rspack_external__rsbuild_core_1b356efc.rspack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE + 1,
            raw: true,
            include: /\.(css)$/
        }));
    }
    if (!isEmptyObject(footerConfig)) {
        if (footerConfig.js) plugins.push(new __rspack_external__rsbuild_core_1b356efc.rspack.BannerPlugin({
            banner: footerConfig.js,
            stage: __rspack_external__rsbuild_core_1b356efc.rspack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE + 1,
            raw: true,
            footer: true,
            include: /\.(js|mjs|cjs)$/
        }));
        if (footerConfig.css) plugins.push(new __rspack_external__rsbuild_core_1b356efc.rspack.BannerPlugin({
            banner: footerConfig.css,
            stage: __rspack_external__rsbuild_core_1b356efc.rspack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE + 1,
            raw: true,
            footer: true,
            include: /\.(css)$/
        }));
    }
    return {
        tools: {
            rspack: {
                plugins
            }
        }
    };
}
function composeDecoratorsConfig(compilerOptions, version) {
    if (version || !compilerOptions?.experimentalDecorators) return {};
    return {
        source: {
            decorators: {
                version: 'legacy'
            }
        }
    };
}
function composePrintFileSizeConfig(bundle, target) {
    if (bundle) return {};
    return {
        performance: {
            printFileSize: {
                total: ({ environmentName, distPath, assets, totalSize, totalGzipSize })=>{
                    let log = `${picocolors.yellow(assets.length)} files generated in ${picocolors.cyan(distPath)}, ${picocolors.magenta('total:')} ${(totalSize / 1000).toFixed(1)} kB`;
                    if ('web' === target) log += ` ${picocolors.green(`(${(totalGzipSize / 1000).toFixed(1)} kB gzipped)`)}`;
                    log += ` ${picocolors.dim(`(${environmentName})`)}`;
                    return log;
                },
                detail: false
            }
        }
    };
}
async function createConstantRsbuildConfig() {
    return (0, __rspack_external__rsbuild_core_1b356efc.defineConfig)({
        performance: {
            chunkSplit: {
                strategy: 'custom'
            },
            buildCache: true
        },
        tools: {
            htmlPlugin: false,
            rspack: {
                optimization: {
                    moduleIds: 'named',
                    nodeEnv: false
                },
                experiments: {
                    rspackFuture: {
                        bundlerInfo: {
                            force: false
                        }
                    }
                },
                resolve: {
                    extensionAlias: {
                        '.js': [
                            '.ts',
                            '.tsx',
                            '.js',
                            '.jsx'
                        ],
                        '.jsx': [
                            '.tsx',
                            '.jsx'
                        ],
                        '.mjs': [
                            '.mts',
                            '.mjs'
                        ],
                        '.cjs': [
                            '.cts',
                            '.cjs'
                        ]
                    }
                }
            }
        },
        output: {
            target: 'node',
            distPath: {
                js: './',
                jsAsync: './',
                css: './',
                cssAsync: './'
            }
        }
    });
}
const composeFormatConfig = ({ format, bundle = true, umdName, pkgJson, enabledShims, advancedEsm })=>{
    const jsParserOptions = {
        cjs: {
            requireResolve: false,
            requireDynamic: false,
            requireAsExpression: false
        },
        esm: {
            importMeta: false,
            importDynamic: false,
            commonjs: {
                exports: 'skipInEsm'
            }
        },
        others: {
            worker: false
        }
    };
    const experimentalEsmOutput = bundle && 'esm' === format && advancedEsm;
    const plugins = [
        new __rspack_external__rsbuild_core_1b356efc.rspack.experiments.RslibPlugin({
            interceptApiPlugin: true,
            forceNodeShims: enabledShims.esm.__dirname || enabledShims.esm.__filename
        }),
        experimentalEsmOutput && new __rspack_external__rsbuild_core_1b356efc.rspack.experiments.EsmLibraryPlugin()
    ].filter(Boolean);
    switch(format){
        case 'esm':
            return {
                output: {
                    filenameHash: false
                },
                tools: {
                    rspack: {
                        module: {
                            parser: {
                                javascript: {
                                    ...jsParserOptions.esm,
                                    ...jsParserOptions.cjs,
                                    ...jsParserOptions.others
                                }
                            }
                        },
                        optimization: {
                            concatenateModules: !experimentalEsmOutput,
                            sideEffects: experimentalEsmOutput ? true : 'flag',
                            runtimeChunk: experimentalEsmOutput ? {
                                name: 'rslib-runtime'
                            } : void 0,
                            avoidEntryIife: true,
                            splitChunks: {
                                chunks: 'async'
                            }
                        },
                        output: {
                            module: true,
                            chunkFormat: experimentalEsmOutput ? false : 'module',
                            library: {
                                type: 'modern-module'
                            },
                            chunkLoading: 'import',
                            workerChunkLoading: 'import'
                        },
                        experiments: {
                            outputModule: true
                        },
                        plugins
                    }
                }
            };
        case 'cjs':
            return {
                output: {
                    filenameHash: false
                },
                tools: {
                    rspack: {
                        module: {
                            parser: {
                                javascript: {
                                    ...jsParserOptions.esm,
                                    ...jsParserOptions.cjs,
                                    ...jsParserOptions.others
                                }
                            }
                        },
                        optimization: {
                            splitChunks: {
                                chunks: 'async'
                            }
                        },
                        output: {
                            iife: false,
                            chunkFormat: 'commonjs',
                            library: {
                                type: 'commonjs-static'
                            },
                            chunkLoading: 'require',
                            workerChunkLoading: 'async-node'
                        },
                        plugins
                    }
                }
            };
        case 'umd':
            {
                if (!bundle) throw new Error('When using "umd" format, "bundle" must be set to "true". Since the default value for "bundle" is "true", so you can either explicitly set it to "true" or remove the field entirely.');
                const config = {
                    output: {
                        filenameHash: false
                    },
                    tools: {
                        rspack: {
                            module: {
                                parser: {
                                    javascript: {
                                        importMeta: false
                                    }
                                }
                            },
                            output: {
                                asyncChunks: false,
                                library: umdName ? {
                                    type: 'umd',
                                    name: umdName
                                } : {
                                    type: 'umd'
                                }
                            },
                            optimization: {
                                nodeEnv: process.env.NODE_ENV,
                                splitChunks: false
                            },
                            plugins
                        }
                    }
                };
                return config;
            }
        case 'iife':
            {
                if (!bundle) throw new Error('When using "iife" format, "bundle" must be set to "true". Since the default value for "bundle" is "true", so you can either explicitly set it to "true" or remove the field entirely.');
                const config = {
                    output: {
                        filenameHash: false,
                        minify: {
                            jsOptions: {
                                minimizerOptions: {
                                    module: true
                                }
                            }
                        }
                    },
                    tools: {
                        rspack: {
                            module: {
                                parser: {
                                    javascript: {
                                        importMeta: false
                                    }
                                }
                            },
                            output: {
                                iife: true,
                                asyncChunks: false,
                                library: {
                                    type: 'modern-module'
                                }
                            },
                            optimization: {
                                nodeEnv: process.env.NODE_ENV,
                                splitChunks: false
                            },
                            plugins
                        }
                    }
                };
                return config;
            }
        case 'mf':
            if (!bundle) throw new Error('When using "mf" format, "bundle" must be set to "true". Since the default value for "bundle" is "true", so you can either explicitly set it to "true" or remove the field entirely.');
            return {
                dev: {
                    writeToDisk: true
                },
                tools: {
                    rspack: (config, { env })=>{
                        config.output = {
                            ...config.output,
                            uniqueName: pkgJson.name
                        };
                        config.optimization = {
                            ...config.optimization,
                            nodeEnv: 'development' === env ? 'development' : 'production',
                            moduleIds: 'development' === env ? 'named' : 'deterministic'
                        };
                    }
                },
                output: {
                    target: 'web'
                }
            };
        default:
            throw new Error(`Unsupported format: ${format}`);
    }
};
const disableUrlParseRsbuildPlugin = ()=>({
        name: 'rsbuild:disable-url-parse',
        setup (api) {
            api.modifyBundlerChain((config, { CHAIN_ID })=>{
                config.module.rule(CHAIN_ID.RULE.JS).parser({
                    url: false
                });
            });
        }
    });
const fixJsModuleTypePlugin = ()=>({
        name: 'rsbuild:fix-js-module-type',
        setup (api) {
            api.modifyBundlerChain((config, { CHAIN_ID })=>{
                config.module.rule(CHAIN_ID.RULE.JS).delete('type');
            });
        }
    });
const BundlePlugin = ()=>({
        name: 'rslib:bundle',
        setup (api) {
            api.onBeforeBuild({
                order: 'post',
                handler: ({ bundlerConfigs })=>{
                    if (bundlerConfigs) {
                        for (const config of bundlerConfigs)if (config?.module?.parser?.javascript?.jsx === true) {
                            logger.error('Bundle mode does not support preserving JSX syntax. Set "bundle" to "false" or change the JSX runtime to `automatic` or `classic`. Check out ' + picocolors.green('https://rslib.rs/guide/solution/react#jsx-transform') + ' for more details.');
                            process.exit(1);
                        }
                    }
                }
            });
        }
    });
const composeBundleConfig = (bundle)=>{
    if (bundle) return {
        rsbuildConfig: {
            plugins: [
                BundlePlugin()
            ]
        }
    };
    return {
        rsbuildConfig: {}
    };
};
const composeShimsConfig = (format, shims)=>{
    const resolvedShims = {
        cjs: {
            'import.meta.url': shims?.cjs?.['import.meta.url'] ?? true
        },
        esm: {
            __filename: shims?.esm?.__filename ?? false,
            __dirname: shims?.esm?.__dirname ?? false,
            require: shims?.esm?.require ?? false
        }
    };
    const enabledShims = {
        cjs: 'cjs' === format ? resolvedShims.cjs : {
            'import.meta.url': false
        },
        esm: 'esm' === format ? resolvedShims.esm : {
            __filename: false,
            __dirname: false,
            require: false
        }
    };
    let rsbuildConfig = {};
    switch(format){
        case 'esm':
            rsbuildConfig = {
                tools: {
                    rspack: {
                        node: {
                            __dirname: resolvedShims.esm.__dirname ? 'node-module' : false,
                            __filename: resolvedShims.esm.__filename ? 'node-module' : false
                        }
                    }
                },
                plugins: [
                    resolvedShims.esm.require && pluginEsmRequireShim(),
                    disableUrlParseRsbuildPlugin(),
                    fixJsModuleTypePlugin()
                ].filter(Boolean)
            };
            break;
        case 'cjs':
            rsbuildConfig = {
                plugins: [
                    resolvedShims.cjs['import.meta.url'] && pluginCjsImportMetaUrlShim(),
                    disableUrlParseRsbuildPlugin(),
                    fixJsModuleTypePlugin()
                ].filter(Boolean)
            };
            break;
        case 'umd':
        case 'iife':
        case 'mf':
            rsbuildConfig = {
                plugins: [
                    fixJsModuleTypePlugin()
                ]
            };
            break;
        default:
            throw new Error(`Unsupported format: ${format}`);
    }
    return {
        rsbuildConfig,
        enabledShims
    };
};
const composeModuleImportWarn = (request, issuer)=>`The externalized commonjs request ${picocolors.green(`"${request}"`)} from ${picocolors.green(issuer)} will use ${picocolors.blue('"module"')} external type in ESM format. If you want to specify other external type, consider setting the request and type with ${picocolors.blue('"output.externals"')}.`;
const composeExternalsConfig = (format, externals)=>{
    const externalsTypeMap = {
        esm: 'module-import',
        cjs: 'commonjs-import',
        umd: 'umd',
        mf: 'global',
        iife: 'global'
    };
    const globalObjectMap = {
        esm: void 0,
        cjs: void 0,
        umd: void 0,
        mf: void 0,
        iife: 'globalThis'
    };
    const rspackConfig = {};
    const rsbuildConfig = {};
    switch(format){
        case 'esm':
        case 'cjs':
        case 'umd':
        case 'mf':
        case 'iife':
            rsbuildConfig.output = externals ? {
                externals
            } : {};
            rspackConfig.externalsType = externalsTypeMap[format];
            if (globalObjectMap[format]) rspackConfig.output = {
                globalObject: globalObjectMap[format]
            };
            break;
        default:
            throw new Error(`Unsupported format: ${format}`);
    }
    return {
        ...rsbuildConfig,
        tools: {
            rspack: rspackConfig
        }
    };
};
const composeOutputFilenameConfig = (config, format, autoExtension, multiCompilerIndex, pkgJson)=>{
    const { jsExtension, dtsExtension } = getDefaultExtension({
        format,
        pkgJson,
        autoExtension
    });
    const filenameHash = config.output?.filenameHash ?? false;
    const getHash = ()=>{
        if ('string' == typeof filenameHash) return filenameHash ? `.[${filenameHash}]` : '';
        return filenameHash ? '.[contenthash:8]' : '';
    };
    const inferChunkFilename = (filename)=>{
        if ('function' != typeof filename) {
            const hasName = filename.includes('[name]');
            const hasId = filename.includes('[id]');
            const hasChunkHash = filename.includes('[chunkhash]');
            const hasContentHash = filename.includes('[contenthash]');
            const multiCompilerPrefix = 'number' == typeof multiCompilerIndex ? `${multiCompilerIndex}~` : '';
            if (hasChunkHash || hasContentHash || hasName || hasId) return filename.replace(/(^|\/)([^/]*(?:\?|$))/, `$1${multiCompilerPrefix}$2`);
            return filename.replace(/(^|\/)([^/]*(?:\?|$))/, `$1${multiCompilerIndex}[id].$2`);
        }
    };
    const hash = getHash();
    const defaultJsFilename = `[name]${hash}${jsExtension}`;
    const userJsFilename = config.output?.filename?.js;
    const defaultJsChunkFilename = inferChunkFilename(userJsFilename ?? defaultJsFilename);
    const finalJsExtension = 'string' == typeof userJsFilename && userJsFilename ? extname(userJsFilename) : jsExtension;
    const chunkFilename = {
        tools: {
            rspack: {
                output: {
                    chunkFilename: defaultJsChunkFilename
                }
            }
        }
    };
    const finalConfig = userJsFilename ? chunkFilename : (0, __rspack_external__rsbuild_core_1b356efc.mergeRsbuildConfig)(chunkFilename, {
        output: {
            filename: {
                js: defaultJsFilename
            }
        }
    });
    return {
        config: 'mf' === format ? {} : finalConfig,
        jsExtension: finalJsExtension,
        dtsExtension
    };
};
const composeSyntaxConfig = (target, syntax)=>{
    if (syntax) return {
        tools: {
            rspack: (config)=>{
                config.target = transformSyntaxToRspackTarget(syntax);
            }
        },
        output: {
            overrideBrowserslist: transformSyntaxToBrowserslist(syntax, target)
        }
    };
    return {
        tools: {
            rspack: (config)=>{
                config.target = [
                    'es2022'
                ];
                return config;
            }
        },
        output: {
            overrideBrowserslist: ESX_TO_BROWSERSLIST.esnext(target)
        }
    };
};
const traverseEntryQuery = (entry, callback)=>{
    const newEntry = {};
    for (const [key, value] of Object.entries(entry)){
        let result = value;
        result = 'string' == typeof value ? callback(value) : Array.isArray(value) ? value.map(callback) : {
            ...value,
            import: 'string' == typeof value.import ? callback(value.import) : value.import.map(callback)
        };
        newEntry[key] = result;
    }
    return newEntry;
};
const resolveEntryPath = (entries, root)=>traverseEntryQuery(entries, (item)=>node_path.resolve(root, item));
const composeEntryConfig = async (rawEntry, bundle, root, cssModulesAuto, userOutBase)=>{
    let entries = rawEntry;
    if (!entries) {
        if (false !== bundle) return {
            entryConfig: {},
            outBase: null
        };
        entries = {
            index: 'src/**'
        };
    }
    if ('object' != typeof entries) throw new Error(`The ${picocolors.cyan('source.entry')} configuration should be an object, but received ${typeof entries}: ${picocolors.cyan(entries)}. Checkout ${picocolors.green('https://rslib.rs/config/rsbuild/source#sourceentry')} for more details.`);
    if (false !== bundle) {
        const entryErrorReasons = [];
        traverseEntryQuery(entries, (entry)=>{
            const entryAbsPath = node_path.isAbsolute(entry) ? entry : node_path.resolve(root, entry);
            const isDirLike = '' === node_path.extname(entryAbsPath);
            const dirError = `Glob pattern ${picocolors.cyan(`"${entry}"`)} is not supported when "bundle" is "true", considering "bundle" to "false" to use bundleless mode, or specify a file entry to bundle. See ${picocolors.green('https://rslib.rs/guide/basic/output-structure')} for more details.`;
            if (node_fs.existsSync(entryAbsPath)) {
                const stats = node_fs.statSync(entryAbsPath);
                if (!stats.isFile()) entryErrorReasons.push(dirError);
            } else if (isDirLike) entryErrorReasons.push(dirError);
            else entryErrorReasons.push(`Can't resolve the entry ${picocolors.cyan(`"${entry}"`)} at the location ${picocolors.cyan(entryAbsPath)}. Please ensure that the file exists.`);
            return entry;
        });
        if (entryErrorReasons.length) throw new AggregateError(entryErrorReasons.map((reason)=>new Error(reason)));
        return {
            entryConfig: {
                source: {
                    entry: resolveEntryPath(entries, root)
                }
            },
            outBase: null
        };
    }
    const scanGlobEntries = async (tryResolveOutBase)=>{
        const resolvedEntries = {};
        const resolveOutBase = async (resolvedEntryFiles)=>{
            if (void 0 !== userOutBase) return node_path.isAbsolute(userOutBase) ? userOutBase : node_path.resolve(root, userOutBase);
            const lcp = await calcLongestCommonPath(resolvedEntryFiles) ?? root;
            return lcp;
        };
        for (const key of Object.keys(entries)){
            const entry = entries[key];
            const entryFiles = Array.isArray(entry) ? entry : 'string' == typeof entry ? [
                entry
            ] : null;
            if (!entryFiles) throw new Error('Entry can only be a string or an array of strings for now');
            const globEntryFiles = await glob(entryFiles, {
                cwd: root,
                absolute: true,
                dot: true,
                ignore: [
                    '**/.DS_Store',
                    '**/Thumbs.db'
                ]
            });
            const resolvedEntryFiles = globEntryFiles.filter((i)=>!DTS_EXTENSIONS_PATTERN.test(i));
            if (0 === resolvedEntryFiles.length) {
                const error = new Error(`No entry files matching ${entryFiles.map((file)=>picocolors.cyan(file)).join(', ')}. Please ensure the entry pattern in ${picocolors.cyan('source.entry')} is correct and points to valid source files.`);
                error.stack = '';
                throw error;
            }
            const outBase = await resolveOutBase(resolvedEntryFiles);
            function getEntryName(file) {
                const { dir, name } = node_path.parse(node_path.relative(outBase, file));
                const entryFileName = node_path.join(dir, name);
                if (isCssGlobalFile(file, cssModulesAuto)) return `${RSLIB_CSS_ENTRY_FLAG}/${entryFileName}`;
                return entryFileName;
            }
            for (const file of resolvedEntryFiles){
                const entryName = getEntryName(file);
                if (resolvedEntries[entryName]) tryResolveOutBase && logger.warn(`Duplicate entry ${picocolors.cyan(entryName)} from ${picocolors.cyan(node_path.relative(root, file))} and ${picocolors.cyan(node_path.relative(root, resolvedEntries[entryName]))}, which may lead to the incorrect output, please rename the file.`);
                resolvedEntries[entryName] = file;
            }
        }
        if (tryResolveOutBase) {
            const outBase = await resolveOutBase(Object.values(resolvedEntries));
            return {
                resolvedEntries,
                outBase
            };
        }
        return {
            resolvedEntries,
            outBase: null
        };
    };
    const { outBase } = await scanGlobEntries(true);
    const entryConfig = {
        tools: {
            rspack: {
                entry: async ()=>{
                    const { resolvedEntries } = await scanGlobEntries(false);
                    return resolvedEntries;
                }
            }
        }
    };
    return {
        entryConfig,
        outBase
    };
};
const composeBundlelessExternalConfig = (jsExtension, redirect, cssModulesAuto, bundle, outBase)=>{
    if (bundle) return {
        config: {}
    };
    const styleRedirectPath = redirect.style?.path ?? true;
    const styleRedirectExtension = redirect.style?.extension ?? true;
    const jsRedirectPath = redirect.js?.path ?? true;
    const jsRedirectExtension = redirect.js?.extension ?? true;
    const assetRedirectPath = redirect.asset?.path ?? true;
    const assetRedirectExtension = redirect.asset?.extension ?? true;
    let resolver;
    return {
        resolvedJsRedirect: {
            path: jsRedirectPath,
            extension: jsRedirectExtension
        },
        config: {
            output: {
                externals: [
                    async (data, callback)=>{
                        const { request, getResolve, context, contextInfo } = data;
                        if (!request || !getResolve || !context || !contextInfo) return void callback();
                        const { issuer } = contextInfo;
                        const originExtension = extname(request);
                        if (!resolver) resolver = getResolve();
                        async function redirectPath(request) {
                            try {
                                let resolvedRequest = request;
                                resolvedRequest = await resolver(context, resolvedRequest);
                                if ('string' != typeof outBase) throw new Error(`outBase expect to be a string in bundleless mode, but got ${outBase}`);
                                const isSubpath = normalizeSlash(resolvedRequest).startsWith(`${normalizeSlash(outBase)}/`);
                                if (isSubpath) {
                                    resolvedRequest = normalizeSlash(node_path.relative(node_path.dirname(issuer), resolvedRequest));
                                    if (!resolvedRequest.startsWith('./') && !resolvedRequest.startsWith('../')) resolvedRequest = `./${resolvedRequest}`;
                                    return {
                                        path: resolvedRequest,
                                        isResolved: true
                                    };
                                }
                                return {
                                    path: void 0,
                                    isResolved: true
                                };
                            } catch (_e) {
                                logger.debug(`Failed to resolve module ${picocolors.green(`"${request}"`)} from ${picocolors.green(issuer)}. If it's an npm package, consider adding it to dependencies or peerDependencies in package.json to make it externalized.`);
                                return {
                                    path: request,
                                    isResolved: false
                                };
                            }
                        }
                        if (issuer) {
                            let resolvedRequest = request;
                            const { path: redirectedPath, isResolved } = await redirectPath(resolvedRequest);
                            const cssExternal = await cssExternalHandler(resolvedRequest, callback, jsExtension, cssModulesAuto, styleRedirectPath, styleRedirectExtension, redirectedPath, issuer);
                            if (false !== cssExternal) return cssExternal;
                            if (void 0 === redirectedPath) return void callback(void 0, request);
                            if (jsRedirectPath) resolvedRequest = redirectedPath;
                            if (resolvedRequest.startsWith('.') && isResolved) {
                                const ext = extname(resolvedRequest);
                                if (ext) if (JS_EXTENSIONS_PATTERN.test(resolvedRequest)) resolvedRequest = resolvedRequest.replace(/\.[^.]+$/, jsRedirectExtension ? jsExtension : JS_EXTENSIONS_PATTERN.test(originExtension) ? originExtension : '');
                                else {
                                    resolvedRequest = assetRedirectPath ? redirectedPath : request;
                                    if (assetRedirectExtension) resolvedRequest = resolvedRequest.replace(/\.[^.]+$/, jsExtension);
                                }
                                else if (jsRedirectExtension) {
                                    if (!jsRedirectPath && await isDirectory(join(dirname(issuer), resolvedRequest))) resolvedRequest = `${resolvedRequest.replace(/\/+$/, '')}/index`;
                                    resolvedRequest = `${resolvedRequest}${jsExtension}`;
                                }
                            }
                            callback(void 0, resolvedRequest);
                            return;
                        }
                        callback();
                    }
                ]
            }
        }
    };
};
const composeDtsConfig = async (libConfig, format, dtsExtension)=>{
    const { autoExternal, banner, footer, redirect } = libConfig;
    let { dts } = libConfig;
    if (false === dts || void 0 === dts) return {};
    if (true === dts) dts = {
        bundle: false
    };
    const { pluginDts } = await import("rsbuild-plugin-dts");
    return {
        plugins: [
            pluginDts({
                bundle: dts?.bundle,
                distPath: dts?.distPath,
                build: dts?.build,
                abortOnError: dts?.abortOnError,
                dtsExtension: dts?.autoExtension ? dtsExtension : '.d.ts',
                autoExternal: getAutoExternalDefaultValue(format, autoExternal),
                alias: dts?.alias,
                banner: banner?.dts,
                footer: footer?.dts,
                redirect: redirect?.dts,
                tsgo: dts?.tsgo
            })
        ]
    };
};
const composeTargetConfig = (userTarget, format)=>{
    const target = userTarget ?? ('mf' === format ? 'web' : 'node');
    switch(target){
        case 'web':
            return {
                config: {
                    tools: {
                        rspack: {
                            target: [
                                'web'
                            ]
                        }
                    }
                },
                target: 'web',
                externalsConfig: {}
            };
        case 'node':
            return {
                config: {
                    tools: {
                        rspack: {
                            externalsPresets: {
                                node: false
                            },
                            target: [
                                'node'
                            ]
                        }
                    },
                    output: {
                        target: 'node'
                    }
                },
                target: 'node',
                externalsConfig: {
                    output: {
                        externals: nodeBuiltInModules
                    }
                }
            };
        default:
            throw new Error(`Unsupported platform: ${target}`);
    }
};
const composeExternalHelpersConfig = (externalHelpers, pkgJson)=>{
    let defaultConfig = {
        tools: {
            swc: {
                jsc: {
                    externalHelpers: false
                }
            }
        }
    };
    if (externalHelpers) {
        const deps = [
            ...Object.keys(pkgJson?.dependencies ?? []),
            ...Object.keys(pkgJson?.devDependencies ?? [])
        ];
        if (!deps.includes(SWC_HELPERS)) {
            logger.error(`${picocolors.green('externalHelpers')} is enabled, but the ${picocolors.blue(SWC_HELPERS)} dependency declaration was not found in package.json.`);
            process.exit(1);
        }
        defaultConfig = Object.assign(defaultConfig, {
            output: {
                externals: new RegExp(`^${SWC_HELPERS}($|\\/|\\\\)`)
            }
        });
        defaultConfig.tools.swc.jsc.externalHelpers = true;
    }
    return defaultConfig;
};
async function composeLibRsbuildConfig(config, multiCompilerIndex, root, sharedPlugins) {
    checkMFPlugin(config, sharedPlugins);
    const rootPath = root ? getAbsolutePath(process.cwd(), root) : process.cwd();
    const pkgJson = readPackageJson(rootPath);
    const { compilerOptions } = await loadTsconfig(rootPath, config.source?.tsconfigPath);
    const cssModulesAuto = config.output?.cssModules?.auto ?? true;
    const { format = 'esm', shims, bundle = true, banner = {}, footer = {}, autoExtension = true, autoExternal, externalHelpers = false, redirect = {}, umdName, experiments } = config;
    const advancedEsm = experiments?.advancedEsm;
    const { rsbuildConfig: bundleConfig } = composeBundleConfig(bundle);
    const { rsbuildConfig: shimsConfig, enabledShims } = composeShimsConfig(format, shims);
    const formatConfig = composeFormatConfig({
        format,
        pkgJson: pkgJson,
        bundle,
        umdName,
        enabledShims,
        advancedEsm: advancedEsm ?? false
    });
    const externalHelpersConfig = composeExternalHelpersConfig(externalHelpers, pkgJson);
    const userExternalsConfig = composeExternalsConfig(format, config.output?.externals);
    const { config: outputFilenameConfig, jsExtension, dtsExtension } = composeOutputFilenameConfig(config, format, autoExtension, multiCompilerIndex, pkgJson);
    const { entryConfig, outBase } = await composeEntryConfig(config.source?.entry, config.bundle, rootPath, cssModulesAuto, config.outBase);
    const { config: bundlelessExternalConfig } = composeBundlelessExternalConfig(jsExtension, redirect, cssModulesAuto, bundle, outBase);
    const { config: targetConfig, externalsConfig: targetExternalsConfig, target } = composeTargetConfig(config.output?.target, format);
    const syntaxConfig = composeSyntaxConfig(target, config?.syntax);
    const autoExternalConfig = composeAutoExternalConfig({
        bundle,
        format,
        autoExternal,
        pkgJson,
        userExternals: config.output?.externals
    });
    const cssConfig = composeCssConfig(outBase, cssModulesAuto, config.bundle, banner?.css, footer?.css);
    const assetConfig = composeAssetConfig(bundle, format);
    const entryChunkConfig = composeEntryChunkConfig({
        useLoader: true !== advancedEsm && ('esm' === format || 'iife' === format),
        enabledImportMetaUrlShim: enabledShims.cjs['import.meta.url'],
        contextToWatch: outBase
    });
    const dtsConfig = await composeDtsConfig(config, format, dtsExtension);
    const externalsWarnConfig = composeExternalsWarnConfig(format, userExternalsConfig?.output?.externals, autoExternalConfig?.output?.externals);
    const minifyConfig = composeMinifyConfig(config);
    const bannerFooterConfig = composeBannerFooterConfig(banner, footer);
    const decoratorsConfig = composeDecoratorsConfig(compilerOptions, config.source?.decorators?.version);
    const printFileSizeConfig = composePrintFileSizeConfig(bundle, target);
    return (0, __rspack_external__rsbuild_core_1b356efc.mergeRsbuildConfig)(bundleConfig, formatConfig, shimsConfig, syntaxConfig, externalHelpersConfig, outputFilenameConfig, targetConfig, externalsWarnConfig, userExternalsConfig, autoExternalConfig, targetExternalsConfig, bundlelessExternalConfig, entryConfig, cssConfig, assetConfig, entryChunkConfig, minifyConfig, dtsConfig, bannerFooterConfig, decoratorsConfig, printFileSizeConfig);
}
async function composeCreateRsbuildConfig(rslibConfig) {
    const constantRsbuildConfig = await createConstantRsbuildConfig();
    const { lib: libConfigsArray, mode: _mode, root, plugins: sharedPlugins, dev: _dev, server: _server, logLevel, ...sharedRsbuildConfig } = rslibConfig;
    if (logLevel && !isDebug()) logger.level = logLevel;
    if (!Array.isArray(libConfigsArray) || 0 === libConfigsArray.length) throw new Error(`Expect "lib" field to be a non-empty array, but got: ${picocolors.cyan(JSON.stringify(libConfigsArray))}.`);
    const libConfigPromises = libConfigsArray.map(async (libConfig, index)=>{
        const userConfig = (0, __rspack_external__rsbuild_core_1b356efc.mergeRsbuildConfig)(sharedRsbuildConfig, libConfig);
        const libRsbuildConfig = await composeLibRsbuildConfig(userConfig, libConfigsArray.length > 1 ? index : null, root, sharedPlugins);
        userConfig.source ??= {};
        userConfig.source.entry = {};
        userConfig.output ??= {};
        delete userConfig.output.externals;
        const config = {
            format: libConfig.format ?? 'esm',
            config: (0, __rspack_external__rsbuild_core_1b356efc.mergeRsbuildConfig)(constantRsbuildConfig, libRsbuildConfig, omit(userConfig, {
                id: true,
                bundle: true,
                format: true,
                autoExtension: true,
                autoExternal: true,
                redirect: true,
                syntax: true,
                externalHelpers: true,
                banner: true,
                footer: true,
                dts: true,
                shims: true,
                umdName: true,
                outBase: true,
                experiments: true
            }))
        };
        if ('string' == typeof libConfig.id) config.id = libConfig.id;
        return config;
    });
    const composedRsbuildConfig = await Promise.all(libConfigPromises);
    return composedRsbuildConfig;
}
async function composeRsbuildEnvironments(rslibConfig) {
    const rsbuildConfigWithLibInfo = await composeCreateRsbuildConfig(rslibConfig);
    const environmentWithInfos = [];
    const usedIds = rsbuildConfigWithLibInfo.map(({ id })=>id).filter(Boolean);
    const environments = {};
    const formatCount = rsbuildConfigWithLibInfo.reduce((acc, { format })=>{
        acc[format] = (acc[format] ?? 0) + 1;
        return acc;
    }, {});
    const composeDefaultId = (format)=>{
        const nextDefaultId = (format, index)=>`${format}${1 === formatCount[format] && 0 === index ? '' : index}`;
        let index = 0;
        let candidateId = nextDefaultId(format, index);
        while(-1 !== usedIds.indexOf(candidateId))candidateId = nextDefaultId(format, ++index);
        usedIds.push(candidateId);
        return candidateId;
    };
    for (const { format, id, config } of rsbuildConfigWithLibInfo){
        const libId = 'string' == typeof id ? id : composeDefaultId(format);
        environments[libId] = config;
        environmentWithInfos.push({
            id: libId,
            format,
            config
        });
    }
    const conflictIds = usedIds.filter((id, index)=>usedIds.indexOf(id) !== index);
    if (conflictIds.length) throw new Error(`The following ids are duplicated: ${conflictIds.map((id)=>`"${id}"`).join(', ')}. Please change the "lib.id" to be unique.`);
    return {
        environments,
        environmentWithInfos
    };
}
const pruneEnvironments = (environments, libs)=>{
    if (!libs || 0 === libs.length) return environments;
    const filteredEnvironments = Object.fromEntries(Object.entries(environments).filter(([name])=>libs.includes(name)));
    if (0 === Object.keys(filteredEnvironments).length) throw new Error(`The following libs are not found: ${libs.map((lib)=>`"${lib}"`).join(', ')}.`);
    return filteredEnvironments;
};
async function watchFilesForRestart(files, restart) {
    if (!files.length) return;
    const chokidar = await import("../compiled/chokidar/index.js");
    const watcher = chokidar.watch(files, {
        ignoreInitial: true,
        ignorePermissionErrors: true
    });
    const callback = debounce(async (filePath)=>{
        watcher.close();
        await beforeRestart({
            filePath
        });
        await restart();
    }, 300);
    watcher.on('add', callback);
    watcher.on('change', callback);
    watcher.on('unlink', callback);
}
let cleaners = [];
const onBeforeRestart = (cleaner)=>{
    cleaners.push(cleaner);
};
const clearConsole = ()=>{
    if (isTTY() && !process.env.DEBUG) process.stdout.write('\x1B[H\x1B[2J');
};
const beforeRestart = async ({ filePath, clear = true } = {})=>{
    if (clear) clearConsole();
    if (filePath) {
        const filename = node_path.basename(filePath);
        logger.info(`restart because ${picocolors.yellow(filename)} is changed.\n`);
    } else logger.info('restarting...\n');
    for (const cleaner of cleaners)await cleaner();
    cleaners = [];
};
async function build(config, options = {}) {
    const { environments } = await composeRsbuildEnvironments(config);
    const rsbuildInstance = await (0, __rspack_external__rsbuild_core_1b356efc.createRsbuild)({
        callerName: 'rslib',
        config: {
            mode: 'production',
            root: config.root,
            plugins: config.plugins,
            dev: config.dev,
            server: config.server,
            logLevel: isDebug() ? 'info' : config.logLevel,
            environments: pruneEnvironments(environments, options.lib)
        }
    });
    const buildInstance = await rsbuildInstance.build({
        watch: options.watch
    });
    if (options.watch) onBeforeRestart(buildInstance.close);
    else await buildInstance.close();
    return rsbuildInstance;
}
function toArr(any) {
    return null == any ? [] : Array.isArray(any) ? any : [
        any
    ];
}
function toVal(out, key, val, opts) {
    var x, old = out[key], nxt = ~opts.string.indexOf(key) ? null == val || true === val ? '' : String(val) : 'boolean' == typeof val ? val : ~opts.boolean.indexOf(key) ? 'false' === val ? false : 'true' === val || (out._.push((x = +val, 0 * x === 0) ? x : val), !!val) : (x = +val, 0 * x === 0) ? x : val;
    out[key] = null == old ? nxt : Array.isArray(old) ? old.concat(nxt) : [
        old,
        nxt
    ];
}
function mri2(args, opts) {
    args = args || [];
    opts = opts || {};
    var k, arr, arg, name, val, out = {
        _: []
    };
    var i = 0, j = 0, idx = 0, len = args.length;
    const alibi = void 0 !== opts.alias;
    const strict = void 0 !== opts.unknown;
    const defaults = void 0 !== opts.default;
    opts.alias = opts.alias || {};
    opts.string = toArr(opts.string);
    opts.boolean = toArr(opts.boolean);
    if (alibi) for(k in opts.alias){
        arr = opts.alias[k] = toArr(opts.alias[k]);
        for(i = 0; i < arr.length; i++)(opts.alias[arr[i]] = arr.concat(k)).splice(i, 1);
    }
    for(i = opts.boolean.length; i-- > 0;){
        arr = opts.alias[opts.boolean[i]] || [];
        for(j = arr.length; j-- > 0;)opts.boolean.push(arr[j]);
    }
    for(i = opts.string.length; i-- > 0;){
        arr = opts.alias[opts.string[i]] || [];
        for(j = arr.length; j-- > 0;)opts.string.push(arr[j]);
    }
    if (defaults) for(k in opts.default){
        name = typeof opts.default[k];
        arr = opts.alias[k] = opts.alias[k] || [];
        if (void 0 !== opts[name]) {
            opts[name].push(k);
            for(i = 0; i < arr.length; i++)opts[name].push(arr[i]);
        }
    }
    const keys = strict ? Object.keys(opts.alias) : [];
    for(i = 0; i < len; i++){
        arg = args[i];
        if ('--' === arg) {
            out._ = out._.concat(args.slice(++i));
            break;
        }
        for(j = 0; j < arg.length && 45 === arg.charCodeAt(j); j++);
        if (0 === j) out._.push(arg);
        else if ('no-' === arg.substring(j, j + 3)) {
            name = arg.substring(j + 3);
            if (strict && !~keys.indexOf(name)) return opts.unknown(arg);
            out[name] = false;
        } else {
            for(idx = j + 1; idx < arg.length && 61 !== arg.charCodeAt(idx); idx++);
            name = arg.substring(j, idx);
            val = arg.substring(++idx) || i + 1 === len || 45 === ('' + args[i + 1]).charCodeAt(0) || args[++i];
            arr = 2 === j ? [
                name
            ] : name;
            for(idx = 0; idx < arr.length; idx++){
                name = arr[idx];
                if (strict && !~keys.indexOf(name)) return opts.unknown('-'.repeat(j) + name);
                toVal(out, name, idx + 1 < arr.length || val, opts);
            }
        }
    }
    if (defaults) {
        for(k in opts.default)if (void 0 === out[k]) out[k] = opts.default[k];
    }
    if (alibi) for(k in out){
        arr = opts.alias[k] || [];
        while(arr.length > 0)out[arr.shift()] = out[k];
    }
    return out;
}
const removeBrackets = (v)=>v.replace(/[<[].+/, "").trim();
const findAllBrackets = (v)=>{
    const ANGLED_BRACKET_RE_GLOBAL = /<([^>]+)>/g;
    const SQUARE_BRACKET_RE_GLOBAL = /\[([^\]]+)\]/g;
    const res = [];
    const parse = (match)=>{
        let variadic = false;
        let value = match[1];
        if (value.startsWith("...")) {
            value = value.slice(3);
            variadic = true;
        }
        return {
            required: match[0].startsWith("<"),
            value,
            variadic
        };
    };
    let angledMatch;
    while(angledMatch = ANGLED_BRACKET_RE_GLOBAL.exec(v))res.push(parse(angledMatch));
    let squareMatch;
    while(squareMatch = SQUARE_BRACKET_RE_GLOBAL.exec(v))res.push(parse(squareMatch));
    return res;
};
const getMriOptions = (options)=>{
    const result = {
        alias: {},
        boolean: []
    };
    for (const [index, option] of options.entries()){
        if (option.names.length > 1) result.alias[option.names[0]] = option.names.slice(1);
        if (option.isBoolean) if (option.negated) {
            const hasStringTypeOption = options.some((o, i)=>i !== index && o.names.some((name)=>option.names.includes(name)) && "boolean" == typeof o.required);
            if (!hasStringTypeOption) result.boolean.push(option.names[0]);
        } else result.boolean.push(option.names[0]);
    }
    return result;
};
const findLongest = (arr)=>arr.sort((a, b)=>a.length > b.length ? -1 : 1)[0];
const padRight = (str, length)=>str.length >= length ? str : `${str}${" ".repeat(length - str.length)}`;
const camelcase = (input)=>input.replace(/([a-z])-([a-z])/g, (_, p1, p2)=>p1 + p2.toUpperCase());
const setDotProp = (obj, keys, val)=>{
    let i = 0;
    let length = keys.length;
    let t = obj;
    let x;
    for(; i < length; ++i){
        x = t[keys[i]];
        t = t[keys[i]] = i === length - 1 ? val : null != x ? x : !~keys[i + 1].indexOf(".") && +keys[i + 1] > -1 ? [] : {};
    }
};
const setByType = (obj, transforms)=>{
    for (const key of Object.keys(transforms)){
        const transform = transforms[key];
        if (transform.shouldTransform) {
            obj[key] = Array.prototype.concat.call([], obj[key]);
            if ("function" == typeof transform.transformFunction) obj[key] = obj[key].map(transform.transformFunction);
        }
    }
};
const getFileName = (input)=>{
    const m = /([^\\\/]+)$/.exec(input);
    return m ? m[1] : "";
};
const camelcaseOptionName = (name)=>name.split(".").map((v, i)=>0 === i ? camelcase(v) : v).join(".");
class CACError extends Error {
    constructor(message){
        super(message);
        this.name = this.constructor.name;
        if ("function" == typeof Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
        else this.stack = new Error(message).stack;
    }
}
class Option {
    constructor(rawName, description, config){
        this.rawName = rawName;
        this.description = description;
        this.config = Object.assign({}, config);
        rawName = rawName.replace(/\.\*/g, "");
        this.negated = false;
        this.names = removeBrackets(rawName).split(",").map((v)=>{
            let name = v.trim().replace(/^-{1,2}/, "");
            if (name.startsWith("no-")) {
                this.negated = true;
                name = name.replace(/^no-/, "");
            }
            return camelcaseOptionName(name);
        }).sort((a, b)=>a.length > b.length ? 1 : -1);
        this.name = this.names[this.names.length - 1];
        if (this.negated && null == this.config.default) this.config.default = true;
        if (rawName.includes("<")) this.required = true;
        else if (rawName.includes("[")) this.required = false;
        else this.isBoolean = true;
    }
}
const processArgs = process.argv;
const platformInfo = `${process.platform}-${process.arch} node-${process.version}`;
class Command {
    constructor(rawName, description, config = {}, cli){
        this.rawName = rawName;
        this.description = description;
        this.config = config;
        this.cli = cli;
        this.options = [];
        this.aliasNames = [];
        this.name = removeBrackets(rawName);
        this.args = findAllBrackets(rawName);
        this.examples = [];
    }
    usage(text) {
        this.usageText = text;
        return this;
    }
    allowUnknownOptions() {
        this.config.allowUnknownOptions = true;
        return this;
    }
    ignoreOptionDefaultValue() {
        this.config.ignoreOptionDefaultValue = true;
        return this;
    }
    version(version, customFlags = "-v, --version") {
        this.versionNumber = version;
        this.option(customFlags, "Display version number");
        return this;
    }
    example(example) {
        this.examples.push(example);
        return this;
    }
    option(rawName, description, config) {
        const option = new Option(rawName, description, config);
        this.options.push(option);
        return this;
    }
    alias(name) {
        this.aliasNames.push(name);
        return this;
    }
    action(callback) {
        this.commandAction = callback;
        return this;
    }
    isMatched(name) {
        return this.name === name || this.aliasNames.includes(name);
    }
    get isDefaultCommand() {
        return "" === this.name || this.aliasNames.includes("!");
    }
    get isGlobalCommand() {
        return this instanceof GlobalCommand;
    }
    hasOption(name) {
        name = name.split(".")[0];
        return this.options.find((option)=>option.names.includes(name));
    }
    outputHelp() {
        const { name, commands } = this.cli;
        const { versionNumber, options: globalOptions, helpCallback } = this.cli.globalCommand;
        let sections = [
            {
                body: `${name}${versionNumber ? `/${versionNumber}` : ""}`
            }
        ];
        sections.push({
            title: "Usage",
            body: `  $ ${name} ${this.usageText || this.rawName}`
        });
        const showCommands = (this.isGlobalCommand || this.isDefaultCommand) && commands.length > 0;
        if (showCommands) {
            const longestCommandName = findLongest(commands.map((command)=>command.rawName));
            sections.push({
                title: "Commands",
                body: commands.map((command)=>`  ${padRight(command.rawName, longestCommandName.length)}  ${command.description}`).join("\n")
            });
            sections.push({
                title: "For more info, run any command with the `--help` flag",
                body: commands.map((command)=>`  $ ${name}${"" === command.name ? "" : ` ${command.name}`} --help`).join("\n")
            });
        }
        let options = this.isGlobalCommand ? globalOptions : [
            ...this.options,
            ...globalOptions || []
        ];
        if (!this.isGlobalCommand && !this.isDefaultCommand) options = options.filter((option)=>"version" !== option.name);
        if (options.length > 0) {
            const longestOptionName = findLongest(options.map((option)=>option.rawName));
            sections.push({
                title: "Options",
                body: options.map((option)=>`  ${padRight(option.rawName, longestOptionName.length)}  ${option.description} ${void 0 === option.config.default ? "" : `(default: ${option.config.default})`}`).join("\n")
            });
        }
        if (this.examples.length > 0) sections.push({
            title: "Examples",
            body: this.examples.map((example)=>{
                if ("function" == typeof example) return example(name);
                return example;
            }).join("\n")
        });
        if (helpCallback) sections = helpCallback(sections) || sections;
        console.log(sections.map((section)=>section.title ? `${section.title}:
${section.body}` : section.body).join("\n\n"));
    }
    outputVersion() {
        const { name } = this.cli;
        const { versionNumber } = this.cli.globalCommand;
        if (versionNumber) console.log(`${name}/${versionNumber} ${platformInfo}`);
    }
    checkRequiredArgs() {
        const minimalArgsCount = this.args.filter((arg)=>arg.required).length;
        if (this.cli.args.length < minimalArgsCount) throw new CACError(`missing required args for command \`${this.rawName}\``);
    }
    checkUnknownOptions() {
        const { options, globalCommand } = this.cli;
        if (!this.config.allowUnknownOptions) {
            for (const name of Object.keys(options))if ("--" !== name && !this.hasOption(name) && !globalCommand.hasOption(name)) throw new CACError(`Unknown option \`${name.length > 1 ? `--${name}` : `-${name}`}\``);
        }
    }
    checkOptionValue() {
        const { options: parsedOptions, globalCommand } = this.cli;
        const options = [
            ...globalCommand.options,
            ...this.options
        ];
        for (const option of options){
            const value = parsedOptions[option.name.split(".")[0]];
            if (option.required) {
                const hasNegated = options.some((o)=>o.negated && o.names.includes(option.name));
                if (true === value || false === value && !hasNegated) throw new CACError(`option \`${option.rawName}\` value is missing`);
            }
        }
    }
}
class GlobalCommand extends Command {
    constructor(cli){
        super("@@global@@", "", {}, cli);
    }
}
var __assign = Object.assign;
class CAC extends EventEmitter {
    constructor(name = ""){
        super();
        this.name = name;
        this.commands = [];
        this.rawArgs = [];
        this.args = [];
        this.options = {};
        this.globalCommand = new GlobalCommand(this);
        this.globalCommand.usage("<command> [options]");
    }
    usage(text) {
        this.globalCommand.usage(text);
        return this;
    }
    command(rawName, description, config) {
        const command = new Command(rawName, description || "", config, this);
        command.globalCommand = this.globalCommand;
        this.commands.push(command);
        return command;
    }
    option(rawName, description, config) {
        this.globalCommand.option(rawName, description, config);
        return this;
    }
    help(callback) {
        this.globalCommand.option("-h, --help", "Display this message");
        this.globalCommand.helpCallback = callback;
        this.showHelpOnExit = true;
        return this;
    }
    version(version, customFlags = "-v, --version") {
        this.globalCommand.version(version, customFlags);
        this.showVersionOnExit = true;
        return this;
    }
    example(example) {
        this.globalCommand.example(example);
        return this;
    }
    outputHelp() {
        if (this.matchedCommand) this.matchedCommand.outputHelp();
        else this.globalCommand.outputHelp();
    }
    outputVersion() {
        this.globalCommand.outputVersion();
    }
    setParsedInfo({ args, options }, matchedCommand, matchedCommandName) {
        this.args = args;
        this.options = options;
        if (matchedCommand) this.matchedCommand = matchedCommand;
        if (matchedCommandName) this.matchedCommandName = matchedCommandName;
        return this;
    }
    unsetMatchedCommand() {
        this.matchedCommand = void 0;
        this.matchedCommandName = void 0;
    }
    parse(argv = processArgs, { run = true } = {}) {
        this.rawArgs = argv;
        if (!this.name) this.name = argv[1] ? getFileName(argv[1]) : "cli";
        let shouldParse = true;
        for (const command of this.commands){
            const parsed = this.mri(argv.slice(2), command);
            const commandName = parsed.args[0];
            if (command.isMatched(commandName)) {
                shouldParse = false;
                const parsedInfo = __assign(__assign({}, parsed), {
                    args: parsed.args.slice(1)
                });
                this.setParsedInfo(parsedInfo, command, commandName);
                this.emit(`command:${commandName}`, command);
            }
        }
        if (shouldParse) {
            for (const command of this.commands)if ("" === command.name) {
                shouldParse = false;
                const parsed = this.mri(argv.slice(2), command);
                this.setParsedInfo(parsed, command);
                this.emit("command:!", command);
            }
        }
        if (shouldParse) {
            const parsed = this.mri(argv.slice(2));
            this.setParsedInfo(parsed);
        }
        if (this.options.help && this.showHelpOnExit) {
            this.outputHelp();
            run = false;
            this.unsetMatchedCommand();
        }
        if (this.options.version && this.showVersionOnExit && null == this.matchedCommandName) {
            this.outputVersion();
            run = false;
            this.unsetMatchedCommand();
        }
        const parsedArgv = {
            args: this.args,
            options: this.options
        };
        if (run) this.runMatchedCommand();
        if (!this.matchedCommand && this.args[0]) this.emit("command:*");
        return parsedArgv;
    }
    mri(argv, command) {
        const cliOptions = [
            ...this.globalCommand.options,
            ...command ? command.options : []
        ];
        const mriOptions = getMriOptions(cliOptions);
        let argsAfterDoubleDashes = [];
        const doubleDashesIndex = argv.indexOf("--");
        if (doubleDashesIndex > -1) {
            argsAfterDoubleDashes = argv.slice(doubleDashesIndex + 1);
            argv = argv.slice(0, doubleDashesIndex);
        }
        let parsed = mri2(argv, mriOptions);
        parsed = Object.keys(parsed).reduce((res, name)=>__assign(__assign({}, res), {
                [camelcaseOptionName(name)]: parsed[name]
            }), {
            _: []
        });
        const args = parsed._;
        const options = {
            "--": argsAfterDoubleDashes
        };
        const ignoreDefault = command && command.config.ignoreOptionDefaultValue ? command.config.ignoreOptionDefaultValue : this.globalCommand.config.ignoreOptionDefaultValue;
        let transforms = Object.create(null);
        for (const cliOption of cliOptions){
            if (!ignoreDefault && void 0 !== cliOption.config.default) for (const name of cliOption.names)options[name] = cliOption.config.default;
            if (Array.isArray(cliOption.config.type)) {
                if (void 0 === transforms[cliOption.name]) {
                    transforms[cliOption.name] = Object.create(null);
                    transforms[cliOption.name]["shouldTransform"] = true;
                    transforms[cliOption.name]["transformFunction"] = cliOption.config.type[0];
                }
            }
        }
        for (const key of Object.keys(parsed))if ("_" !== key) {
            const keys = key.split(".");
            setDotProp(options, keys, parsed[key]);
            setByType(options, transforms);
        }
        return {
            args,
            options
        };
    }
    runMatchedCommand() {
        const { args, options, matchedCommand: command } = this;
        if (!command || !command.commandAction) return;
        command.checkUnknownOptions();
        command.checkOptionValue();
        command.checkRequiredArgs();
        const actionArgs = [];
        command.args.forEach((arg, index)=>{
            if (arg.variadic) actionArgs.push(args.slice(index));
            else actionArgs.push(args[index]);
        });
        actionArgs.push(options);
        return command.commandAction.apply(this, actionArgs);
    }
}
const cac = (name = "")=>new CAC(name);
const dist = cac;
const getEnvDir = (cwd, envDir)=>{
    if (envDir) return node_path.isAbsolute(envDir) ? envDir : node_path.resolve(cwd, envDir);
    return cwd;
};
const parseEntryOption = (entries)=>{
    if (!entries?.length) return;
    const entryList = [];
    for (const rawEntry of entries){
        const value = rawEntry?.trim();
        if (!value) continue;
        const equalIndex = value.indexOf('=');
        if (equalIndex > -1) {
            const name = value.slice(0, equalIndex).trim();
            const entryPath = value.slice(equalIndex + 1).trim();
            if (name && entryPath) {
                entryList.push({
                    key: name,
                    value: entryPath,
                    explicit: true
                });
                continue;
            }
        }
        const basename = node_path.basename(value, node_path.extname(value));
        entryList.push({
            key: basename,
            value,
            explicit: false
        });
    }
    const keyCount = {};
    for (const { key, explicit } of entryList)if (!explicit) keyCount[key] = (keyCount[key] ?? 0) + 1;
    const keyIndex = {};
    const parsed = {};
    for (const { key, value, explicit } of entryList){
        const needsIndex = !explicit && (keyCount[key] ?? 0) > 1;
        const finalKey = needsIndex ? `${key}${keyIndex[key] ?? 0}` : key;
        if (needsIndex) keyIndex[key] = (keyIndex[key] ?? 0) + 1;
        parsed[finalKey] = value;
    }
    return Object.keys(parsed).length ? parsed : void 0;
};
const applyCliOptions = (config, options, root)=>{
    if (options.root) config.root = root;
    if (options.logLevel) config.logLevel = options.logLevel;
    for (const lib of config.lib){
        if (void 0 !== options.format) lib.format = options.format;
        if (void 0 !== options.bundle) lib.bundle = options.bundle;
        if (void 0 !== options.tsconfig) {
            lib.source ||= {};
            lib.source.tsconfigPath = options.tsconfig;
        }
        const entry = parseEntryOption(options.entry);
        if (void 0 !== entry) {
            lib.source ||= {};
            lib.source.entry = entry;
        }
        const syntax = options.syntax;
        if (void 0 !== syntax) lib.syntax = syntax;
        if (void 0 !== options.dts) lib.dts = options.dts;
        if (void 0 !== options.autoExtension) lib.autoExtension = options.autoExtension;
        if (void 0 !== options.autoExternal) lib.autoExternal = options.autoExternal;
        lib.output ??= {};
        if (void 0 !== options.target) lib.output.target = options.target;
        if (void 0 !== options.minify) lib.output.minify = options.minify;
        if (void 0 !== options.clean) lib.output.cleanDistPath = options.clean;
        const externals = options.externals?.filter(Boolean) ?? [];
        if (externals.length > 0) lib.output.externals = externals;
        if (options.distPath) lib.output.distPath = {
            ...'object' == typeof lib.output.distPath ? lib.output.distPath : {},
            root: options.distPath
        };
    }
};
async function initConfig(options) {
    const cwd = process.cwd();
    const root = options.root ? getAbsolutePath(cwd, options.root) : cwd;
    const envs = (0, __rspack_external__rsbuild_core_1b356efc.loadEnv)({
        cwd: getEnvDir(root, options.envDir),
        mode: options.envMode
    });
    onBeforeRestart(envs.cleanup);
    const { content: config, filePath: configFilePath } = await loadConfig({
        cwd: root,
        path: options.config,
        envMode: options.envMode,
        loader: options.configLoader
    });
    if (void 0 === configFilePath) {
        config.lib = [
            {}
        ];
        logger.debug('No config file found. Falling back to CLI options for the default library.');
    }
    config.source ||= {};
    config.source.define = {
        ...envs.publicVars,
        ...config.source.define
    };
    applyCliOptions(config, options, root);
    if (isDebugKey([
        'rslib'
    ])) {
        logger.debug('Rslib config used to generate Rsbuild environments:');
        logger.debug(`\n${node_util.inspect(config, {
            depth: null,
            colors: true
        })}`);
    }
    return {
        config,
        configFilePath,
        watchFiles: [
            configFilePath,
            ...envs.filePaths
        ].filter(Boolean)
    };
}
async function inspect(config, options = {}) {
    const { environments } = await composeRsbuildEnvironments(config);
    const rsbuildInstance = await (0, __rspack_external__rsbuild_core_1b356efc.createRsbuild)({
        callerName: 'rslib',
        config: {
            mode: 'production',
            root: config.root,
            plugins: config.plugins,
            dev: config.dev,
            server: config.server,
            logLevel: isDebug() ? 'info' : config.logLevel,
            environments: pruneEnvironments(environments, options.lib)
        }
    });
    await rsbuildInstance.inspectConfig({
        mode: options.mode,
        verbose: options.verbose,
        outputPath: options.output,
        writeToDisk: true,
        extraConfigs: {
            rslib: config
        }
    });
    return rsbuildInstance;
}
async function startMFDevServer(config, options = {}) {
    const rsbuildInstance = await initMFRsbuild(config, options);
    return rsbuildInstance;
}
async function initMFRsbuild(config, options = {}) {
    const { environments, environmentWithInfos } = await composeRsbuildEnvironments(config);
    const selectedEnvironmentIds = environmentWithInfos.filter((env)=>{
        const isMf = 'mf' === env.format;
        if (!options?.lib || 0 === options.lib.length) return isMf;
        return env.id && options.lib.includes(env.id);
    }).map((env)=>env.id);
    if (!selectedEnvironmentIds.length) throw new Error(`No mf format found in ${options.lib ? `libs ${options.lib.map((lib)=>`"${lib}"`).join(', ')}` : 'your config'}, please check your config to ensure that the mf format is enabled correctly.`);
    const selectedEnvironments = pruneEnvironments(environments, selectedEnvironmentIds);
    const rsbuildInstance = await (0, __rspack_external__rsbuild_core_1b356efc.createRsbuild)({
        callerName: 'rslib',
        config: {
            mode: 'development',
            root: config.root,
            plugins: config.plugins,
            dev: config.dev,
            server: config.server,
            logLevel: isDebug() ? 'info' : config.logLevel,
            environments: selectedEnvironments
        }
    });
    const devServer = await rsbuildInstance.startDevServer();
    onBeforeRestart(devServer.server.close);
    return rsbuildInstance;
}
const applyCommonOptions = (cli)=>{
    cli.option('-c, --config <config>', 'specify the configuration file, can be a relative or absolute path').option('-r, --root <root>', 'specify the project root directory, can be an absolute path or a path relative to cwd').option('--env-mode <mode>', 'specify the env mode to load the `.env.[mode]` file').option('--config-loader <loader>', 'Set the config file loader (auto | jiti | native)', {
        default: 'auto'
    }).option('--env-dir <dir>', 'specify the directory to load `.env` files').option('--log-level <level>', 'set the log level (info | warn | error | silent)').option('--lib <id>', 'specify the library (repeatable, e.g. --lib esm --lib cjs)', {
        type: [
            String
        ],
        default: []
    });
};
function runCli() {
    const cli = dist('rslib');
    cli.version("0.18.4");
    applyCommonOptions(cli);
    const buildDescription = `build the library for production ${picocolors.dim('(default if no command is given)')}`;
    const buildCommand = cli.command('', buildDescription).alias('build');
    const inspectCommand = cli.command('inspect', 'inspect the Rsbuild / Rspack configs of Rslib projects');
    const mfDevCommand = cli.command('mf-dev', 'start Rsbuild dev server of Module Federation format');
    buildCommand.option('-w, --watch', 'turn on watch mode, watch for changes and rebuild').option('--entry <entry>', 'set entry file or pattern (repeatable)', {
        type: [
            String
        ],
        default: []
    }).option('--dist-path <dir>', 'set output directory').option('--bundle', 'enable bundle mode (use --no-bundle to disable)').option('--format <format>', 'specify the output format (esm | cjs | umd | mf | iife)').option('--syntax <syntax>', 'set build syntax target (repeatable)').option('--target <target>', 'set runtime target (web | node)').option('--dts', 'emit declaration files (use --no-dts to disable)').option('--externals <pkg>', 'add package to externals (repeatable)', {
        type: [
            String
        ],
        default: []
    }).option('--minify', 'minify output (use --no-minify to disable)').option('--clean', 'clean output directory before build (use --no-clean to disable)').option('--auto-extension', 'control automatic extension redirect (use --no-auto-extension to disable)').option('--auto-external', 'control automatic dependency externalization (use --no-auto-external to disable)').option('--tsconfig <path>', 'use specific tsconfig (relative to project root)').action(async (options)=>{
        try {
            const cliBuild = async ()=>{
                const { config, watchFiles } = await initConfig(options);
                if (options.watch) {
                    config.plugins = config.plugins || [];
                    config.plugins.push({
                        name: 'rslib:on-after-build',
                        setup (api) {
                            api.onAfterBuild(({ isFirstCompile })=>{
                                if (isFirstCompile) logger.success('build complete, watching for changes...');
                            });
                        }
                    });
                    watchFilesForRestart(watchFiles, async ()=>{
                        await cliBuild();
                    });
                }
                await build(config, options);
            };
            await cliBuild();
        } catch (err) {
            logger.error('Failed to build.');
            if (err instanceof AggregateError) for (const error of err.errors)logger.error(error);
            else logger.error(err);
            process.exit(1);
        }
    });
    inspectCommand.option('--output <output>', 'specify inspect content output path', {
        default: '.rsbuild'
    }).option('--verbose', 'show full function definitions in output').action(async (options)=>{
        try {
            const { config } = await initConfig(options);
            await inspect(config, {
                lib: options.lib,
                mode: options.mode,
                output: options.output,
                verbose: options.verbose
            });
        } catch (err) {
            logger.error('Failed to inspect config.');
            logger.error(err);
            process.exit(1);
        }
    });
    mfDevCommand.action(async (options)=>{
        try {
            const cliMfDev = async ()=>{
                const { config, watchFiles } = await initConfig(options);
                await startMFDevServer(config, {
                    lib: options.lib
                });
                watchFilesForRestart(watchFiles, async ()=>{
                    await cliMfDev();
                });
            };
            await cliMfDev();
        } catch (err) {
            logger.error('Failed to start mf-dev.');
            logger.error(err);
            process.exit(1);
        }
    });
    cli.help((sections)=>{
        sections.shift();
        for (const section of sections){
            if ('Usage' === section.title) section.body = section.body.replace('$ rslib', picocolors.yellow('$ rslib [command] [options]'));
            if ('Commands' === section.title) section.body = section.body.replace(`         ${buildDescription}`, `build    ${buildDescription}`);
            if (section.title?.startsWith('For more info')) {
                section.title = picocolors.dim('  For details on a sub-command, run');
                section.body = picocolors.dim('  $ rslib <command> -h');
            } else section.title = picocolors.cyan(section.title);
        }
    });
    cli.parse();
}
function initNodeEnv() {
    if (!process.env.NODE_ENV) {
        const command = process.argv[2] ?? '';
        process.env.NODE_ENV = [
            'build'
        ].includes(command) ? 'production' : 'development';
    }
}
function setupLogLevel() {
    const logLevelIndex = process.argv.findIndex((item)=>'--log-level' === item || '--logLevel' === item);
    if (-1 !== logLevelIndex) {
        const level = process.argv[logLevelIndex + 1];
        if (level && [
            'warn',
            'error',
            'silent'
        ].includes(level) && !isDebug()) logger.level = level;
    }
}
function prepareCli() {
    initNodeEnv();
    setupLogLevel();
    const { npm_execpath } = process.env;
    if (!npm_execpath || npm_execpath.includes('npx-cli.js') || npm_execpath.includes('.bun')) logger.log();
    logger.greet(`  Rslib v0.18.4\n`);
}
const src_version = "0.18.4";
export * as rsbuild from "@rsbuild/core";
export { logger } from "../compiled/rslog/index.js";
export { rspack } from "@rsbuild/core";
export { build, composeCreateRsbuildConfig as unstable_composeCreateRsbuildConfig, defineConfig, inspect, loadConfig, prepareCli, runCli, src_version as version, startMFDevServer };
